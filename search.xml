<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[코드사이닝의 이해]]></title>
      <url>/2018/11/17/Signing/</url>
      <content type="html"><![CDATA[<h1><span id="injeungseo-jongryu">인증서 종류</span></h1>
<ul>
<li><strong>Certificate Signing Request 개발자 인증 요청서</strong></li>
<li><strong>Development Certificate 개발자 인증서</strong></li>
<li><strong>Distribution Certificate 배포자 인증서</strong></li>
<li><strong>Provisioning Profile 개발자 인증서, App ID, 테스트할 Device 정보가 포함되어 있는 파일</strong></li>
</ul>
<p>코드 사이닝을 이해하기 위해서는 아래와 같은 사실 때문이다.</p>
<blockquote>
<p>단지 애플만이 자신들의 하드웨어에서 어떤 소프트웨어가 동작하도록 허락된 주체이기 때문이다.</p>
</blockquote>
<p>실제로 매번 앱이 실행될때마다 앱은 애플로 부터 인증을 받았는지 그래서 앱을 실행할 수 있는 권한이 주어졌는지 확인을 한다.</p>
<br>
<h2><span id="apple-injeungseo">Apple 인증서</span></h2>
<p>애플만이 앱을 실행할 권한을 가지기 때문에 개발자들은 디바이스에서 테스트를 하기 위해서는 애플이 개발자를 신뢰하여 <strong>애플 대신 앱을 실행할 권한을 부여</strong>받아야만 한다.</p>
<ol>
<li>KeyChain 앱에서 **Certificate Signing Request(CER)**를 생성한다.</li>
</ol>
<ul>
<li>키체인 앱은 공개키와 개인키를 자동으로 생성한다. (목록은 <code>key</code>카테고리에서 확인할 수 있다) 이 공개키를 통해서 내가 누구인지 애플쪽에서 확인할 키이기 때문에 잃어버리지 않도록 잘 보관해야한다.</li>
<li>애플에 보낼 CertSigningRequest 파일을 생성한다. 이 파일은 나의 이름, 이메일, 공개키를 포함하고 있으며, 개인키를 이용하여 사이닝된다.</li>
<li>이 공개키, 개인키 메커니즘을 통해서 정말 내가 만들었는지 확인할 수 있다.</li>
</ul>
<ol start="2">
<li>CSR을 애플에 업로드하면서 인증서를 요청하면 애플측에서는 간단한 확인 작업 후 개발 인증서를 발급해준다.  이 인증서를 받아서 키체인앱에 드래그앤드롭으로 추가하면 <code>my certificate</code> 카테고리에 추가됨을 확인할 수 있다.</li>
</ol>
<ul>
<li>더블클릭해서 내용을 보면 애플을 통해서 발급받았으며, 애플은 나를 신뢰한다는 정보를 담고 있다.</li>
<li><strong>이 인증서는 앱을 사인할 때 사용된다.</strong></li>
<li>여기까지 진행하면 내가 누구인지를 애플에 알림으로써 애플이 나에게 인증서를 발급하고 앱을 사인할 수 있도록 허락밭은 상태이다.</li>
</ul>
<br>
<h2><span id="provisioning-profile">Provisioning Profile</span></h2>
<p>추가적으로 필요한 요청은 나의 디바이스(iphone/ipad)가 나를 신뢰할 수 있는지를 알아야 앱을 설치할 수가 있다.<br>
이때 필요한 것이 <strong>PP(Provisioning Profile)파일</strong> 이다.</p>
<ul>
<li>
<p>프로비저닝 프로파일을 만든다는 것은 나의 iOS 디바이스들을 <u>앞 단계에서 만든 인증서와 연결하는 것</u>을 의미한다. 그 결과로 만들어진 <code>*.mobileprovision</code> 파일은 나의 iOS 앱을 컴파일하는 과정에서 사용되며 또한 앱을 테스트하려고 하는 디바이스에 설치가 되어야 한다.</p>
</li>
<li>
<p>프로비저닝 프로파일을 생성할 때 연동한 AppID와 실제 컴파일하려는 앱의 ID가 일치해야만 빌드되므로 각 프로젝트마다 각각의 PP파일을 갖게 된다.</p>
</li>
<li>
<p>프로젝트를 생성하면 자동으로 <code>automatic manage signing</code>에 체크가 되어 자동으로 pp가 생성된다. 이것을 해제하여 자동생성을 막는 것이 좋다.! 되도록이면 직접 생성하고 관리하는 버릇을 들이자</p>
</li>
<li>
<p>설치방법</p>
</li>
</ul>
<ol>
<li>
<p>Identifier &gt; AppIDs  — 새로운 앱추가</p>
</li>
<li>
<p>Certificates &gt; Development — 개발용 인증서 추가</p>
</li>
</ol>
<ul>
<li>
<p>키체인 접근 &gt; 인증서 지원 &gt; 인증 기관에서 인증서 요청</p>
</li>
<li>
<p>사용자 이메일, 이름, 디스크에 저장됨을 누른후 생성</p>
</li>
<li>
<p><a href="http://comxp.tistory.com/298" target="_blank" rel="noopener">CER 생성</a></p>
</li>
<li>
<p>생성 후에 *.cer 파일을 저장한다 (일반적으로 ios_development.cer)</p>
</li>
</ul>
<ol start="3">
<li>Provisioning Profiles &gt; Development — pp파일 생성</li>
</ol>
<ul>
<li>우측 상단의 + 버튼을 누른 후 <strong>iOS App Development</strong> 를 체크해준다.</li>
<li>Select App ID에서 아까 추가해준 App ID를 선택한다.</li>
<li>Select Device를 선택해주고 만약 등록되어있지 않다면 Device &gt; iPhone(or another Deviece)를 선택 후 등록해준다.</li>
<li>XS or XS Max의 경우 UDID가 아이튠즈에 나오지 않으므로 Xcode 에서 window &gt; Device and Simulators 를 누른후 <code>identifier</code>의 넘버를 긁어온다 (넘버사이에 - 가 있는게 기존넘버와 다른점이랄까…당황)</li>
<li>이름은 대부분 <em>XX의 iPhone XS</em> 이런식으로 등록</li>
<li>iphone의 경우 한 아이디당 100대까지 등록 가능하다.</li>
<li>pp 파일이름을 정해주고 등록하면 pp 파일이 생성된다 (*.mobileprovision)</li>
<li>다운로드</li>
</ul>
<ol start="4">
<li>Xcode의 프로젝트로 들어와서 &gt; general &gt; signing 에 import 해준다.</li>
</ol>
<ul>
<li>debug 와 release가 있다. (development / distribution)</li>
</ul>
<ol start="5">
<li>Distribution도 위와같이 진행해주면된다 .</li>
</ol>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title></title>
      <url>/2018/11/17/%E1%84%8F%E1%85%A9%E1%84%83%E1%85%B3%E1%84%89%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%82%E1%85%B5%E1%86%BC%E1%84%8B%E1%85%B4%E1%84%8B%E1%85%B5%E1%84%92%E1%85%A2/</url>
      <content type="html"><![CDATA[<h1><span id="injeungseo-jongryu">인증서 종류</span></h1>
<ul>
<li><strong>Certificate Signing Request 개발자 인증 요청서</strong></li>
<li><strong>Development Certificate 개발자 인증서</strong></li>
<li><strong>Distribution Certificate 배포자 인증서</strong></li>
<li><strong>Provisioning Profile 개발자 인증서, App ID, 테스트할 Device 정보가 포함되어 있는 파일</strong></li>
</ul>
<p>코드 사이닝을 이해하기 위해서는 아래와 같은 사실 때문이다.</p>
<blockquote>
<p>단지 애플만이 자신들의 하드웨어에서 어떤 소프트웨어가 동작하도록 허락된 주체이기 때문이다.</p>
</blockquote>
<p>실제로 매번 앱이 실행될때마다 앱은 애플로 부터 인증을 받았는지 그래서 앱을 실행할 수 있는 권한이 주어졌는지 확인을 한다.</p>
<br>
<h2><span id="apple-injeungseo">Apple 인증서</span></h2>
<p>애플만이 앱을 실행할 권한을 가지기 때문에 개발자들은 디바이스에서 테스트를 하기 위해서는 애플이 개발자를 신뢰하여 <strong>애플 대신 앱을 실행할 권한을 부여</strong>받아야만 한다.</p>
<ol>
<li>KeyChain 앱에서 **Certificate Signing Request(CER)**를 생성한다.
<ul>
<li>키체인 앱은 공개키와 개인키를 자동으로 생성한다. (목록은 <code>key</code>카테고리에서 확인할 수 있다) 이 공개키를 통해서 내가 누구인지 애플쪽에서 확인할 키이기 때문에 잃어버리지 않도록 잘 보관해야한다.</li>
<li>애플에 보낼 CertSigningRequest 파일을 생성한다. 이 파일은 나의 이름, 이메일, 공개키를 포함하고 있으며, 개인키를 이용하여 사이닝된다.
<ul>
<li>이 공개키, 개인키 메커니즘을 통해서 정말 내가 만들었는지 확인할 수 있다.</li>
</ul>
</li>
</ul>
</li>
<li>CSR을 애플에 업로드하면서 인증서를 요청하면 애플측에서는 간단한 확인 작업 후 개발 인증서를 발급해준다.  이 인증서를 받아서 키체인앱에 드래그앤드롭으로 추가하면 <code>my certificate</code> 카테고리에 추가됨을 확인할 수 있다.
<ul>
<li>더블클릭해서 내용을 보면 애플을 통해서 발급받았으며, 애플은 나를 신뢰한다는 정보를 담고 있다.</li>
<li><strong>이 인증서는 앱을 사인할 때 사용된다.</strong></li>
<li>여기까지 진행하면 내가 누구인지를 애플에 알림으로써 애플이 나에게 인증서를 발급하고 앱을 사인할 수 있도록 허락밭은 상태이다.</li>
</ul>
</li>
</ol>
<br>
<h2><span id="provisioning-profile">Provisioning Profile</span></h2>
<p>추가적으로 필요한 요청은 나의 디바이스(iphone/ipad)가 나를 신뢰할 수 있는지를 알아야 앱을 설치할 수가 있다.<br>
이때 필요한 것이 <strong>PP(Provisioning Profile)파일</strong> 이다.</p>
<ul>
<li>
<p>프로비저닝 프로파일을 만든다는 것은 나의 iOS 디바이스들을 <u>앞 단계에서 만든 인증서와 연결하는 것</u>을 의미한다. 그 결과로 만들어진 <code>*.mobileprovision</code> 파일은 나의 iOS 앱을 컴파일하는 과정에서 사용되며 또한 앱을 테스트하려고 하는 디바이스에 설치가 되어야 한다.</p>
</li>
<li>
<p>프로비저닝 프로파일을 생성할 때 연동한 AppID와 실제 컴파일하려는 앱의 ID가 일치해야만 빌드되므로 각 프로젝트마다 각각의 PP파일을 갖게 된다.</p>
</li>
<li>
<p>프로젝트를 생성하면 자동으로 <code>automatic manage signing</code>에 체크가 되어 자동으로 pp가 생성된다. 이것을 해제하여 자동생성을 막는 것이 좋다.! 되도록이면 직접 생성하고 관리하는 버릇을 들이자</p>
</li>
<li>
<p>설치방법</p>
<ol>
<li>
<p>Identifier &gt; AppIDs  — 새로운 앱추가</p>
</li>
<li>
<p>Certificates &gt; Development — 개발용 인증서 추가</p>
<ul>
<li>
<p>키체인 접근 &gt; 인증서 지원 &gt; 인증 기관에서 인증서 요청</p>
</li>
<li>
<p>사용자 이메일, 이름, 디스크에 저장됨을 누른후 생성</p>
</li>
<li>
<p><a href="http://comxp.tistory.com/298" target="_blank" rel="noopener">CER 생성</a></p>
</li>
<li>
<p>생성 후에 *.cer 파일을 저장한다 (일반적으로 ios_development.cer)</p>
</li>
</ul>
</li>
<li>
<p>Provisioning Profiles &gt; Development — pp파일 생성</p>
<ul>
<li>우측 상단의 + 버튼을 누른 후 <strong>iOS App Development</strong> 를 체크해준다.</li>
<li>Select App ID에서 아까 추가해준 App ID를 선택한다.</li>
<li>Select Device를 선택해주고 만약 등록되어있지 않다면 Device &gt; iPhone(or another Deviece)를 선택 후 등록해준다.
<ul>
<li>XS or XS Max의 경우 UDID가 아이튠즈에 나오지 않으므로 Xcode 에서 window &gt; Device and Simulators 를 누른후 <code>identifier</code>의 넘버를 긁어온다 (넘버사이에 - 가 있는게 기존넘버와 다른점이랄까…당황)</li>
<li>이름은 대부분 <em>XX의 iPhone XS</em> 이런식으로 등록</li>
<li>iphone의 경우 한 아이디당 100대까지 등록 가능하다.</li>
</ul>
</li>
<li>pp 파일이름을 정해주고 등록하면 pp 파일이 생성된다 (*.mobileprovision)</li>
<li>다운로드</li>
</ul>
</li>
<li>
<p>Xcode의 프로젝트로 들어와서 &gt; general &gt; signing 에 import 해준다.</p>
<ul>
<li>debug 와 release가 있다. (development / distribution)</li>
</ul>
</li>
<li>
<p>Distribution도 위와같이 진행해주면된다 .</p>
</li>
</ol>
</li>
</ul>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Quick Sort]]></title>
      <url>/2018/08/18/algo-quickSort/</url>
      <content type="html"><![CDATA[<h1><span id="kwig-jeongryeol">퀵 정렬</span></h1>
<ul>
<li>
<p>기준 값(pivot)을 중심으로 전체 원소를 왼쪽 부분집합과 오른쪽 부분집합으로 분할(Divide)한다. =&gt; partitioning이라고 한다.</p>
</li>
<li>
<p>전체 원소에 대해서 정렬을 수행하지 않는다.</p>
</li>
<li>
<p>피봇을 정하는 기준 : 첫 인덱스, 마지막 인덱스, 가운데 인덱스 (풀이자의 자유)</p>
</li>
<li>
<p>피봇을 어떤 것을 정하느냐( &amp; partitioning) 에 따라서 성능에 큰 영향을 미친다. (경우에 따라 시간복잡도가 달라진다.)</p>
</li>
<li>
<p>Divede -and -Conquer paradigm</p>
</li>
</ul>
<h2><span id="solution">solution</span></h2>
<ol>
<li>피봇을 정한다.</li>
<li>첫번째 인덱스는 <strong>L</strong>,  마지막인덱스는 <strong>R</strong>로 지정한다.</li>
<li>피봇을 기준으로 작은값은 앞으로 , 큰값은 뒤로 보낸다.</li>
<li>나눠진 파트에서 다시 재귀적으로 파티셔닝을 한다. (각 부분의 크기가 1이 될 때 까지)</li>
</ol>
]]></content>
      
        <categories>
            
            <category> ALGORISM </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 정렬 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Dependency Injection,DI]]></title>
      <url>/2018/08/11/iOS-DependencyInjection/</url>
      <content type="html"><![CDATA[<h1><span id="dependency-injection">Dependency Injection</span></h1>
<p>OOP 패러다임 베이스에서 application을 개발할 때, 소프트웨어를 테스트하려면 IoC(Inversion of Control) 원칙을 따르게 된다. 그래서 일반적으로 각 클래스에 필요한 종속성을 제공하는 것으로 <strong>DI 패턴</strong>을 사용합니다.</p>
<p>이 포스팅에서는 Swift에서의 DI의 구현에 초점을 맞춰서 작성한다.</p>
<br>
<h4><span id="ioc-jeeoyi-yeogjeon">IoC :: 제어의 역전</span></h4>
<blockquote>
<p>마틴 파울러의 “IoC Inversion of Control” 문서에서 다룬 내용을 기반으로 설명합니다.</p>
</blockquote>
<p>프로그래밍을 할 때, 관련이 깊은 제어와 속성들을 하나로 묶어 객체를 만들고, 그 객체들이 서로 상호작용 하도록 하는 것이 OOP의 주된 개념이다. 또한 단위 제어를 객체에 묶었더라도 여전히 객체들을 제어해야한다. 결과적으로 프로그래머가 작성하는 코드를 최소화 시키기 위해 나온 개념이라고 볼 수 있다.</p>
<p>IoC란 간단히 말하자면 어떤 일을 하도록 만들어진 프레임워크에 제어의 권한을 넘김으로써 클라이언트 코드가 신경 써야 할 것을 줄이는 전략이다. 따라서 <u>제어가 역전</u>되었다고 표현한다.</p>
<p>가장 간단한 방법은 delegate 혹은 event에 나의 메서드를 등록시키는 것이다.</p>
<p>이때 마틴파울러는 IoC라는 용어가 일반적이여서 의미가 모호하게되자 <strong>Dependency Injection</strong>이라는 구체적인 용어를 사용한다고 언급하면서 의존성 주입이라는 개념이 등장하게된다.</p>
<blockquote>
<p>참조 : <a href="https://martinfowler.com/articles/injection.html" target="_blank" rel="noopener">https://martinfowler.com/articles/injection.html</a></p>
</blockquote>
<br>
<h2><span id="1-saengseongjaeseo-gibongabs-sayong">1. 생성자에서 기본값 사용</span></h2>
<p>Swift 에서는 생성자의 인자를 사용하여 의존성을 주입할 수 있다.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CoffeMachine</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> coffeBean: <span class="type">CofeeBean</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(bean: <span class="type">CofeeBean</span> = <span class="type">CofeeBean</span>() ) &#123;</span><br><span class="line">        <span class="keyword">self</span>.coffeBean = bean</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> DI </tag>
            
            <tag> pattern </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[제네릭과 익스텐션]]></title>
      <url>/2018/08/01/chap22-Generic/</url>
      <content type="html"><![CDATA[<h1><span id="extension">Extension</span></h1>
<p>스위프트의 강력한 기능 중 하나로 구조체, 클래스, 열거형, 프로토콜 타입에 새로운 기능을 추가할 수 있다.<em>(단, 기존 기능 재정의 불가</em>). 또한 프로토콜과 함께 사용하면 강력한 기능을 쓸 수 있다.</p>
<p>추가할 수 있는 기능은 아래와 같다.</p>
<ul>
<li>연산 타입 프로퍼티 / 연산 인스턴스 프로퍼티</li>
<li>타입 메서드 / 인스턴스 메서드</li>
<li>이니셜라이저</li>
<li>서브스크립트</li>
<li>중첩 타입</li>
<li><strong>특정 프로토콜을 준수할 수 있도록 기능 추가</strong></li>
</ul>
<br>
<h1><span id="generic">Generic</span></h1>
<p>스위프트의 강력한 기능 중 하나로 어떤 타입으로도 유연하게 대응할 수 있다.</p>
<p>재사용성 및 코드 중복을 줄일 수 있어서 깔끔하고 추상적인 표현을 가능하게 해준다.</p>
<p>표준 라이브러리는 많은 제네릭 코드로 구성되어 있다.</p>
<ul>
<li>Array</li>
<li>Dictionary</li>
<li>Set</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 타입 매개변수 - Element</span></span><br><span class="line"><span class="comment">// Array는 Generic type</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">Array</span>&lt;<span class="title">Element</span>&gt; : <span class="title">RandomAccessCollection</span> </span>&#123;</span><br><span class="line">    ... <span class="comment">//생략</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//generic function</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">map</span>&lt;T&gt; <span class="params">(<span class="number">_</span> transform: <span class="params">(Element)</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">T</span>) <span class="keyword">rethrows</span> [<span class="type">T</span>] &#123;</span><br><span class="line">    <span class="comment">//생략</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 익스텐션에서는 제네릭 타입이지만 타입 매개 변수를 따로 명시해주지 않는다.</span></span><br><span class="line"><span class="comment">// 대신 기존에 정의되어 있는 Element라는 타입은 사용가능하다</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> property: <span class="type">Element</span>? &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.last</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>
<h2><span id="taib-jeyag">타입 제약</span></h2>
<p>종종 제네릭 함수가 처리해야 할 기능이 특정 타입에 한정되어야 처리할 수 있는 등 특정 프로토콜을 따르는 타입만 사용할 수 있도록 제약을 두어야 하는 상황이 발생할 수 있다.</p>
<p>그때 <strong>클래스 타입 혹은 프로토콜</strong>로 제약을 줄 수 있다.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">Dictionary</span>&lt;<span class="title">Key</span>: <span class="title">Hashable</span>, <span class="title">Value</span>&gt; : <span class="title">Collection</span>, <span class="title">ExpressibleByDictionaryLiteral</span> </span>&#123; <span class="comment">/*생략 ... */</span>&#125;</span><br></pre></td></tr></table></figure>
<br>
<h2><span id="peurotokolyi-yeongwantaib-associated-type">프로토콜의 연관타입(Associated Type)</span></h2>
<p>프로토콜에서 사용할 수 있는 플레이스홀더 이름이다. 즉, 제네릭에서는 어떤 타입이 들어올지 모를때, 타입 매개변수를 통해 ‘종류는 모르지만 <u>어떤 타입이 여기에 쓰일 것</u>이다.’ 라고 표현해주었다면, 연관 타입은 <strong>타입 매개변수의 그 역활을 프로토콜에서 실행할 수 있도록 만들어진 기능</strong>이다.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Container</span> </span>&#123;</span><br><span class="line">    associatedtype <span class="type">ItemType</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">append</span><span class="params">(<span class="number">_</span> item: ItemType)</span></span></span><br><span class="line">    <span class="keyword">subscript</span>(i: <span class="type">Int</span>) -&gt; <span class="type">ItemType</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>
]]></content>
      
        <categories>
            
            <category> SWIFT </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 제네릭 </tag>
            
            <tag> extension </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[TDD (Test Driven Development)]]></title>
      <url>/2018/07/28/TDD/</url>
      <content type="html"><![CDATA[<h1><span id="tdd-test-driven-development">TDD (Test Driven Development)</span></h1>
<p>Kent Beck은 Extreme Programming 라는 소프트웨어 개발론을 도입했다. 그 개념에서 쓰인 규칙중 하나는 개발자는 unit test를 작성해야 하며, 소프트웨어의 모든 부분이 테스트되어져야 한다는 것이다. 소프트웨어가 배포되어 커스터머에게 가기전에 모든 테스트는 통과되어야 한다. 그리고 개발코드가 작성되기 전에 테스트가 작성되어야 한다. 이것을 <strong>테스트 주도 개발</strong>이라고 한다.</p>
<blockquote>
<p>Test the program before you WRITE IT</p>
</blockquote>
<br>
<ul>
<li>
<p>실패하기에 충분하지 않은 유닛 테스트는 더이상 쓸 수 없다.</p>
</li>
<li>
<p>실패한 유닛 테스트를 통과하지 않는 한 프로덕션 코드를 작성할 수 없다.</p>
</li>
<li>
<p>실패한 유닛 테스트를 통과하기에 충분한 프로덕션 코드는 더이상 작성하지 않는다.</p>
</li>
</ul>
<br>
<p>위와 같은 규칙이 이상해 보일 지 모르지만, 이러한 규칙을 따르면 실제로 기능을 구현하는 데 필요한 코드만 작성하게 된다. 그리고 그것에 필요한 테스트코드만 작성하게 된다.</p>
<br>
<h2><span id="tdd-workflow-red-green-refactor">TDD Workflow - red, green, refactor</span></h2>
<h3><span id="red-ask">Red : Ask</span></h3>
<p>작성하고자 하는 메서드나 기능이 무엇인지 선별하고 작성 완료 조건을 정해서 실패하는 테스트 케이시를 작성한다.</p>
<p>실패하는 테스트를 작성해서 시작해라. 이미 구현되지 않은 기능 혹은 확실하게 구현하려는 엣지 케이스를 테스트해야 한다. <code>red</code> 라는 이름은 대부분 실패한 테스트코드를 표현하는 것에서 유래되었다. Xcode에서도 실패하게 되면 빨간 체크표시가 있는 아이콘이 생긴다.</p>
<p>이 단계에서 작성하는 테스트가 처음에는 실패하는 것이 매우 중요하다. 그렇지 않으면 이 테스트가 제대로 작동하는지 확인하고 구현할 기능을 실제로 테스트 할 수가없다. 항상 통과하는 쓸모없는 테스트를 작성한 것일 수 있기 때문이다.</p>
<br>
<ul>
<li>테스트 케이스를 하나씩 추가해나가면서 구현 클래스를 점진적으로 만드는 방식 추천<br>
(모든 테스트케이스가 all green 상태에 이르기까지 긴 시간이 걸릴 수 있다.)</li>
<li>하나의 테스트 케이스가 하나의 기능을 테스트하도록 만드는 것이 기본 원칙이다.</li>
<li></li>
</ul>
<br>
<h3><span id="green-respond">Green : Respond</span></h3>
<p>Green 단계에서 <strong>테스트를 통과시키는 가장 간단한 코드</strong>를 작성한다. 작성한 코드가 깨끗하고 훌륭한지는 중요하지 않다. 모든 테스트가 통과되기만 하면 충분하다.<br>
Xcode에서 통과한 테스트에서는  초록색 체크표시 아이콘이 생긴다.</p>
<p>이 단계에서는 테스트를 통과시키는 가장 <em>simple</em>한 코드를 작성하는 것이 매우 중요하다. 즉, 읽기 쉽고 이해하기 쉬우며 쉽게 변할 수 있는 코드를 말한다.</p>
<ul>
<li>테스트 케이스를 통한 제품 코드 구현을 하드코딩으로 시작하는 것도 괜찮은 출발점이다. 최대한 간단한 로직이나 하드코딩 값을 이용해서 테스트를 최대한 빨리 통과시킨다.</li>
</ul>
<br>
<h3><span id="refactor-refine">Refactor : Refine</span></h3>
<p>리팩터 단계에서는 코드를 개선한다. 중복을 제거하고 공통 값을 추출하는 등의 작업을 한다. 코드를 가능한 한 좋게 만든다.</p>
<ul>
<li>소스의 가독성</li>
<li>중복코드</li>
<li>메서드 및 변수의 네이밍의 적절성</li>
<li>구조 개선</li>
</ul>
<h3><span id="repeat">Repeat</span></h3>
<br>
<h2><span id="gijon-gaebal-mic-teseuteuyi-munjejeom">기존 개발 및 테스트의 문제점</span></h2>
<ol>
<li>
<p>특정 모듈의 개발 기간이 길어질수록 개발자의 목표의식이 흐려진다.</p>
</li>
<li>
<p><strong>작업 분량이 늘어날수록 확인이 어려워진다</strong>.</p>
</li>
<li>
<p>개발자의 집중력이 피료해진다.</p>
</li>
<li>
<p>논리적인 오류를 찾기가 어렵다.</p>
</li>
<li>
<p><strong>코드의 사용 방법과 변경 이력을 개발자의 기억력에 의존하게 되는 경우가 많다</strong>.</p>
</li>
<li>
<p>테스트 케이스가 적혀 있는 엑셀 파일을 보며 매번 테스트를 실행하는 게 점점 귀찮아져서는 점차 간소화하는 항목들이 늘어난다.</p>
</li>
<li>
<p><strong>코드 수정 시에 기존 코드의 정상 동작에 대한 보장이 어렵다</strong>.</p>
</li>
<li>
<p>테스트를 해보려면 소스코드에 변경을 가하는 등, 번거로운 선행 작업이 필요할 수 있다.</p>
</li>
<li>
<p>그래서 소스 변경 시 해야 하는 <u>회기 테스트</u>는 곧잘 희귀 테스트가 되기 쉽다.</p>
<p><strong>회기 테스트</strong> : 이미 개발과 테스트가 완료된 모듈에 수정을 가하게 될 경우, 기존에 동작하던 다른 부분도 정상적으로 동작하는지 확인하기 위해 수행하는 테스트. 해당 모듈 뿐 아니라 그 모듈과 연관되어 있는 다른 모든 모듈도 변함없이 목표대로 작동하는지를 매번 테스트해야 한다.</p>
</li>
<li>
<p>개발자의 귀중한 노동력을 적지 않게 소모한다.</p>
</li>
</ol>
<br>
<h2><span id="tddyi-mogpyo">TDD의 목표</span></h2>
<blockquote>
<p>Clean code that works (잘 동작하는 깔끔한 코드)</p>
</blockquote>
<br>
<h2><span id="tddyi-rule">TDD의 Rule</span></h2>
<p><em>Given - When - Then</em></p>
<ul>
<li>Give: 테스트를 시작하기 위해 주어지는 선조건</li>
<li>When: 테스트하는 코드의 수행</li>
<li>Then: assertion (예상결과)</li>
</ul>
<br>
<h2><span id="tddsi-yuyisahang">TDD시 유의사항</span></h2>
<ul>
<li>TDD에서는 개발이 시작된 시점부터 <strong>가능한 빠른 시점 내에 그리고 자주 실패</strong>를 경험하도록 유도한다.</li>
<li>클래스 설계시 클래스를 정의할 때 가장 중요한 건  '속성’이 아닌 ‘<strong>동작</strong>’ 이다. 동작을 먼저 정하고 필요한 속성을 정하는 것이 순차적으로 맞다. 따라서 처음부터 필요한 모든 속성을 생각할 필요가 없다. 추후에 필요하면 추가하면 된다.</li>
<li>테스트 케이스를 엉성하게 만들면 테스트 자체를 신뢰할 수 없게 된다.</li>
<li>TDD에서는 실패하는 테스트를 여러 개 만들어놓고 진행하는 걸 권장하지 않는다.</li>
<li>무엇을 테스트 할 것인가를 체크한다
<ul>
<li>결과가 옳은가?</li>
<li>모든 경계조건이 옳은가?</li>
<li>역(inverse)관계를 확인할 수 있는가?</li>
<li>다른 수단을 사용해서 결과를 교차확인할 수 있는가?</li>
<li>에러 조건을 강제로 만들어낼 수 있는가?</li>
<li>성능이 한도 내에 있는가?</li>
</ul>
</li>
</ul>
<br>
<h2><span id="robeoteu-matinyi-tdd-weoncig">로버트 마틴의 TDD 원칙</span></h2>
<ul>
<li>실패하는 테스트를 작서하기 전에는 절대로 제품 코드를 작성하지 않는다.</li>
<li>실패하는 테스트 코드를 한 번에 하나 이상 작성하지 않는다.</li>
<li>현재 실패하고 있는 테스트를 통과하기에 충분한 정도를 넘어서는 제품 코드를 작성하지 않는다.</li>
</ul>
<br>
<h2><span id="tddyi-jangjeom">TDD의 장점</span></h2>
<ul>
<li>
<p>개발의 방향을 잃지 않게 유지해준다.<br>
테스트 케이스들은 자신이 어디까지 왔고 앞으로 나아가야 하는 곳이 어디인지를 알려주는 나침반 같은 역활을 한다.</p>
</li>
<li>
<p>품질 높은 소프트웨어 모듈 보유<br>
TDD를 통해 만들어진 애플리케이션은 필요한 만큼 테스트를 거친 ’ 품질이 검증된 부품 '을 갖게되는 것이다. 단위 모듈의 품질이 향상되면서 완성된 어플리케이션의 품질도 향상시킨다.<br>
TDD를 사용하지 않은 개발팀에 비해 TDD를 적용한 팀의  결함률이 최대 1/10 정도까지 감소했다.</p>
</li>
<li>
<p>자동화된 단위 테스트 케이스를 갖게 된다.</p>
</li>
<li>
<p>사용 설명서 &amp; 의사소통의 수단<br>
TDD로 개발 시 테스트 코드가 개발 종료와 함께 남게 된다. 그리고 미래 개발자에게 제공되는 상세화된 모듈 사용 설명서라는 부분도 포함되어 있다. 기존 코드(legacy code)의 난해함과 문서화 부재가 주는 상실감이 IT 프로젝트에서 많은 악영향을 끼친다.</p>
</li>
<li>
<p>설계 개선<br>
객체 개설 원리 중 기본에 해당하는 원칙들이 잘못 적용됐거나 충분히 고려되지 않았을 가능성이 높다. 테스트가 가능하도록 설계 구조를 고민하다 보면 자연스럽게 디자인을 개선하게 된다. 미리 고민해보고 작성하는 것과 작성하면서 그때그때 추가하는 것은 모듈의 응집도와 의존성 정도에 큰 차이를 만들어낸다.</p>
</li>
<li>
<p>보다 자주 성공한다<br>
TDD는 매 주기를 짧게 설정하도록 권장한다. 그때마다 목표를 이뤘다는 성취감을 느낄 수 있다.</p>
<blockquote>
<p>Divide and Test, then Conquer</p>
</blockquote>
</li>
</ul>
<br>
<h2><span id="teseuteu-keiseu-jagseongbangsig">테스트 케이스 작성방식</span></h2>
<ol>
<li>테스트 대상 메소드와 이름을 1:1로 일치</li>
<li>테스트 대상 메소드의 이름 뒤에 추가적인 정보를 기재<br>
보통 상세 케이스들은 메소드 이름 뒤에 _을 붙여 구별하는데 이때 주로 한글을 사용한다.<br>
한글 사용을 적극 권장하는 이유는 메서드 목록을 뽑은 뒤 엑셀에서 _로 구분해넣으면 자연스럽게 테스트케이스 항목이 표로 만들어 지기 때문이다.</li>
<li>테스트 시나리오에 집중</li>
</ol>
<br>
<h2><span id="tddyi-hangye">TDD의 한계</span></h2>
<ul>
<li>동시성 문제</li>
<li>접근제한자 메서드<br>
public으로 되어 있는 메서드만 테스트해도 무방하다. Public 메서드가 테스트될 때, 포함된 private 메서드들도 함께 테스트가 이뤄진다고 볼 수 있기 때문이다.</li>
<li>의존성 모듈 테스트</li>
</ul>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> UnitTest </tag>
            
            <tag> TDD </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[DBMS 란?]]></title>
      <url>/2018/06/26/CS-DBMS/</url>
      <content type="html"><![CDATA[<h1><span id="database">Database</span></h1>
<p>줄여서 DB라고 부르며 여러 사람이 공유하고 사용할 목적으로 통합하여 관리되는 데이터의 집합이다.</p>
<ul>
<li>똑같은 자료를 중복 없이 통합적으로 저장한다</li>
<li>컴퓨터가 접근하여 처리할 수 있는 저장장치에 기록된다.</li>
<li>어떤 조직의 기능을 수행하는 데 없어서는 안 되는 기술로 존재 목적이 뚜렷하다.</li>
<li>실시간으로 접근하여 데이터를 읽거나 쓸 수있다.</li>
<li>데이터베이스에 저장된 데이터는 추가,수정,삭제 등 지속적으로 변한다.</li>
</ul>
<br>
<h2><span id="dbms-database-management-system-deiteobeiseu-gwanrisiseutem">DBMS (Database Management System, 데이터베이스 관리시스템)</span></h2>
<p>데이터베이스 내에 저장된 데이터에 손쉽게 접근할 수 있도록 해주는 소프트웨어 도구의 모음이다. (Ex, MariaDB, MySQL )</p>
<h3><span id="oracle">Oracle</span></h3>
<p>데이터베이스 시장의 절반을 차지하는 큰 규모의 상용 DBMS. 단, 제품 가격이 상당히 비싼 것으로도 유명하다.</p>
<br>
<h3><span id="sqlserver">SQLServer</span></h3>
<p>마이크로소프트가 사이베이스라는 데이터베이스를 기반으로 개발한 관계형 DBMS.  <strong>MS-SQL</strong>이라고도 불린다. 데이터베이스 관리 및 데이터 조작을 위한 전용 GUI 툴을 함께 제공하는 것이 특징이다.</p>
<br>
<h3><span id="mysql">mySQL</span></h3>
<p>세계에서 가장 많이 사용되는 오픈소스 기반 관계형 DBMS로 멀티 스레드 및 멀티 유저 기반으로 운영된다. 특히 웹어플리케이션을 구축할 때 많이 사용되며, APM(PHP + Apache + MySQL) 조합이 가장 많이 쓰인다.<br>
본래는 오픈소스로 성장 후 썬 마이크로시스템즈에 인수 되었다가 썬이 현재는 오라클에 인수되었다. 오라클은 오픈소스 프로젝트를 엉망으로 만드는 능력이 대단하다. 핵심 개발자들이 오라클의 불확실한 라이선스와 충돌하고, 이를 견디지 못해 새로운 오픈소스 기반 DBMS인 mariaDB를 만들게 되었다.</p>
<br>
<h3><span id="sqlite">SQLite</span></h3>
<p>위 DBMS는 동시에 서버로 분류가 된다. 하지만 SQLite는 응용 프로그램의 부분적인 모듈로 동작한다. 독립적인 서버로 설치해서 사용할 수 없다.<br>
다른 DBMS처럼 네트워크를 통해 서비스를 제공하지 않고 , 항상 로컬에서 라이브러리에 포함해서만 사용할 수 있다. 시스템에 간편하게 탑재할 수 있어서 애플리케이션의 내장용 데이터베이스로 사용되는 경우가 많다.</p>
<br>
<h3><span id="mongodb">MongoDB</span></h3>
<p>SQL구문을 사용하지 않고 데이터들 사이의 결합 관계를 충분히 지원하지 않는 데이터베이스인 <strong>NoSQL</strong> 타입이 있다. 대표적으로 하둡(Hadoop)과 몽고DB이다.</p>
<p>몽고DB는 _오픈소스 기반의 크로스 플랫폼 도큐먼트 지향 데이터베이스 관리 시스템_이다. 플랫폼에 상관없이 사용할 수 있도록 문서 기반으로 데이터를 저장하는 DBMS라는 뜻이다. 대부분 관계형 DBMS들이 자신만의 바이너리 코드를 이용하여 데이터 구조를 다루는데 반해 몽고DB는 앞에서 JSON 형태로 데이터를 저장한다. 형식과 구조의 제약으로부터 조금 더 자유롭다는 장점이 있다.</p>
<p>공통적으로 NoSQL은 단순하면서 병렬적 확장이 용이한 구조이기 때문에  분산 처리에 적합하다. 따라서 빅데이터를 다루는 아키텍쳐에서 NoSQL이 빠지지 않고 포함되는 것은 이 같은 확장성 때문이다.</p>
<br>
<h2><span id="transaction">Transaction</span></h2>
<p>CRUD(Create, Read, Update, Delete)는 DBMS가 제공하는 가장 기본적이면서 핵심적인 기능으로 데이터베이스에서 최소의 작업 단위라고 할 수 있다. 트랜젝션은 하나 이상의 CRUD 작업들을 마치 하나의 실행 단위인 것처럼 묶어주는 기능으로, ATM 기기나 데이터베이스 등의 시스템에서 강조되는 개념이다.</p>
<ul>
<li>DBMS가 제공하는 트랙젝션은 연관된 여러 개의 CRUD 작업을 묶어 단일 작업처럼 수행할 수 있도록 해 주는 기능이다.</li>
<li>논리적 작업단위</li>
<li>commit : 트렌젝션의 최종 결과가 성공이면 그 결과를 데이터베이스에 반영</li>
<li>rollback : 일부 작업이 수행되지 않아 트렌젝션 최종 결과가 실패인 경우 아무것도 실행되지 않았던 처음 상태로 되돌린다.</li>
</ul>
<br>
<h5><span id="teurenjegsyeon-4daeweoncig">트렌젝션 4대원칙</span></h5>
<ol>
<li>원자성  : 하나의 트렌젝션 내에 정의된 작업들은 모두 수행되든지, 아니면 아무것도 수행되지 않아야 한다.</li>
<li>일관성 : 정당한 데이터만을 데이터베이스에 반영해서 무결성을 유지해야한다.</li>
<li>격리성 : 하나의 트렌젝션이 실행되는 동안 트렌젝션 내부에 다른 트렌젝션이 접근할 수 없어야 한다.</li>
<li>지속성 : 하드웨어나 소프트웨어에 오류가 발생했더라도 트렌젝션의 결과가 데이터베이스에 계속 보존되어야 한다.</li>
</ol>
]]></content>
      
        <categories>
            
            <category> CS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> DB </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ReactiveX]]></title>
      <url>/2018/05/31/RXSwift-FRP/</url>
      <content type="html"><![CDATA[<h1><span id="reactivex">ReactiveX</span></h1>
<hr>
<p>Reactive programming은 데이터 스트림과 변화의 증식에 기반한 비동기 프로그래밍 패러다임이다<br>
그런 Reactive programming 을 기반으로 설계된 비동기 데이터 스트림을 처리하는 API를 제공하는 라이브러리이다.<br>
<code>RXSwift</code> 는 Swift 로 Reactive 프로그래밍을 하기 위한 라이브러리이다.</p>
<br>
<h2><span id="observable">Observable</span></h2>
<hr>
<p>Arrays, Strings 와 같은 Sequences는 RxSwift에서 Observables가 된다. Swift Sequence Protocol을 따르는 모든 Object들의 Observable을 만들 수 있다. 이런 Observable은 구독가능하다.</p>
<p>옵저버(observer)는 <strong>Observable</strong> 을 구독한다. observable이 배출하는 항목들에 옵저버는 반응한다. 이러한 패턴은 동시성 연산을 가능하게 한다. observable이 객체를 배출할 때까지 기다릴 필요 없이 어떤 객체가 배출되면 그 시점을 감시하는 구독자(subscriber)를 옵저버 안에 두고 그 관찰자를 통해 배출 알림을 받으면 되기 때문이다.</p>
<p>아래는 <em>마블다이어그램</em> 을 통해 설명한 것이다.</p>
<p><img src="http://reactivex.io/assets/operators/legend.png" alt="마블다이어그램"></p>
<br>
<p>“Observable” 안에 데이터를 조회하고 변환하는 메커니즘을 정의한 후, Observable이 이벤트를 발생시키면 옵저버의 관찰자가 그 순간을 감지하고 준비된 연산을 실행시켜 결과를 리턴하는 메커니즘 때문에, observable을 구독한다고 표현한다.</p>
<p>이 접근 방법은 의존관계가 없는 많은 코드들을 실행할 때, 하나의 코드 블럭이 실행 결과를 리턴할 때까지 기다릴 필요 없이 계속해서 다음 코드 블럭을 실행할 수 있기 때문에 한번에 여러개의 코드를 실행 시킬 수 있어서 실행시간이 단축된다는 장점이 있다</p>
<h4><span id="hot-vs-cold">Hot VS Cold</span></h4>
<hr>
<p>observable은 연속된 항목을 배출할 때 observable에 따라 다르게 전달한다.</p>
<ul>
<li>Hot observable : item이 생성되자 마자 항목을 배출한다. 따라서 어떤 옵저버들은 항목들이 배출되는 중간부터 구독할 수 있다.</li>
<li>Cold observable : 옵저버의 구독이 있기 전까지는 항목을 배출하지 않는다. 이때는 옵저버들이 모든 항목을 구독할 수 있도록 보장받는다.</li>
</ul>
<br>
<h4><span id="single">Single</span></h4>
<hr>
<p><a href="http://reactivex.io/documentation/ko/observable.html" target="_blank" rel="noopener">Observable</a>과 유사한 “Single”을 제공한다.</p>
<p>Single은 Obvservable의 한 형태이지만, Observable처럼 존재하지 않는 곳에서부터 무한대까지의 임이의 연속된 값들을 배출하는 것과는 달리, 항상 한 가지 값 또는 오류 알림 둘 중 하나만 배출한다.</p>
<p>이런 이유 때문에, Single을 구독할 때는 Observable을 구독할 때 사용하는 세 개의 메서드(<code>onNext</code>, <code>onError</code>, 그리고 <code>onCompleted</code>) 대신 다음의 두 메서드만 사용할 수 있다:</p>
<ul>
<li>
<p>onSuccess</p>
<p>Single은 자신이 배출하는 하나의 값을 이 메서드를 통해 전달한다</p>
</li>
<li>
<p>onError</p>
<p>Single은 항목을 배출할 수 없을 때 이 메서드를 통해 Throwable 객체를 전달한다</p>
</li>
</ul>
<p>Single은 이 메서드 중 하나만 그리고, 한 번만 호출한다. 메서드가 호출되면 Single의 생명주기는 끝나고 구독도 종료된다.</p>
<br>
<h3><span id="observer">observer</span></h3>
<hr>
<p>구독자, 관찰자, 리액터라고 불리며 observable을 구독한다. observable은 항목을 배출하거나 observable의 메서드 호출을 통해 옵저버에게 알림을 보낸다.</p>
<br>
<h4><span id="ilban-meseodeuhocul-vs-rx-meseodeu-hocul">일반 메서드호출 VS RX 메서드 호출</span></h4>
<hr>
<p>일반 메서드 호출은 다음과 같이 처리된다.</p>
<ol>
<li>메서드를 호출한다</li>
<li>메서드가 리턴한 값을 변수에 저장한다</li>
<li>결과 값을 가진 변수를 통해 필요한 연산을 처리한다</li>
</ol>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> returnValue = someMethod(parameters)</span><br><span class="line"><span class="keyword">self</span>.view.data = returnValue</span><br></pre></td></tr></table></figure>
<br>
<p>RX(비동기 모델)에서는 다음과 같이 처리된다.</p>
<ol>
<li>비동기 메서드 호출로 결과를 리턴받고 필요한 동작을 처리하는 메서드를 정의한다. 이 메서드는 <strong>옵저버</strong>의 일부에 포함된다.</li>
<li><em>observable</em>로 비동기 호출을 정의한다.</li>
<li>구독을 통해 옵저버를 observable 객체에 연결시킨다. (+ observable의 동작 초기화)</li>
<li>필요한 코드를 연달아 구현한다. 메서드 호출로 결과가 리턴될 때마다, 옵저버의 메서드는 리턴값 (observable이 배출하는 item) 또는 항목들을 사용해서 연산을 시작한다.</li>
</ol>
<br>
<h3><span id="observable-contract">observable contract</span></h3>
<hr>
<p>Observable은 0개 이상의 OnNext 알림을 만들고 각각의 알림은 배출된 하나의 항목을 나타내며 OnCompleted나 OnError 알림 중 하나를 배출한다. 단, OnCompleted와 OnError 알림 둘 다 만들지는 않는다. OnCompleted나 OnError 알림을 배출한 후에는 다른 알림을 배출하지 않는다.</p>
<p>Observable은 항목을 배출하지 않을 수 있고, OnCompleted나 OnError 알림을 전달했다 해도 종료되지 않을 수 있다. 이 말은 즉, Observable은 아무 알림도 배출하지 않거나, OnCompleted 또는 OnError 알림만 배출할 수 있으며, 또는 OnNext 알리만 배출할 수도 있다는 것을 말한다.</p>
<p>Observable은 반드시 (병렬이 아닌)순차적으로 옵저버에게 알림을 보낸다. 그리고 이 알림은 다른 스레드를 통해 전달 되기도 한다. 하지만, 공식적으로 알림 간에는 <em>전후</em> 관계가 존재한다.</p>
<ul>
<li><code>Subscribe</code> : 옵저버가 observable로 부터 알림을 받을 준비가 됬음을 알린다.</li>
<li><code>unsubscribe</code> : 옵저버가 더이상 observable로 부터 알림을 받고 싶지 않다는 것을 말한다.  (disconnect)</li>
<li><code>Request</code> (optional) : 옵저버가 특정 수 만큼의 추가적 onNext 알림만 받고 싶다는 것을 말한다.</li>
</ul>
<br>
<h3><span id="ibenteu-meseodeu">이벤트 메서드</span></h3>
<hr>
<p><code>Subscribe</code> : 메서드를 통해 옵저버와 observable을 연결한다. 그러면 옵저버는 아래의 메서드들을 구현하게 된다.</p>
<ul>
<li>
<p><code>onNext</code>(배출) : observable은 새로운 항목을 배출할 때마다 이 메서드를 호출한다. 이 메서드는 observable이 <strong>배출하는 항목을 파라미터</strong>로 전달받는다.</p>
</li>
<li>
<p><code>onError</code>(알림) : observable은 기대하는 데이터가 생성되지 않았거나, 다른 이유로 오류가 발생할 경우 오류를 알리기 위해 이 메서드를 호출한다. 이 메서드가 호출되면 스트림은 종료된다. 오류정보를 저장하고 있는 객체를 파라미터로 전달받는다.</p>
</li>
<li>
<p><code>onCompleted</code>(알림) : 오류가 발생하지 않았다면 observable은 마지막 메서드를 호출 후 끝으로 이 메서드를 호출한다.</p>
</li>
</ul>
<br>
<h2><span id="disposing">Disposing</span></h2>
<hr>
<p>Observables의 사용이 끝나면 메모리에서 해제가 되어야 한다. 그 때 사용할 수 있는것이 Dispose이다. RxSwift에서는 <code>DisposeBag</code>을 사용하는데 DisposeBag instance가 deinit() 될 때 모든 메모리를 해제한다.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line"><span class="keyword">let</span> stringSequence = <span class="type">Observable</span>.just(<span class="string">"RxSwift Observable"</span>)</span><br><span class="line"><span class="keyword">let</span> subscription = stringSequence.subscribe &#123; (event) <span class="keyword">in</span></span><br><span class="line"><span class="built_in">print</span>(event)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// subscription 을 disposeBag에 넣어 메모리를 해제</span></span><br><span class="line">subscription.addDisposableTo(disposeBag)</span><br></pre></td></tr></table></figure>
<br>
<h2><span id="operator">Operator</span></h2>
<hr>
<p>observable을 받아 연산하고 처리해준다. 주로 체이닝을 통해 처리되며, 이때 처리는 순차적으로 진행된다.</p>
<h3><span id="operator-chainning">operator Chainning</span></h3>
<hr>
<p>대부분의 연산자들은 Observable 상에서 동작하고 Observable을 리턴한다. 이런 접근 방법은 연산자들을 하나의 Observable에 적용하고 또 다음 연산자에 다시 적용할 수 있는 연산자 체인을 제공한다. 연산자 체인에 걸려있는 각각의 연산자들은 이전 연산자가 리턴한 Observable을 변경한다.</p>
<p>특정 클래스의 다양한 메서드 연산을 통해서 같은 클래스에 있는 항목들을 변경하는 빌더 패턴 같은 것도 존재한다. 이 패턴 역시 비슷한 방법으로 메서드 체인을 제공한다. 하지만, 연산자의 호출 순서가 문제가 되지 않는 빌더 패턴과는 달리, Obervable 연산자들은 <em>호출 순서</em>에 영향을 받는다.</p>
<p>Observable 연산자 체인은 원본 Observable과는 떨어져서 동작할 수 없고 <em>순서대로</em> 동작하기 때문에, 호출 체인 중 바로 이전에 호출된 연산자가 리턴한 Observable을 기반으로 실행된다.</p>
<br>
<h2><span id="subject-publishsubject">Subject (PublishSubject)</span></h2>
<hr>
<p>subject는 옵저버나 Observable처럼 행동하는 ReactiveX의 일부 구현체에서 사용 가능한 일종의 교각 혹은 프록시라고 볼 수 있는데, 그 이유는 subject는 <strong>옵저버</strong>이기 때문에 하나 이상의 Observable을 구독할 수 있으며 동시에 Observable이기도 하기 때문에 항목들을 하나 하나 거치면서 재배출하고 관찰하며 새로운 항목들을 배출할 수도 있다.</p>
<p>Rx 에서 Subject는 Observable 과 Observer 둘 다 될 수 있는 특별한 형태이다. Subject는 Observables을 subscribe(구독) 할 수 있고 다시 emit(방출)할 수 도 있다. 혹은 새로운 Observable을 emit 할 수 있다</p>
<p>하나의 subject는 하나의 Observable을 구독하면서, ( “Cold” Observable인 경우)Observable이 항목들을 배출시키도록 동작시킨다. 그 결과로 인해 원래는 “Cold” Observable이었던 주제를 “Hod” Observable로 만들기도 한다</p>
<br>
<h4><span id="aysncsubject">AysncSubject</span></h4>
<hr>
<p>observable로 부터 배출된 마지막 값만을 배출하고 observable의 동작이 완료된 후에야 동작한다. 즉, observable의 <strong>가장 마지막 값을 옵저버에 전달</strong>하는데, observable이 오류로 인해 종료될 경우 아무 항목도 배출하지 않고 발생한 오류를 그대로 전달한다.</p>
<p><img src="http://reactivex.io/documentation/operators/images/S.AsyncSubject.png" alt="AysncSubject"></p>
<br>
<h4><span id="behaviorsubject">BehaviorSubject</span></h4>
<hr>
<p>옵저버가 BehaviorSubject를 구독하기 시작하면, 옵저버는 구독 전 소스 observable이 가장 최근에 발행한 항목의 발행으로 시작하며, 구독 이후에 발행된 항목들은 계속 발행한다.</p>
<p>만약 observable이 오류 때문에 종료되면, 아무런 항목도 배출하지 않고 observable에서 발생한 오류를 그대로 전달한다.</p>
<p><img src="http://reactivex.io/documentation/operators/images/S.BehaviorSubject.png" alt="BehaviorSubject"></p>
<h4><span id="variable">Variable</span></h4>
<hr>
<p>Variable 은 BehaviorSubject의 Wrapper 함수이며 BehaviorSubject처럼 작동하며 더 익숙한 이름으로 사용하기 위해 만들어 졌다. Variable은 Error 이벤트를 Emit 하지 않는다. deinit에서 해제 되며 Completed이벤트를 Emit한다.</p>
<br>
<h4><span id="publishsubject">PublishSubject</span></h4>
<hr>
<p><u>구독 이후에 observable이 배출한 항목만</u> 옵저버에게 배출한다.</p>
<p>주의할 점은, <code>PublishSubject</code>는 (이를 막지 않는 이상) 생성 시점에서 즉시 항목들을 배출하기 시작할 것이고 이런 특성 때문에 주제가 생성되는 시점과 옵저버가 이 주제를 구독하기 시작하는 그 사이에 배출되는 항목들을 잃어 버릴 수 있다는 단점이 있다.</p>
<p>Observable이 배출하는 모든 항목들의 배출을 보장해야 한다면 <a href="http://reactivex.io/documentation/ko/operators/create.html" target="_blank" rel="noopener"><code>Create</code></a>을 사용해서 명시적으로 “차가운” Observable(항목들을 배출하기 전에 모든 옵저버가 구독을 시작했는지 체크한다)을 생성하거나, PublishSubject 대신 <code>ReplaySubject</code>를 사용해야 한다</p>
<p><img src="http://reactivex.io/documentation/operators/images/S.PublishSubject.e.png" alt="PublishSubject"></p>
<br>
<h4><span id="replaysubject">ReplaySubject</span></h4>
<hr>
<p>옵저버가 구독을 시작한 시점과 관계 없이 observable들이 배출한 모든 항목을 모든 옵저버에게 배출한다.</p>
<p><code>ReplaySubject</code>는 몇 개의 생성자 오버로드를 제공하는데 이를 통해, 재생 버퍼의 크기가 특정 이상으로 증가할 경우, 또는 처음 배출 이후 지정한 시간이 경과할 경우 오래된 항목들을 제거한다.</p>
<p>만약, <code>ReplaySubject</code>을 옵저버로 사용할 경우, 멀티 스레드 환경에서는 <a href="http://reactivex.io/documentation/contract.html" target="_blank" rel="noopener">Observable 계약</a> 위반과 subject에서 어느 항목 또는 알림을 먼저 재생해야 하는지 알 수 없는 모호함이 동시에 발생할 수 있기 때문에 (비순차적) 호출을 유발시키는 <code>onNext</code>(또는 그 외 <code>on</code>) 메서드를 사용하지 않도록 주의해야 한다.</p>
<p><img src="http://reactivex.io/documentation/operators/images/S.ReplaySubject.png" alt="ReplaySubject"></p>
<br>
<h2><span id="scheduler">Scheduler</span></h2>
<hr>
<p>Observable 연산자 체인에 멀티스레딩을 적용하고 싶다면, 특정 스케줄러를 사용해서 연산자(또는 특정 Observable)를 실행하면 된다.</p>
<p>ReactiveX의 일부 Observable 연산자는 사용할 스케줄러를 파라미터로 전달 받기도 하는데, 이 연산자들은 자신이 처리할 연산의 일부 또는 전체를 전달된 스케줄러 내에서 실행한다.</p>
<p>기본적으로, Observable과 연산자 체인은 이처럼 스케줄러를 통해 동작하고 <code>Subscribe</code> 메서드가 호출되는 스레드를 사용해서 옵저버에게 알림을 보낸다.</p>
<ul>
<li><code>SubscribeOn</code> 연산자 :  다른 스케줄러를 지정해서 Observable이 처리해야 할 연산자들을 실행 시킨다.</li>
<li><code>ObserveOn</code> 연산자 :  Observable이 옵저버에게 알림을 보낼때 사용 할 스케줄러를 명시한다.</li>
</ul>
<p>아래 그림이 보여주듯, SubscribeOn 연산자는 Observable이 연산을 위해 사용할 스레드를 지정하며, 연산자 체인 중 아무 곳에서 호출해도 문제되지 않는다. 하지만, ObserveOn 연산자는 연산자 체인 중 Observable이 사용할 스레드가 호출 체인 중 어느 시점에서 할당되는지에 따라 <em>그 후</em>에 호출되는 연산자는 영향을 받는다. 그렇기 때문에, 어쩌면 여러분은 특정 연산자를 별도의 스레드에서 실행 시키기 위해 연산자 체인 중 한 군데 이상에서ObserveOn을 호출하게 될 것이다.</p>
<p><img src="http://reactivex.io/documentation/operators/images/schedulers.png" alt="Scheduler"></p>
<br>
<h2><span id="bind">Bind</span></h2>
<hr>
<p>아래와 같이 바인딩을 해서 operated 된 값을 넘겨준다.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Observable</span>.combineLatest(firstName.rx.text, lastName.rx.text) &#123; $<span class="number">0</span> + <span class="string">" "</span> + $<span class="number">1</span> &#125;</span><br><span class="line">.<span class="built_in">map</span> &#123; <span class="string">"Greetings, <span class="subst">\($<span class="number">0</span>)</span>"</span> &#125;</span><br><span class="line">.bind(to: greetingLabel.rx.text)`</span><br></pre></td></tr></table></figure>
<p>UITableView 혹은 UICollectionView 와도 바인딩이 가능하다.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">viewModel</span><br><span class="line">.rows</span><br><span class="line">.bind(to: resultsTableView.rx.items(cellIdentifier: <span class="string">"WikipediaSearchCell"</span>, cellType: <span class="type">WikipediaSearchCell</span>.<span class="keyword">self</span>)) &#123; (<span class="number">_</span>, viewModel, cell) <span class="keyword">in</span></span><br><span class="line">cell.title = viewModel.title</span><br><span class="line">cell.url = viewModel.url</span><br><span class="line">&#125;</span><br><span class="line">.disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>
<h5><span id="reference">reference</span></h5>
<hr>
<p><a href="http://reactivex.io/documentation/ko/observable.html" target="_blank" rel="noopener">observable</a></p>
<p><a href="http://reactivex.io/documentation/ko/operators.html" target="_blank" rel="noopener">Operators</a></p>
]]></content>
      
        
        <tags>
            
            <tag> ReactiveX </tag>
            
            <tag> RXSwift </tag>
            
            <tag> FRP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ARKit Basic]]></title>
      <url>/2018/05/07/ARkit-basic/</url>
      <content type="html"><![CDATA[<h1><span id="arkit-basic">ARKit basic</span></h1>
<h2><span id="vector">Vector</span></h2>
<hr>
<p>Vector3은 x,y,z 로 이루어져 있는 위치값이다. 공간이 인식되면 방향성 및 포즈를 인식하여 해당 공간에  물체의 위치를 수치로 나타낼 수 있다.</p>
<p><img src="https://cdn-images-1.medium.com/max/1600/1*IRvOJvHSBOpLxbdGCzck-g.png" alt="vecter"></p>
<br>
<p>##Built-in Geometry Types</p>
<ul>
<li>SCNText</li>
<li>SCNShape</li>
<li>SCNText</li>
<li>SCNCone</li>
<li>SCNSphere</li>
<li>and so on… (<a href="https://developer.apple.com/documentation/scenekit/built_in_geometry_types" target="_blank" rel="noopener">Built-in Geometry Types</a>)</li>
</ul>
<br>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> node = <span class="type">SCNNode</span>()</span><br><span class="line">node.geometry = <span class="type">SCNCapsule</span>(capRadius:<span class="number">0.1</span> , height: <span class="number">0.3</span>)    <span class="comment">//캡슐형 노드 생성</span></span><br><span class="line">node.geometry?.firstMaterial?.specular.contents = <span class="type">UIColor</span>.orange <span class="comment">//빛에 의한 반사되는 것을 정의한다</span></span><br><span class="line">node.geometry?.firstMaterial?.diffuse.contents = <span class="type">UIColor</span>.blue    <span class="comment">//빛에 의한 확산을 정의한다</span></span><br><span class="line">node.position = <span class="type">SCNVector3</span>(<span class="number">0</span>,<span class="number">0</span>,-<span class="number">7</span>)    <span class="comment">//x,y,z</span></span><br><span class="line"><span class="keyword">self</span>.sceneView.scene.rootNode.addChildNode(node)    <span class="comment">//뷰에 노드 추가</span></span><br></pre></td></tr></table></figure>
<br>
<h2><span id="definition">Definition</span></h2>
<h3><span id="scnmaterial">SCNMaterial</span></h3>
<hr>
<p>랜더링될 때, 물체의 표면의 생김새를 정의하는 특성들의 모음이다.</p>
<p>내가 물체를 만들때, 물체의 생김새나 특성 등을 정의하고, 그것을 다수의 물체를 만들때 재사용이 가능하다.</p>
<br>
<h3><span id="arsession">ARSession</span></h3>
<hr>
<p>In ARKit the <strong>ARSession</strong> coordinates the logic and data necessary to create the augmented reality experience. This includes camera and motion data and calculations required to keep track of the world as it moves around.</p>
<br>
<h3><span id="arframe">ARFrame</span></h3>
<hr>
<p>An <strong>ARFrame</strong> contains a video frame data and position tracking data which gets passed along to the ARSession in the currentFrame property.ARKit marries that image data with the motion tracking data to calculate the iPhone’s position.</p>
<br>
<h3><span id="aranchor">ARAnchor</span></h3>
<hr>
<p>An <strong>ARAnchor</strong> is a position in the real world that maintained regardless of motion or position of the camera (theoretically). It’s anchored to a specific position, and for the most part will remain there.</p>
<br>
<h3><span id="matrix">Matrix</span></h3>
<hr>
<p>열과 행으로 이루어진 배열로 다음과 같은 값을 포함하고있다.</p>
<ul>
<li>Rotation (changing orientation)</li>
<li>Scaling (size changes)</li>
<li>Translation (moving position)</li>
</ul>
<h5><span id="byeonhwansig">변환식</span></h5>
<blockquote>
<p>Transformed Point = Transformation Matrix × Original Point</p>
</blockquote>
<br>
<h2><span id="relative-positioning">Relative Positioning</span></h2>
<hr>
<p>기준이 되는 노드에 <code>addChildNode</code>로 붙이려는 객체노드를 추가하고, position을 설정하면 기준이 되는 노드의 중점을 기준으로 배치가 된다.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> box = <span class="type">SCNNode</span>(geometry: <span class="type">SCNBox</span>(width:<span class="number">0.1</span>, height: <span class="number">0.1</span>,lengh: <span class="number">0.1</span>, chamferRadius:<span class="number">0</span>))</span><br><span class="line">box.position = <span class="type">SCNVector3</span>(<span class="number">0</span>,-<span class="number">0.05</span>,<span class="number">0</span>)    <span class="comment">//node의 중심좌료로 부터의 위치</span></span><br><span class="line">node.addChildNode(box)</span><br></pre></td></tr></table></figure>
<br>
<h2><span id="rotation">Rotation</span></h2>
<hr>
<p><code>eulerAngles</code> 메서드를 사용해서 세팅한다. 오일러 각은 객체가 놓인 방향을 3차원 공간에서 표시하기 위해 도입한 세 개의 각도이다.</p>
<ul>
<li>𝞪 (or 𝞧) : <strong>z-축</strong>을 회전축으로 하여 회전된 x-y 좌표축의 각도</li>
<li>𝞫 (or 𝞱) : 회전된 <strong>x-축</strong>을 회전축으로 하여 회전된 z-y 좌표축의 각도</li>
<li>𝞬 (or 𝟇) : <strong>위에서 회전된 z-축</strong>을 회전축으로 하여 회전된 x-y 좌표축의 각도</li>
</ul>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/a/a1/Eulerangles.svg/250px-Eulerangles.svg.png" alt="오일러각"></p>
<p>오일러 각의 범위는 𝞪와 𝞬 는 이상적인 상황에서 2 π radian 까지이며 , 𝞫의 경우 -π/2~π/2 radian 까지이다. 𝞫의 범위가 제한적인 것을 <strong>짐벌 락</strong>  이라고 하는데, 앞서 회전한 두 축의 영향으로 세 번째 회전의 가동 범위가 줄어들기 때문이다.</p>
<h5><span id="document">Document</span></h5>
<ul>
<li>Pitch (the <code>x</code> component) is the rotation about the node’s x-axis.</li>
<li>Yaw (the <code>y</code> component) is the rotation about the node’s y-axis.</li>
<li>Roll (the <code>z</code> component) is the rotation about the node’s z-axis.</li>
</ul>
<br>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node.eulerAngles = <span class="type">SCNVector3</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="type">Float</span>(degreesToRadians))</span><br></pre></td></tr></table></figure>
<p>extension을 통해 아래와 같이 쓰면 편리하다.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Int</span> </span>&#123;</span><br><span class="line"><span class="keyword">var</span> degreesToRadians: <span class="type">Double</span> &#123; <span class="keyword">return</span> <span class="type">Double</span>(<span class="keyword">self</span>) * .pi/<span class="number">180</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>
<h2><span id="rotation">Rotation</span></h2>
<hr>
<p>로테이션 값으로는 <code>CGFloat</code> 단위로 쓰이며 degee를 radian으로 변환해서 사용한다.</p>
<p><img src="https://cdn-images-1.medium.com/max/1600/1*_NesYbqz4HqX-it5ieB0Lw.png" alt="degreeNradian"></p>
<br>
<h5><span id="radian">Radian</span></h5>
<hr>
<p>라디안은 각도의 측정 단위이며, 반지름의 길이가 1인 원의 중심으로 부터 호의 길이가 1인 각을 1라디안으로 정의한다.</p>
<p>따라서 <code>1radian = 180/π degrees</code> 이다.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Double</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">toRadians</span><span class="params">()</span></span> -&gt; <span class="type">Double</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span> * .pi / <span class="number">180.0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">toDegrees</span><span class="params">()</span></span> -&gt; <span class="type">Double</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span> * <span class="number">180.0</span> / .pi</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>
<h4><span id="matrix-gt-vector">matrix -&gt; vector</span></h4>
<hr>
<p>매트릭스 값을 벡터값으로 변환하는 과정은 다음과 같다.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">positionFromTransform</span><span class="params">(<span class="number">_</span> transform: matrix_float4x4)</span></span> -&gt; <span class="type">SCNVector3</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    column 0  column 1  column 2  column 3</span></span><br><span class="line"><span class="comment">//         1        0         0       X       </span></span><br><span class="line"><span class="comment">//         0        1         0       Y      </span></span><br><span class="line"><span class="comment">//         0        0         1       Z       </span></span><br><span class="line"><span class="comment">//         0        0         0       1    </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="type">SCNVector3Make</span>(transform.columns.<span class="number">3</span>.x, transform.columns.<span class="number">3</span>.y, transform.columns.<span class="number">3</span>.z)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>source : <a href="https://medium.com/journey-of-one-thousand-apps/arkit-and-corelocation-part-two-7b045fb1d7a1" target="_blank" rel="noopener">ARKit and CoreLocation</a></p>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ARKit </tag>
            
            <tag> CoreLocation </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[스케쥴링]]></title>
      <url>/2018/05/02/CS-OS-3Scheduling/</url>
      <content type="html"><![CDATA[<h1><span id="seukejyulring-algorijeum">스케쥴링 알고리즘</span></h1>
<h2><span id="seukejulring-algorijeum">스케줄링 알고리즘</span></h2>
<h3><span id="fcfs-first-come-first-served-seukejyulring">FCFS (First-Come First-Served) 스케쥴링</span></h3>
<hr>
<ul>
<li><strong>비선점 스케쥴링</strong> 알고리즘</li>
<li>Queue와 같은 작동원리</li>
<li>준비큐에 도착한 순서에 따라 디스패치(준비-&gt;실행)</li>
<li>장점 : 가장 간단한 스케쥴링</li>
<li>단점 : 짧은 프로세스가 긴 프로세스를 기다리거나, 중요한 프로세스가 나중에 수행될 수 있음.</li>
</ul>
<br>
<h3><span id="sjf-shortest-job-first-seukejyulring">SJF (Shortest Job First) 스케쥴링</span></h3>
<hr>
<ul>
<li>비선점 스케쥴링 알고리즘</li>
<li>준비 큐에서 <strong>기다리는 프로세스 중 실행시간이 가장 짧다고 예상된 것</strong>을 먼저 디스패치</li>
<li>장점 : 일괄처리 환경에서 구현하기 쉬움 , 상위단계 스케쥴링에서 많이 쓰임.</li>
<li>단점 : 실행 예정 시간 길이를 사용자의 추정치에 의존하기 때문에 실제로는 먼저 처리할 직업의 CPU 시간을 예상할 수 없음.</li>
</ul>
<br>
<h3><span id="str-shortest-remaining-time-seukejyulring">STR(Shortest Remaining Time) 스케쥴링</span></h3>
<hr>
<ul>
<li>선점 스케줄링 알고리즘</li>
<li>실행이 끝날 때 까지 남은 시간 추정치가 가장 짧은 프로세스를 먼저 디스패치 (SJF와 비슷하다)</li>
<li>프레세싱 도중에 들어온 프로세스의 사이클 시간과 현재 프로세싱 중인 것과 남은 시간을 비교하여 더 짧은 것을 먼저 선점하여 실행한다. 만약 실행중인 프로세스가 더 많은 사이클이 남아있다면 준비큐로 들어가게되고 도중에 들어온 프로세스가 실행되게 된다.</li>
<li>대기시간 : 준비큐에 들어와서 실행되기 직전까지의 시간</li>
<li>반환시간 : 준비시간 부터 종료시간까지의 시간</li>
<li>장점 : SJF보다 평균 대기시간이나 평균 반환시간에서 효율적, 대화형 운영체제에 유용</li>
<li>단점 : 각 프로세스의 실행시간 추적, 선점을 위한 문맥 교환 등 SJF보다 오버헤드가 큼</li>
</ul>
<br>
<h3><span id="rr-round-robin-seukejyulring">RR (Round Robin) 스케쥴링</span></h3>
<hr>
<ul>
<li>선점 스케쥴링 알고리즘</li>
<li>준비 큐에 도착한 순서에 따라 디스패치하지만 정해진 시간 할당량에 의해 실행을 제한(FCFS와 비슷한 방식이지만 정해진 할당량이 있다는 차이점이 있다)</li>
<li>시간 할당량 안에 완료되지 못한 프로세스는 <strong>준비 큐의 맨 뒤에 배치</strong></li>
<li>시간 할당량 보다 프로세싱 시간이 크게되면 할당량 만큼만 진행하고 남은 프로레싱은 준비 큐의 맨뒤로 배치되어 순서가 되면 진행된다.</li>
<li>장점 : CPU를 독점하지 않고 공평하게 이용, 대화형 운영체제에서 유용</li>
<li>단점 : <em>시간 할당량이 너무 크면</em> FCFS 스케줄링과 같아짐. (시간 할당량보다 프로세싱 시간이 더 짧게 걸릴때) , 혹은 <em>시간 할당량이 너무 작으면</em> 문맥 교환에 따른 오버헤드가 크게 증가함</li>
</ul>
<p>*** 오버헤드(Overhead) : <em>어떤 처리를 하기 위해 들어가는 간접적인 처리 시간 · 메모리 등을 말한다.</em></p>
<br>
<h3><span id="hrn-highest-response-ratio-next-seukejulring">HRN (Highest Response-ratio Next) 스케줄링</span></h3>
<hr>
<ul>
<li>비선점 스케줄링 알고리즘</li>
<li>준비 큐에서 기다리는 프로세스 중 <strong>응답비율이 가장 큰 것을 먼저</strong> 디스패치</li>
</ul>
<p><code>응답비율 = 대기시간 + 예상 실행시간 / 예상 실행시간 = ( 대기시간 / 예상 실행시간 ) + 1</code></p>
<ul>
<li>SJF의 단점을 보완(시간이 긴 프로세스에게 불리함)</li>
</ul>
<br>
<h3><span id="dadangye-pideubaeg-kyu-seukejulring">다단계 피드백 큐 스케줄링</span></h3>
<hr>
<ul>
<li>선점 스케줄링 알고리즘</li>
<li><strong>I/O 중심 프로세스</strong>로 CPU 중심 프로세스의 특성에 따라 서로 다른 시간 할당량 부여</li>
<li>단계 k의 큐에 있는 프로세스가 CPU를 할당 받으려면 단계 1~ 단계 k-1 까지 모든 큐가 비어있어야만 함</li>
<li>예를 들어 연산 위주의 CPU 중심 프로세스는 낮은 우선권이지만 긴 시간 할당량을 가진다. (높은 단계의 큐로 가기에 적합)</li>
<li>각 단계마다 하나씩 큐 존재</li>
<li>단계가 커질수록 시간 할당량도 커짐</li>
</ul>
<h5><span id="process">Process</span></h5>
<ol>
<li>새로운 프로세스는 최상위 단계의 준비 큐에 들어간 후 FCFS의 순서로 CPU를 할당받아 실행되다가 그 큐의 시간 할당량이 끝나면 한단계 아래의 준비 큐에 들어감으로써 결과적으로 우선순위가 한 단계 낮아지게 된다.</li>
<li>각 단계에서도 그 단계 큐의 시간 할당량을 다 사용할 때까지 계속 실행된다면 다음 큐로 들어가게 되며, 마지막 단계에서는 더 내려갈 단계가 없으므로 RR방식으로 실행된다</li>
</ol>
<br>
<h5><span id="jeogeungjeog-dadangye-pideubaeg-kyu-seukejulring">적응적 다단계 피드백 큐 스케줄링</span></h5>
<ul>
<li>시간 할당량을 다 쓰기 전에 CPU를 반납하는 경우 하나 작은 단계의 큐로 이동 배치</li>
<li>연산 위주의 프로세스에서 -&gt; I/O 위주로 바뀐다면 점점 작은 단계로 배치 가능</li>
</ul>
<br>
<h2><span id="summary">Summary</span></h2>
<hr>
<p>FCFS -&gt; RR -&gt; 다단계 피드백 큐</p>
<p>SJF -&gt; HRN</p>
<p>SJF -&gt; STR</p>
<p>비선점 -&gt; 선점의 방식으로 보완 차용되어 파생된 방식들이 많다.</p>
]]></content>
      
        <categories>
            
            <category> CS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 스케쥴링 </tag>
            
            <tag> 프로세스 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[프로세스]]></title>
      <url>/2018/05/02/CS-OS-2Process/</url>
      <content type="html"><![CDATA[<h1><span id="peuroseseu">프로세스</span></h1>
<h2><span id="peuroseseu-process">프로세스 (Process)</span></h2>
<hr>
<ul>
<li>실행중인 프로그램을 의미한다.</li>
<li>운영체제로 부터 자원을 할당받아 동작한다.</li>
<li>자원 : CPU, 메모리, 입출력 장치, 파일 등</li>
<li>동작: CPU가 프로세스의 명령을 실행</li>
<li>처리의 기본 단위</li>
<li>자원 소유의 단위(하나의 주소공간) 및 디스패칭의 단위(하나의 제어흐름)</li>
<li>단일 프로세스 내에서 동시처리 불가능</li>
</ul>
<h3><span id="peuroseseu-gwanrijayi-yeoghwal">프로세스 관리자의 역활</span></h3>
<hr>
<ul>
<li>프로세스를 생성 및 삭제</li>
<li>프로세스 실행(CPU 할당)을 위한 스케줄 결정</li>
<li>프로세스의 상태를 관리하여 상태 전이를 처리</li>
</ul>
<br>
<h4><span id="5-sangtaemodel">5-상태모델</span></h4>
<ol>
<li>생성 : 처음 작업이 시스템에 주어진 상태</li>
<li>준비 : 실행 준비가 되어 CPU 할당을 기다리는 상태</li>
<li>실행 : 프로세스가 처리되는 상태</li>
<li>종료 : 모든 처리가 완료되어 사용자에게 반환되는 상태</li>
<li>대기 : 프로세스가 특정 자원을 할당받을 때 까지 또는 I/O 작업이 끝날 때까지 작업이 보류되는 상태</li>
</ol>
<ul>
<li><code>준비</code> -&gt; <code>실행</code> 과정을 <strong>Dispatch</strong> 라고한다.</li>
</ul>
<h4><span id="peuroseseu-jeeo-beulrog-process-control-block-pcb">프로세스 제어 블록 (Process Control Block , PCB)</span></h4>
<hr>
<ul>
<li>프로세스의 관리를 위한 목적</li>
<li>프로세스의 정보를 보관</li>
</ul>
<br>
<h4><span id="peuroseseu-saengseonggwa-jongryo">프로세스 생성과 종료</span></h4>
<hr>
<ul>
<li>프로세스의 이름 (PID) 결정</li>
<li>준비 큐에 삽입</li>
<li>초기 우선순위 부여</li>
<li>프로세스 제어 블록(PCB) 생성</li>
</ul>
<br>
<h4><span id="peuroseseu-saengseong-siseutem-hoculgwa-jongryo">프로세스 생성 시스템 호출과 종료</span></h4>
<hr>
<ul>
<li>프로세스 생성 : 하나의 프로세스가 프로세스 생성 시스템 호출을 통해 새로운 프로세스를 생성 (tree 형태)</li>
<li>fork()</li>
<li>호출하는 프로세스 : 부모 프로세스</li>
<li>생성되는 프로세스 : 자식 프로세스</li>
<li>프로세스 종료 : 프로세스의 마지막 명령이 실행을 마치는 경우, 프로세스 종료 후 부모 프로세스에게 실행결과를 되돌려 줌</li>
</ul>
<br>
<h2><span id="seuredeu-thread">스레드 (Thread)</span></h2>
<hr>
<ul>
<li>프로세스 내에서의 <strong>다중처리</strong>를 위해 제안된 개념</li>
<li>하나의 프로세스 내에는 하나 이상의 쓰레드가 존재</li>
<li>하나의 스레드 내에서는 하나의 실행점만 존재 ( 디스패칭의 단위 )</li>
<li>실행에 필요한 최소한의 정보만을 가지며, 자신이 속해 있는 프로세스의 실행환경을 공유</li>
</ul>
<br>
<h3><span id="dajung-sseuredeuyi-jangjeom">다중 쓰레드의 장점</span></h3>
<hr>
<ul>
<li>멀티 CPU 혹은 멀티코어 시스템에서는 병렬처리 가능</li>
<li>처리 속도 별로 쓰레드가 나눠진 경우 효율적인 처리 가능</li>
</ul>
<br>
<h2><span id="seukejyulring-scheduling">스케쥴링 (Scheduling)</span></h2>
<hr>
<ul>
<li>공정성 : 모든 프로세스가 적정 수준에서 CPU 작업을 할 수 있게 함</li>
<li>균형 : 시스템의 자원들의 충분히 활용될 수 있게 함</li>
</ul>
<ol>
<li>상위단계 스케줄링</li>
</ol>
<ul>
<li>시스템에 들어오는 작업들을 선택하여 프로세스를 생성한 후 프로세스 준비 큐에 전달</li>
<li>선택 기준 : 시스템의 자원을 효율적으로 이용할 수 있도록 하는 것</li>
<li><u>입출력(I/O) 중심 작업과 연산 중심 작업을 균형 있게 선택</u></li>
</ul>
<ol start="2">
<li>하위단계 스케쥴링</li>
</ol>
<ul>
<li>사용 가능한 CPU를 준비상태의 어느 프로세스에게 배당할지를 결정</li>
<li>CPU를 배당받은 프로세스는 결국 실행상태가 되어 프로세스가 처리됨</li>
<li>수행 주체 : Dispatcher</li>
</ul>
<ol start="3">
<li>중간단계 스케쥴링</li>
</ol>
<ul>
<li>프로세스를 일시적으로 메모리에서 제거하여 중지시키거나 다시 활성화 시킴</li>
<li>시스템에 대한 단기적인 부하를 조절</li>
</ul>
<br>
<h4><span id="seonjeom-preemptive-seukejyulring">선점(Preemptive) 스케쥴링</span></h4>
<hr>
<ul>
<li><em>진행 중인 프로세스에 인터럽트</em>를 걸고 <strong>다른 프로세스에 CPU를 할당</strong>하는 스케쥴링 전략</li>
<li>높은 우선순위의 프로세스를 긴급하게 처리하는 경우에 유용</li>
<li>대화식 시분할 시스템에서 빠른 응답시간을 유지하는데 유용</li>
<li>문맥 교환에 따른 오버헤드 발생</li>
</ul>
<br>
<h4><span id="biseonjeom-nonpreemptive-seukejulring-jeongcaeg">비선점(Nonpreemptive) 스케줄링 정책</span></h4>
<hr>
<ul>
<li>프로세스가 CPU를 할당받아 실행이 시작되면 작업 자체가 I/O 인터럽트를 걸거나 작업을 종료할 때까지 실행상태에 있게 됨</li>
<li>모든 프로세스가 공정하게 순서에 따라 실행된다 -&gt; 응답시간 예측 가능</li>
<li>짧은 프로세스가 긴 프로세스를 기다리게 될 수 있다. (비효율적일 수 있다)</li>
</ul>
]]></content>
      
        <categories>
            
            <category> CS </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[운영체제]]></title>
      <url>/2018/05/02/CS-Operating-System/</url>
      <content type="html"><![CDATA[<h1><span id="unyeongceje">운영체제</span></h1>
<h2><span id="keompyuteo-siseutemgwa-unyeongceje">컴퓨터 시스템과 운영체제</span></h2>
<hr>
<ul>
<li>컴퓨터 시스템의 운영</li>
</ul>
<ol>
<li>컴퓨터 시스템의 자원을 제어 및 관리</li>
<li>응용 프로그램들의 실행을 도와주는 소프트웨어</li>
</ol>
<ul>
<li>사용자 지원</li>
</ul>
<ol>
<li>사용자의 명령을 해석하여 실행</li>
<li>사용자와 하드웨어 사이의 매개체 역할 수행</li>
</ol>
<br>
<h3><span id="cpuyi-dongjag-modeu">CPU의 동작 모드</span></h3>
<hr>
<ul>
<li>슈퍼바이저 모드(커널 모드 :: Kernel)</li>
<li>운영체제의 커널이 동작되는 모드</li>
<li>하드웨어를 직접 제어할 수 있는 <strong>CPU 명령어 사용 가능</strong></li>
<li>보호 모드(사용자 모드)</li>
<li>응용 프로그램이 동작되는 모드</li>
<li>하드웨어를 직접 제어할 수 있는 <strong>CPU 명령어 사용 불가능</strong></li>
<li>시스템 호출 : 응용 프로그램이 운영체제에게 서비스를 요청하는 메커니즘</li>
</ul>
<br>
<h4><span id="keoneol-kernel">커널(Kernel)</span></h4>
<hr>
<ul>
<li>운영체제의 핵심 요소</li>
<li>응용 프로그램과 하드웨어 수준의 처리 사이의 가교 역활</li>
</ul>
<br>
<ol>
<li>일체형 커널(monolithic kernel)</li>
</ol>
<ul>
<li>운영체제의 모든 서비스가 커널 내에 포함됨</li>
<li>장점: 커널 내부 요소들이 서로 효율적으로 상호작용을 할 수 있음</li>
<li>단점: 한 요소에 있는 오류로 인해 시스템 전체에 장애가 발생할 수 있음</li>
<li>UNIX, Linux</li>
</ul>
<ol start="2">
<li>마이크로 커널(microkernel)</li>
</ol>
<ul>
<li>운영체제의 대부분 요소들을 커널 외부로 분리</li>
<li>커널 내에는 메모리 관리, 멀티태스킹, 프로세스 간 통신 등 최소한의 요소들만 남김</li>
<li>장점: 새로운 서비스를 추가하여 <strong>운영체제를 확장하기 쉬움</strong>. 유지보수가 용이하여 <strong>안정성이 우수</strong>함.</li>
<li>단점: 커널 외부 요소들 사이에는 IPC를 통해야만 하므로 성능 저하가 발생함.</li>
</ul>
<br>
<h2><span id="unyeongcejeyi-guseong">운영체제의 구성</span></h2>
<hr>
<ol>
<li>프로세스 관리자 (실행중인 프로그램 관리)</li>
</ol>
<ul>
<li>프로세스를 생성, 삭제, <u>CPU 할당을 위한 스케쥴 결정</u></li>
<li>프로세스의 상태를 관리하여 상태 전이를 처리</li>
</ul>
<ol start="2">
<li>메모리 관리자</li>
</ol>
<ul>
<li>메모리(주기억장치) 공간에 대한 요구의 유효성 체크</li>
<li>메모리 할당 및 회수</li>
<li>메모리 공간 보호</li>
</ul>
<ol start="3">
<li>장치 관리자</li>
</ol>
<ul>
<li>컴퓨터 시스템의 모든 장치(키보드, 디스크, 네트워크 장치…)를 관리</li>
<li>시스템의 장치를 할당, 작동 시작, 반환</li>
</ul>
<ol start="4">
<li>파일 관리자</li>
</ol>
<ul>
<li>컴퓨터 시스템의 모든 파일을 관리</li>
<li>파일의 접근 제한 관리</li>
<li>파일을 열어 자원을 할당하거나 파일을 닫아 자원을 회수</li>
</ul>
<br>
<h2><span id="unyeongcejeyi-yuhyeong">운영체제의 유형</span></h2>
<hr>
<ol>
<li>일괄처리(batch processing) 운영체제</li>
</ol>
<ul>
<li>작업을 모아서 처리</li>
<li>사용자와 상호작용 없이 순차적으로 실행</li>
<li>효율성 평가: 처리량, 반환시간</li>
</ul>
<ul>
<li>반환시간: 작업의 생성 시점부터 종료 시점까지의 소요시간</li>
<li>처리량: 주어진 시간 안에 처리된 작업의 수</li>
</ul>
<ul>
<li>Ex, OMR</li>
</ul>
<ol start="2">
<li>대화형 (interactive) 운영체제</li>
</ol>
<ul>
<li>시분할 운영체제라고도 함</li>
<li>일괄처리 운영체제보다 빠르지만 실시간 운영체제보다는 느린 응답시간</li>
<li>이용자에게 즉각적인 피드백을 제공</li>
</ul>
<ol start="3">
<li>실시간(real-time) 운영체제</li>
</ol>
<ul>
<li>가장 빠른 응답시간</li>
<li>처리의 결과가 현재의 결정에 영향을 주는 환경에서 사용</li>
<li>Ex, 우주선 비행 시스템, 미사일 제어, 증권거래 관리 시스템, 은행 입출금 시스템 등에 사용</li>
</ul>
<ol start="4">
<li>하이브리드(hybrid) 운영체제</li>
</ol>
<ul>
<li><u>일괄처리 운영체제</u>와 <u>대화형 운영체제</u>의 결함</li>
<li>이용자는 터미널을 통해 접속하고 빠른 응답시간을 얻음</li>
<li>대화형 작업이 많지 않을 경우 백그라운드에서 배치 프로그램 실행</li>
<li>현재 사용되고 있는 대부분의 대형 컴퓨터 시스템은 하이브리드 운영체제</li>
</ul>
<br>
<h2><span id="unyeongcejeyi-yeogsa">운영체제의 역사</span></h2>
<hr>
<ul>
<li>1940년대 : 초기 전자식 디지털 컴퓨터</li>
<li>운영체제가 존재하지 않음</li>
<li>기계적 스위치에 의해 작동</li>
<li>1950년대 : 단순 순차처리 및 단일흐름 일괄처리</li>
<li>한 번에 오직 하나의 작업만을 수행</li>
<li>최초의 운영체제 등장</li>
<li>1960년대 : 멀티프로그래밍</li>
<li>멀티프로그래밍, 시분할 처리 개념</li>
<li>다중 대화식 사용자 지원</li>
<li>1970년대 : 멀티모드 시분할</li>
<li>일괄처리, 시분할 처리, 실시간 처리를 지원하는 멀티모드 시분할의 보편화</li>
<li>근거리 지역 네트워크(LAN)의 실용화</li>
<li>정보보호 및 보안문제의 증대로 암호화의 중대성 대두</li>
<li>네트워크의 대두와 함께 클라이언트 / 서버 모델 확산</li>
<li>1990년대 : 병렬처리 및 분산처리</li>
<li>순차처리를 벗어나 분산 및 병렬 처리 발전</li>
<li>그래픽 사용자 인터페이스 (GUI)의 강화</li>
<li>선점형 멀티태스킹, 멀티쓰레딩, 가상 메모리의 보편화</li>
<li>2000년대 : 모바일 및 임베디드 운영체제</li>
<li>모바일 운영체제 보편화</li>
<li>가전제품을 위한 임베디드 운영체제의 보편화</li>
<li>고속화, 고기능화, 경량화 방향으로 발전</li>
<li>네트워크 기반의 분산 및 병렬 운영체제의 보편화</li>
<li>클라우드 환경의 운영체제</li>
</ul>
<br>
]]></content>
      
        <categories>
            
            <category> CS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS_GCCvsLLVM]]></title>
      <url>/2018/05/02/iOS-GCCvsLLVM/</url>
      <content type="html"><![CDATA[<h1><span id="ios-gcc-vs-llvm">[iOS] GCC VS LLVM</span></h1>
<h2><span id="compiler">Compiler</span></h2>
<hr>
<p><strong>컴파일 언어</strong>란 작성한 코드를 컴퓨터가 인식하기 위해 row-level 언어로 컴파일을 수행하고 이러한 컴파일 단계를 거쳐야 실행할 수 있는 언어를 말한다. 이때 컴파일러가 <code>Code -&gt; Binary</code> 과정을 통해 변환시킨다.</p>
<h2><span id="gcc">GCC</span></h2>
<hr>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Queue]]></title>
      <url>/2018/02/07/algorism-Queue/</url>
      <content type="html"><![CDATA[<h1><span id="queue">Queue</span></h1>
<h2><span id="kyu-jaryogujoyi-adt">큐 자료구조의 ADT</span></h2>
<ul>
<li>QueueInit : 큐의 초기화를 진행한다. 큐 생성 후 제일 먼저 호출되어야 하는 함수이다.</li>
<li>QIsEmpty : 큐가 빈 경우 true , 그렇지 않으면 false를 리턴한다.</li>
<li>Enqueue : 큐에 데이터를 저장한다. 매개변수 data로 전달된 값을 저장한다.</li>
<li>Dequeue : 저장순서가 가장 앞선 데이터를 삭제한다. 삭제된 데이터는 반환된다. 함수의 호출을 위해서는 데이터가 하나 이상 존재함이 보장되어야 한다.</li>
<li>QPeek : 저장순서가 가장 앞선 데이터를 반환하되 삭제하지 않는다. 함수의 호출을 위해서는 데이터가 하나 이상 존재함이 보장되어야 한다.</li>
</ul>
<hr>
<br>
<h2><span id=""></span></h2>
]]></content>
      
        <categories>
            
            <category> ALGORISM </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 알고리즘 </tag>
            
            <tag> 큐 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Stack]]></title>
      <url>/2018/02/06/algorism-Stack/</url>
      <content type="html"><![CDATA[<h1><span id="stack">Stack</span></h1>
<h2><span id="seutaegyi-gibongujo-by-list">스택의 기본구조 :by List</span></h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span>:</span></span><br><span class="line">    <span class="comment"># 스택의 초기화</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.stack = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">SisEmpty</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self.stack) == <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">SPush</span><span class="params">(self, val)</span>:</span></span><br><span class="line">        self.stack.append(val)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">SPop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.SisEmpty():</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.stack.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">SPeek</span><span class="params">(self)</span>:</span></span><br><span class="line">        index = len(self.stack) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self.SisEmpty():</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.stack[index]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## Result</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s_stack = Stack()</span><br><span class="line">    s_stack.SPush(<span class="number">10</span>)</span><br><span class="line">    s_stack.SPush(<span class="number">20</span>)</span><br><span class="line">    s_stack.SPush(<span class="number">30</span>)</span><br><span class="line">    s_stack.SPush(<span class="number">40</span>)</span><br><span class="line"></span><br><span class="line">    print(s_stack.SisEmpty())   <span class="comment">#false</span></span><br><span class="line">    print(s_stack.SPeek())  <span class="comment">#40</span></span><br><span class="line">    print(s_stack.SPop())   <span class="comment">#40</span></span><br><span class="line">    print(s_stack.SPop())   <span class="comment">#30</span></span><br><span class="line">    print(s_stack.SPeek())  <span class="comment">#20</span></span><br></pre></td></tr></table></figure>
<br>
<h2><span id="seutaegeul-iyonghan-yeonsan-huwi-pyogibeob">스택을 이용한 연산 후위 표기법</span></h2>
<h4><span id="adt">ADT</span></h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">convertToPostfix</span><br><span class="line"><span class="comment"># 입력받은 연산자를 후위연산자로 변환한다.</span></span><br><span class="line"></span><br><span class="line">getOpPrec</span><br><span class="line"><span class="comment">#연산자의 가중치를 리턴한다.</span></span><br><span class="line"></span><br><span class="line">get_postfix_exp</span><br><span class="line"><span class="comment">#후위연산자를 리턴한다.</span></span><br></pre></td></tr></table></figure>
<h4><span id="rule">Rule</span></h4>
<ol>
<li><code>(</code> 는 무조건 stack에 담는다.</li>
<li><code>)</code> 를 만나면 무조건 그 이전까지 stack에 담겨있던 것들을 결과물로 옮긴다. (단, 자기자신은 제거될 것)</li>
<li>숫자가 아닌 연산자는 stack에 쌓는다.</li>
</ol>
<br>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> stack <span class="keyword">import</span> Stack</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PostfixCalculate</span>:</span></span><br><span class="line">    <span class="comment"># 원래 주어진 수식</span></span><br><span class="line">    <span class="comment"># origin_exp</span></span><br><span class="line">    <span class="comment"># 결과 (후위 수식)</span></span><br><span class="line">    <span class="comment"># postfix_exp</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># method</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, origin)</span>:</span></span><br><span class="line">        self.origin_exp = origin</span><br><span class="line">        self.postfix_exp = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getOpPrec</span><span class="params">(self,op)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> op == <span class="string">'*'</span> <span class="keyword">or</span> op == <span class="string">'/'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">5</span></span><br><span class="line">        <span class="keyword">elif</span> op == <span class="string">'+'</span> <span class="keyword">or</span> op == <span class="string">'-'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">        <span class="keyword">elif</span> op == <span class="string">'('</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>   <span class="comment"># 등록되지 않은 수식</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">convertToPostfix</span><span class="params">(self)</span>:</span></span><br><span class="line">        exp_list = []</span><br><span class="line">        operate_stack = Stack()</span><br><span class="line"></span><br><span class="line">        <span class="comment">#숫자와 수식을 구별한다</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> self.origin_exp:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> i.isdigit():</span><br><span class="line">                exp_list.append(i)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># ( 거나 스택이 비었을 경우</span></span><br><span class="line">                <span class="keyword">if</span> i == <span class="string">'('</span> <span class="keyword">or</span> operate_stack.SisEmpty():</span><br><span class="line">                    operate_stack.SPush(i)</span><br><span class="line">                <span class="comment"># ) 경우 연산자를 모두 배열에 넣기</span></span><br><span class="line">                <span class="keyword">elif</span> i == <span class="string">')'</span>:</span><br><span class="line">                    operation = operate_stack.SPop()</span><br><span class="line">                    exp_list.append(operation)</span><br><span class="line">                <span class="comment"># 기존의 연산자보다 비중이 높다면 그대로 유지</span></span><br><span class="line">                <span class="keyword">elif</span> self.getOpPrec(i) &gt; self.getOpPrec(operate_stack.SPeek()):</span><br><span class="line">                    operate_stack.SPush(i)</span><br><span class="line">                <span class="comment"># 기존의 연산자보다 비중이 같거나 낮을때</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">while</span> <span class="keyword">not</span> operate_stack.SisEmpty() <span class="keyword">and</span> self.getOpPrec(i) &lt;= self.getOpPrec(operate_stack.SPeek()):</span><br><span class="line">                       operation = operate_stack.SPop()</span><br><span class="line">                       exp_list.append(operation)</span><br><span class="line">                    operate_stack.SPush(i)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> operate_stack.SisEmpty():</span><br><span class="line">            op = operate_stack.SPop()</span><br><span class="line">            exp_list.append(op) </span><br><span class="line">        self.postfix_exp = <span class="string">''</span>.join(exp_list)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_postfix_exp</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.postfix_exp:</span><br><span class="line">            self.convertToPostfix()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> self.postfix_exp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    origin = input(<span class="string">"수식을 입력해주세요: "</span>)</span><br><span class="line"></span><br><span class="line">    calcurate = PostfixCalculate(origin)</span><br><span class="line">    calcurate.convertToPostfix()</span><br><span class="line">    print(<span class="string">"resutl:"</span>, calcurate.get_postfix_exp())</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> ALGORISM </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 알고리즘 </tag>
            
            <tag> 자료구조 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[메모리 저장구조 및 관리]]></title>
      <url>/2018/01/15/CS-memory/</url>
      <content type="html"><![CDATA[<h1><span id="memori-jeojanggujo">메모리 저장구조</span></h1>
<hr>
<p><img src="/img/ref/memory.png" alt="메모리저장구조"></p>
<ol>
<li>Code Segment</li>
</ol>
<ul>
<li>프로그램 코드 자체가 기계어로 저장되는 영역</li>
<li>읽기 전용 데이터<br>
​</li>
</ul>
<ol start="2">
<li>Data Segment ( BSS + DATA )</li>
</ol>
<ul>
<li>프로그램 시작과 동시에 할당되고 프로그램 종료 시 메모리에서 소멸된다.</li>
<li>전역변수, <strong>Static 변수</strong> 등과 같이 프로그램이 실행되는 동안 항상 접근 가능한 변수를 위한 공간이다.</li>
<li>DATA에는 <em>초기화된 전역변수</em>가 저장된다</li>
<li>BSS(Block Stated Symbol)에는 <em>초기화 값이 없는 전역변수</em>를 저장한다.</li>
<li>함수 내부에 선언된 Static 변수는 프로그램이 실행될 때 공간만 할당되고, <strong>함수가 실행될 때 초기화</strong>된다.</li>
</ul>
<ol start="3">
<li>Heap Segment</li>
</ol>
<ul>
<li><strong>동적 할당 영역</strong>으로 참조타입에 대한 저장 공간이다.</li>
<li>프로그래머에 의해 할당되는 공간</li>
<li>소멸 시점은 언어에 따라 <strong><em>GC, ARC</em></strong> 등에 의해 결정된다.</li>
</ul>
<ol start="4">
<li>Stack Segment</li>
</ol>
<ul>
<li>지역 변수, 매개 변수, 리턴 값 등의 <strong>임시 데이터를 저정하는 영역</strong>이다.</li>
<li>함수 시작과 함께 생성되었다가 종료 시 반환된다.</li>
<li>값 타입 저장 공간이다.</li>
</ul>
<br>
<h2><span id="memoriyi-haldang">메모리의 할당</span></h2>
<hr>
<p><img src="/img/ref/memory2.png" alt="메모리할당"></p>
<ul>
<li>CODE, DATA, BSS 영역은 프로그램 컴파일시 처음부터 크기가 정해지는 값들이 저장된다. 따라서 프로그램이 종료하기 전까지 메모리의 크기의 변화가 거의 없다. (전역 변수는 값은 변하더라도 타입은 크기는 변하지 않는다.)</li>
<li>하지만 Stack에서는 지역변수나 함수에 사용되는 인자 등이 할당되는데 CODE 영역에 저장되어 있다가 <strong>런타임 시점</strong>에 할당되었다가 범위가 벗어나면 해제된다. (할당될 위치나 순서, 변수의 타입에 따른 크기 등은 <strong>스택이 차지할 크기는 컴파일 시점에 결정</strong>된다.)</li>
<li>Heap은 <strong>동적할당된 포인터 변수나 인스턴스</strong> 들이 저장되는 영역이기 때문에 명시적으로 해제하거나 더 이상 사용되지 않아 GC(Garbage Collector)에 의해. 수거되어 런타임 시점에 할당되었다가 해제되게 된다.</li>
<li>따라서 Heap 과 Stack은 한정된 메모리 공간 내에서, 힙은 빈공간을 사이에 두고 힙은 낮은곳에서 -&gt; 높은메모리 주소로, 스택은 높은 메모리 주소에서 -&gt; 낮은 곳으로 크기를 채우며 메모리 공간을 차지한다. (그러다가 빈공간을 넘어서는 순간 메모리 오버 플로우가 발생된다.)</li>
</ul>
<br>
<h2><span id="peuroseseu-vs-sseuredeu">프로세스 VS 쓰레드</span></h2>
<hr>
<p><img src="/img/ref/processnthread.png" alt="프로세스와스레드"></p>
<ol>
<li>프로세스
<ul>
<li>각 프로세스 별로 독립적인 [Code, Data, Heap, Stack] 영역을 소유하여 프로세스 전환시(Context Switching) 메모리 전 영역에 대한 전환비용이 발생한다.</li>
</ul>
</li>
<li>쓰레드
<ul>
<li>쓰레드는 [Code, Data, Heap] 영역은 서로 공유하고 Stack 영역만 별도로 소유하여 전환비용이 프로세스에 비해 훨씬 적게 든다.</li>
</ul>
</li>
</ol>
<br>
<h1><span id="memori-gwanri-bangsig">메모리 관리 방식</span></h1>
<h2><span id="mrr-manual-retain-releaase">MRR (Manual Retain-Releaase)</span></h2>
<hr>
<ul>
<li>RC (Reference Count) 수동 관리 방식</li>
</ul>
<br>
<h2><span id="garbage-collection-gc">Garbage Collection (GC)</span></h2>
<hr>
<ul>
<li>정기적으로 Garbage Collector가 실행되어 사용되지 않는 메모리를 반환시키는 방식</li>
<li><s>OS X에서만 지원했었으나 현재는 deprecated</s></li>
</ul>
<br>
<h2><span id="arc-automatic-reference-count">ARC (Automatic Reference Count)</span></h2>
<hr>
<ul>
<li>RC 자동관리 방식. 컴파일러가 알아서 메모리 관리 함수를 적용해준다.</li>
<li>Apple 기본 메모리 관리 방식으로 현재는 거의 ARC만 쓴다.</li>
<li>retain 후 release 하지 않는 오류를 방지하고, 개발자가 메모리 관리를 하는 비중이 줄어들어 프로그래밍의 효율성을 높여준다.</li>
</ul>
<p><img src="/img/ref/ARC.png" alt="ARC"></p>
<br>
]]></content>
      
        <categories>
            
            <category> CS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> memorry </tag>
            
            <tag> ARC </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Git Flow]]></title>
      <url>/2018/01/13/Git-GitFlow/</url>
      <content type="html"><![CDATA[<h1><span id="git-flow">Git Flow</span></h1>
<h2><span id="beuraencing-gwanri-jeonryag">브랜칭 관리 전략</span></h2>
<h3><span id="main-branch">Main Branch</span></h3>
<h4><span id="baepo-master-beuraenci">배포 :: master 브랜치</span></h4>
<p>먼저 배포됬거나 배포준비(production-ready)된 코드는 <code>origin/master</code>에 두고 관리한다.</p>
<p><code>master</code> 브랜치에 병합 한다는 것은 <strong>새버전을 배포한다는 것을 의미</strong>한다. <code>master</code> 브랜치에서 커밋될 때 git hook 스크립트를 걸어서 자동으로 빌드하여 운영서버로 배포하는 형식을 취한다.</p>
<br>
<h4><span id="gaebal-develop-beuraenci">개발 :: develop 브랜치</span></h4>
<p>다음에 배포하기 위해 개발하는 코드는 <code>origin/develop</code>에서 관리한다. <strong>프로젝트를 진행하는 개발자들이 함께 보며 업무를 진행하는 브랜치</strong>이며 가장 역동적인 브랜치라고 할 수 있다. <code>develop</code> 브랜치의 코드가 안정화되고 배포할 준비가 되면 <code>master</code>로 병합하고 배포버전으로 태그를 단다.</p>
<br>
<h3><span id="assistance-branch">Assistance Branch</span></h3>
<p>배포를 준비하고, 이미 배포한 제품이나 서비스의 버그를 빠르게 해결(hotfix) 해야한다. 이 모든 것을 동시에 진행하기 위해서 다양한 브랜치가 필요하다.</p>
<h4><span id="gineungfeature-beuraenci"><strong>기능feature</strong> 브랜치</span></h4>
<p>기능<code>feature</code> 브랜치는 배포하려고 하는 <strong>기능을 개발하는 브랜치</strong>다. 기능을 개발하기 시작할 때는 언제 배포할 수 있을지 알 수 없다. 프로젝트를 진행하면서 애자일 방법론을 도입했다면, 스프린트 기간 동안에 개발해야할 기능이라면 <em>스프린트 기간동안 개발해야할 브랜치</em>를 말한다. 기능<code>feature</code> 브랜치는 그 기능을 다 완성할 때까지 유지하고 있다가 <strong>다 완성되면 개발<code>develop</code> 브랜치로 병합</strong>한다. 개발된 결과가 실망스럽거나 필요없을 때는 삭제하면 된다. 삭제하는 것에 미련을 가질 필요는 없다.</p>
<ul>
<li>git-flow 이용시 <code>feature/{branch-name}</code> 형식</li>
<li>이슈추적을 사용한다면 <code>feature/{issue-number}-{feature-name}</code> 형식</li>
</ul>
<p>참고사이트 : <a href="https://gist.github.com/ihoneymon/a28138ee5309c73e94f9" target="_blank" rel="noopener">https://gist.github.com/ihoneymon/a28138ee5309c73e94f9</a></p>
]]></content>
      
        <categories>
            
            <category> Technology </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 브랜칭전략 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CH20. Error Handling]]></title>
      <url>/2018/01/08/chap20-errorHandle/</url>
      <content type="html"><![CDATA[<h1><span id="error-handling">Error Handling</span></h1>
<h2><span id="oryuceori">오류처리</span></h2>
<hr>
<p>스위프트에서 오류를 처리하는 방법은 크게 두가지가 있다.</p>
<ul>
<li><strong>옵셔널</strong><br>
잘못된 처리의 결과나 실행 도중 실패했을 때 그 결과를 오류로 발생시키는 대신 <strong>nill</strong> 값으로 반환하여 개발자가 이를 적절히 알아서 처리</li>
<li><strong>오류 처리 구문</strong></li>
</ul>
<br>
<h3><span id="oryu-ceori-gumun">오류 처리 구문</span></h3>
<hr>
<p>초반 스위프트에서는 옵셔널만으로 오류를 충분히 처리할 수 있다고 여겨졌으나, 오류가 발생했을 때 <strong><em>오류에 대한 정보를 외부로 전달할 수 없다</em></strong> ( 다양한 오류 상황이 있음에도 불구하고 옵셔널은 모든 오류를 nil 로 반환함 )는 단점을 보완하고자 swift 2.0 부터 오류 처리 구문이 추가되었다.<br>
최근 객체지향 언어들은 오류가 발생했을 때 오류를 ‘반환(return)’ 하는 것이 아닌 <strong>‘던지는(throws)’</strong> 처리를 할 수 있게끔 지원한다. 왜냐하면 오류를 반환하려면 함수의 반환 타입과 일치해야만 하지만 오류를 던지는 것은 실행 흐름 중간에 오류 객체를 만들어 다른 실행 흐름으로 옮겨가는 것이기 때문이다.</p>
<br>
<h4><span id="step1-oryu-taib-jeongyihagi">Step1 : 오류 타입 정의하기</span></h4>
<p>보통 일관된 오류 주제에 소속된 여러 가지 오류를 정의할 수 있어야 하므로 보통 <strong>열거형</strong>으로 정의한다. 오류 타입으로 열거형을 정의할 때는 반드시 <strong>Error 프로토콜</strong>을 구현해야 한다.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Error</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 빈 프로토콜로 정의해도 된다.</span></span><br><span class="line">  <span class="comment">// 프로토콜을 구현했다는 사실 자체가 중요하기 때문!!</span></span><br><span class="line">  <span class="comment">// 이 프로토콜을 구현한 열거형은 컴파일러가 오류 타입으로 인정한다. </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ParsingError</span> : <span class="title">Error</span> </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> overSizeString</span><br><span class="line">  <span class="keyword">case</span> underSizeString</span><br><span class="line">  <span class="keyword">case</span> incorrectFormat</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>
<h4><span id="step2-oryu-deonjigi">Step2 : 오류 던지기</span></h4>
<p>함수나 메서드를 작성할 때 , 오류 객체를 외부로 던질 수 있다는 것을 컴파일러에게 알려주기 위해 정의 구문을 작성할 때 <strong>throws</strong> 키워드를 명시적으로 추가해주어야 한다. ( -&gt; 앞에 써준다.)</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">throwErrors</span><span class="params">()</span></span> <span class="keyword">throws</span> -&gt; <span class="type">String</span>		<span class="comment">// 오류를 던진다</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">throwErrors</span><span class="params">()</span></span> -&gt; <span class="type">String</span> 			<span class="comment">// 오류 던짐 불가</span></span><br></pre></td></tr></table></figure>
<br>
<h4><span id="step3-do-try-catch-gumuneseo-hoculhaejugi">Step3 : Do ~ try ~ catch 구문에서 호출해주기</span></h4>
<p>오류를 던지는 함수나 메서드를 호출할 때에는 앞에 <code>try</code>를 붙여주어야 한다. 그러나 try는 단순히 함수를 호출할 수 있을 뿐 던지는 오류를 잡아내지는 못한다. 따라서 <code>catch</code> 구문을 사용해서 잡야아 한다. catch 뒤에 오류타입을 기재해줘도된다.<br>
또한 오류를 던지지 않고 강제로 함수를 실행하고자 할 때는 <code>try!</code> 를 써준다. try 키워드의 경우 함수 실행 도중 에러가 발생하면 멈추고 오류를 던지지만 try! 같은 경우 강제로 함수가 실행되며, 오류가 발생할 경우 런타임 오류가 발생한다. (주의)</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="comment">// 함수 호출 및 오류가 발생하지 않는 상황에서 실행할 구문</span></span><br><span class="line">  <span class="keyword">try</span> throwErrors() <span class="comment">// 오류를 던질 수 있는 함수</span></span><br><span class="line">&#125; <span class="keyword">catch</span> <span class="type">ParseError</span>.overSizeString &#123;	<span class="comment">//에러가 던져젔을 경우 실행될 구문 </span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"입력된 문자열이 너무 깁니다"</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span> <span class="type">ParseError</span>.underSizeString &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"입력된 문자열이 너무 짧습니다"</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123; <span class="comment">//오류타입이 작성되지 않은 경우는 잡히지 않은 모든 구문을 잡아주는 와일드 카드 역활을 한다.</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"UnKnown Exception Error"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> SWIFT </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 오류처리 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Swift GCD]]></title>
      <url>/2018/01/06/iOS-GCD/</url>
      <content type="html"><![CDATA[<h1><span id="gcd-grand-central-dispatch">GCD (Grand Central Dispatch)</span></h1>
<h2><span id="swift-giban-gcd">swift 기반 GCD</span></h2>
<hr>
<p>GCD는 멀티코어 프로세스를 위한 <strong><em>Thread 프로그래밍 방법</em></strong>이다. 기존의 쓰레드 관리 기법은 개발자가 직접 쓰레드풀을 관리하는 등 수고가 들었지만 GCD에서는 Thread를 OS가 자동 관리 및 분배를 해준다.</p>
<p>기존에는 쓰레드를 직접 생성하고 관리했으나 GCD를 통해서 <strong>Dispatch Queue</strong>에 Task를 생성해서 집어넣기만 하면 된다.</p>
<br>
<h3><span id="meoltiseureding">멀티스레딩</span></h3>
<hr>
<p>연산을 병렬적으로 처리할 수 있도록 보조적인 실행 흐름을 여러 개 생성하는 방식이다. 반대되는 개념으로 <strong>싱글스레딩</strong>이 있으며, 이는 나누어지지 않은 단일 실행 단위가 순서대로 코드를 처리하는 것을 뜻한다.</p>
<p>특정 연산을 처리할 때 여러 개의 작은 단위로 쪼개어 계산하고 <em>최종적으로 이를 합쳐서 완성하는 방식</em> 이 대표적인 멀티 스레딩 방식이다. 또한 보조적인 실행 흐름을 만들어 <em>각각 별도의 실행을 할당</em>하는 것도 멀티 스레딩에 해당한다.</p>
<p>멀티 스레딩 여부는 대부분 언어의 차원에서 지원하며 , 멀티 스레딩을 지원하는 언어에서 싱글 스레드 기반 프로그래밍은 가능하나, 싱글 스레드 기반 프로그래밍에서 멀티 스레딩 방식으로 프로그래밍하는 것은 불가능하다.</p>
<p>Swift 에서는 멀티 스레드 프로세싱을 강화하여, <u>UI 관련된 구문은 <strong>메인 스레드</strong></u>에서 실행되고, 비동기로 실행되는 모든 구문은 서브 스레드에서 실행하도록 처리한다.</p>
<br>
<h3><span id="dispatch-queue">Dispatch Queue</span></h3>
<hr>
<p>Task를 적재하는 데이터 구조이다. 데이터 구조가 Queue이므로 작동 방식이 Serial(순차적) / Concurrent(동시) 상관없이 <strong>FIFO(First In First Out)</strong> 방식으로 동작한다.</p>
<ul>
<li><strong>Serial Dispatch Queue</strong> : Queue에 Push된 순서대로 1개의 Task씩 실행하며, 해당 Task가 끝나기를 기다린다. Queue를 여러 개 만들 수도 있으며, 각 Queue들은 Concurrency하게 돌아간다.</li>
<li><strong>Concurrent Dispatch Queue</strong> : Global Dispatch Queue라고도 불리며, 여러 개의 task를 Concurrent하게 실행합니다. 실행순서는 Push한 순서대로 실행되며, 동시에 실행되는 Task는 시스템의 환경에 따라 달라집니다.</li>
<li><strong>Main Dispatch Queue</strong> : Application의 Main Thread에서 Serial하게 실행되는 Task들을 관리하는 Queue입니다. 해당 Queue는 Application의 Run loop에서 작동하게 됩니다.</li>
</ul>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> GCD </tag>
            
            <tag> 멀티스레드 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[네트워크 통신과 API]]></title>
      <url>/2017/11/27/iOS-api/</url>
      <content type="html"><![CDATA[<h1><span id="neteuweokeu-tongsingwa-api">네트워크 통신과 API</span></h1>
<h2><span id="neteuweokeu-tongsin">네트워크 통신</span></h2>
<hr>
<ol>
<li>TCP/UDP를 사용하는 소켓 방식의 <strong>연결성 통신</strong></li>
<li>HTTP , HTTPS , SMTP 등 프로토콜을 이용한 <strong>비연결성 통신</strong></li>
</ol>
<br>
<h3><span id="sokes-bangsigyi-yeongyeol-jihyang-tongsin">소켓 방식의 연결 지향 통신</span></h3>
<hr>
<ul>
<li>저수준 통신을 통하여 구현된다</li>
<li>서버와 클라이언트가 연결되면 한쪽에서 명시적으로 끊을 때까지 계속 지속해서 연결을 유지하는 방식이다.</li>
<li>연결이 유지되고 있는 상태 / 연결이 종료된 단계 / 연결이 이루어진 단계 로 각각 상태 구분을 하여 프로그래밍 한다.</li>
<li>장점 : 종료하기 전까지는 한번 연결된 통신을 계속 유지하므로 재연결할 필요 없이 원하는 만큼 빠르게 메세지를 주고 받을 수 있다.</li>
<li>단점 : 연결을 유지하기 위해 네트워크 대역을 많이 소모하고 , 서버 부하도 크다. 따라서 네트워크환경이 고르지 않은 모바일 서비스에서는 제한적으로 사용된다.</li>
<li>연결 종류
<ol>
<li>
<p><strong>TCP 연결</strong><br>
데이터 유실을 방지하고 <em>완전한 전송을 보장</em>하지만 상대적으로 느린 연결 방식</p>
</li>
<li>
<p><strong>UDP 연결</strong><br>
데이터의 완전한 전송을 보장하지 않지만 상대적으로 <em>빠른 연결</em> 방식</p>
<p>​</p>
<p>​</p>
</li>
</ol>
</li>
</ul>
<br>
<h3><span id="biyeongyeol-jihyang-tongsin">비연결 지향 통신</span></h3>
<hr>
<ul>
<li>비연결성 프로토콜은 요청이 들어오면 이에 맞는 응답을 보낸 후 바로 연결을 종료한다. 비연결 방식이라 아예 연결을 하지않는 것이 아니라 <strong>단지 연결을 유지하지 않는다는 뜻</strong>이다.</li>
<li>소켓 방식에 비해 상대적으로 데이터를 주고 받는 속도에 제약이 있지만, 네트워크 대역 소모를 줄일 수 있고, 서버 부하도 낮출 수 있어서 모바일 서비스에 많이 사용된다.</li>
<li>웹 서비스 : 웹페이지와 달리, 데이터만 주고받을 수 있도록 설계된 모듈
<ol>
<li><strong>SOAP (Simple Object Access Protocol) 방식</strong>
<ul>
<li>HTTP / HTTPS / SMTP 등의 프로토콜을 통해 양쪽에서 XML 형태의 메세지를 주고 받도록 구현된 프로토콜</li>
<li>RPC (Remote Procedure Call) 이라고 불리는 클리아언트-서버 구조의 메세지 패턴을 주로 사용한다.</li>
<li>Envelope / Header / Body 의 세가지 영역으로 구분된다.
<ul>
<li>Header : 반복이나 보안 및 트랜젝션을 정보로 하는 메타 정보를 처리한다.</li>
<li>XML을 근간으로 하여 헤더 부분과 바디 부분을 조합하는 구조의 디자인 패턴으로 설계되어 있다</li>
</ul>
</li>
<li>SOAP 방식의 장점
<ol>
<li>HTTP는 기존 원격 기술들과 달리 프락시나 방화벽과 관계없이 쉽게 통신할 수 있다.</li>
<li>HTTP이외에도 사용할 수 있는 프로토콜이 다양하다.</li>
<li>플랫폼 독립적인 통신으로 시스템이 바뀌거나 이기종 플랫폼 간의 데이터 통신이 편리하다</li>
<li>프로그래밍 언어에 종속되지 않는다.</li>
<li>매우 간단하고 확장이 용이하다</li>
</ol>
</li>
<li>SOAP 방식의 단점
<ul>
<li>CORBA 같은 미들웨어 기술과 비교하여 상대적으로 느리다.</li>
</ul>
</li>
</ul>
</li>
<li><strong>RESTful (Representational State Transfer)</strong> 방식
<ul>
<li>자원을 정의하고 자원에 대한 주소를 관리하는 방법, REST원리에 따라 구현된 시스템</li>
<li>REST란 웹 형식을 빌려 데이터를 전송하되, SOAP나 쿠키 등 별도의 전송 프로토콜 없이 전송하기 위해 만들어진 간단한 형식의 인터페이스</li>
<li>데이터를 요청하는 <strong>URI</strong> 를 네트워크를 통해 서버로 전달 -&gt; 서버에서는 그에 맞는 응답 데이터가 전송된다.</li>
<li>참고
<ul>
<li>URI (Uniform Resource Identifier) : 인터넷에 있는 자원을 나타내는 유일한 주소. 어떤 계층의 어떤 데이터라는 정보를 알려준다.</li>
<li>URL (Uniform Resource Locator) : URI의 하위 개념으로 , 네트워크 상에서 자원이 어디 있는지를 알려주기 위한 규약</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<br>
<h3><span id="restful-api-amp-http-jeonsong-bangsig">RESTful API &amp; HTTP 전송 방식</span></h3>
<hr>
<ul>
<li>일반적으로 웹에서 사용되는 HTTP 메서드의 종류는 <u>GET 과 POST</u> 두 가지 이다.
<ul>
<li>데이터를 요청시에는 GET , 데이터를 전송하려면 POST를 주로 사용한다.</li>
</ul>
</li>
</ul>
<ul>
<li>GET 방식으로 데이터 전송도 가능하지만, URL뒤에 데이터를 줄줄이 붙여서 전송하므로 URL이 복잡해지고 보안에 취약하다.<br>
<img src="restfulMethod.png" alt="restful메서드"></li>
<li>위 메서드를 URI헤더에 사용하여 처리할 액션을 구분할 수 있다.</li>
</ul>
<br>
<h4><span id="http">HTTP</span></h4>
<hr>
<p>웹 브라우저에서 서버로 보내는 모든 요청은 <strong><em>HTTP 메세지</em></strong> 형태로 전송된다. 서버는 메세지를 분석하여 원하는 바를 파악하고, 그에 맞는 처리를 한 다음에 응답 내용을 HTTP 메세지로 만들어 전송한다. 따라서 메세지를 만들고 변환하는 과정은 브라우저의 역활이다.</p>
<p>하지만 iOS 앱이 서버와 연동하기 위해서는 서버에 요청할 HTTP 메세지를 직접 만들어서 전송해 주어야 한다.</p>
<p><img src="http_message.png" alt="http_message"></p>
<ul>
<li>
<p>HTTP 메세지 구조</p>
<ul>
<li>POST<br>
<img src="HTTP_POST.png" alt="HTTP_POST"><br>
수동으로 HTTP 메세지 작성을 하는 경우에는 URLEncoding 처리를 반드시 해주어야 한다.<br>
​</li>
<li>GET<br>
<img src="HTTP_GET.png" alt="HTTP_GET"></li>
</ul>
</li>
<li>
<p>HTTP 패킷<br>
클라이언트가 서버로 요청했을 때, 보내는 데이터를 HTTP 패킷이라고 한다.<br>
패킷의 구조는 <strong>헤더</strong>와 <strong>바디</strong>로 나누어진다.<br>
헤더에는 HTTP 메서드 / 클라이언트의 정보 / 브라우저 정보 / 접속할 URL 등 과 같은 클라이 언트 정보를 담는다.<br>
바디는 보통 비어있으나, 특정 데이터를 담아서 서버에 요청할 수도 있다.</p>
</li>
<li>
<p>헤더 필드 중 컨텐츠 타입</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//GET방식과 마찬가지로 BODY에 key 와 value 쌍으로 데이터를 넣는다. 똑같이 구분자 &amp;를 쓴다.</span></span><br><span class="line">application/x-www-<span class="keyword">form</span>-urlencoded</span><br><span class="line"></span><br><span class="line"><span class="comment">//BODY에 단순 txt를 넣는다.</span></span><br><span class="line">text/plain</span><br><span class="line"></span><br><span class="line"><span class="comment">//파일전송을 할때 많이 쓰는데 BODY의 데이터를 바이너리 데이터로 넣는다는걸 알려준다.</span></span><br><span class="line">multipart/<span class="keyword">form</span>-data</span><br></pre></td></tr></table></figure>
<p>​</p>
</li>
</ul>
<br>
<h3><span id="get">GET</span></h3>
<hr>
<ul>
<li>
<p>요청하는 데이터르 URL 뒤에 붙여서 보낸다.  (데이터는 key와 value 쌍으로 요청해야 한다.)</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">www.example.com?<span class="attribute">id</span>=mommoo&amp;pass=1234</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>패킷의 헤더에 포함되어 서버에 요청한다. (따라서 바디에는 빈상태로 전송된다.)</p>
</li>
<li>
<p>따라서 간단한 데이터 밖에 넣을 수 없다. (전송 데이터량의 한계)</p>
</li>
<li>
<p>URL에 데이터가 표시되어  POST보다 보안에 더 취약하다.</p>
</li>
</ul>
<br>
<h3><span id="post">POST</span></h3>
<hr>
<ul>
<li>데이터 전송을 기반으로 한 요청 메서드</li>
<li>GET 방식과는 다르게 <strong><em>데이터를 바디에 넣어 전송</em></strong>한다. (단 ,  헤더 필드에 컨텐츠 타입을 꼭 명시해주어야 한다.)</li>
<li>데이터가 URL에 표시되지 않더라도 보안에는 취약하므로 암호화 해야한다.</li>
</ul>
<br>
<h3><span id="xml-bangsig">XML 방식</span></h3>
<hr>
<ul>
<li>SOAP 방식과 RESTful API 모두 XML 방식으로 결과를 제공할 수 있다.</li>
<li>HTML의 한계를 극복학 목적으로 W3C에서 특수 목적의 마크업 언어, 태그라고 불리는 마크업과 내용으로 구성된다.</li>
<li>XML은 태그로 구성된 마크업 형식을 기본 규격으로 사용하므로 <em>플랫폼에 의존적이지 않은 표준 데이터</em>를 제공할 수 있다.</li>
<li>단, 데이터의 의미를 전달하기 위해 마크업 태그를 사용하므로 <strong>주고받아야 할 전체 데이터 용량이 지나치게 커진다는 단점</strong>이 있다.</li>
</ul>
<br>
<h3><span id="json-bangsig">JSON 방식</span></h3>
<hr>
<ul>
<li><strong>JSON (JavaScript Object Notation)</strong> : 자바스크립트 언어에서 객체의 속성을 표현하기 위한 방법으로 처음 사용하기 시작했다.</li>
<li>XML의 단점을 극복하기 위해 만들어진 <em>경량의 데이터 교환 형식</em></li>
<li>복잡한 데이터 구조를 그룹으로 묶어 계층화 할 수 있다는 장점이 있다.</li>
<li>데이터구조는 <strong>JSON객체, JSON배열</strong> 두 종류가 있다.
<ol>
<li>JSON 객체
<ul>
<li><code>{ key : value}</code> 형태로 이루어진 사전(Dictionary)식 데이터 집합이다. 문자열은 <em>더블 쿼우팅(Quoting: “”)</em> 으로 처리해 준다.</li>
<li>여러 속성을 정의하는 <strong><em>순서없는 집합</em></strong></li>
</ul>
</li>
<li>JSON 배열
<ul>
<li><code>[ 객체1, 객체2, 객체3 ...]</code>형태로 이루어져 있으며 JSON객체나, JSON배열 자체를 나열할 수 도 있다.</li>
<li>비슷한 객체가 반복 나열되는 <strong><em>순서화된 리스트</em></strong></li>
</ul>
</li>
</ol>
</li>
</ul>
<br>
<h3><span id="api">API</span></h3>
<hr>
<ul>
<li><strong>오픈 API</strong> : SOAP 프로토콜이나 RESTful 형식을 사용하여 공공 콘텐츠를 제공하는 것.</li>
<li>Request URI : API를 호출하기 위한 네트워크상의 주소<br>
<code>기본URL ? key={조건}&amp;key2={조건2}</code> 의 형식으로 작성하여 Request (요청)한다.</li>
</ul>
<br>
<h4><span id="code-yeonghwa-apiro-deiteo-gajyeoogi">CODE :: 영화 API로 데이터 가져오기</span></h4>
<hr>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 요청 URI http://www.kobis.or.kr/kobisopenapi/webservice/rest/boxoffice/searchDailyBoxOfficeList.json?key="키값"&amp;targetDt=20171116</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> url = <span class="string">"http://www.kobis.or.kr/kobisopenapi/webservice/rest/boxoffice/searchDailyBoxOfficeList.json?key="</span>키값<span class="string">"&amp;targetDt=20171116"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//URL 형식으로 변환</span></span><br><span class="line"><span class="keyword">let</span> apiURI : <span class="type">URL</span>! = <span class="type">URL</span>(string: url)</span><br><span class="line">        </span><br><span class="line"><span class="comment">//REST API 호출</span></span><br><span class="line"><span class="keyword">let</span> apiData = <span class="keyword">try</span>! <span class="type">Data</span>(contentsOf: apiURI) </span><br><span class="line"></span><br><span class="line"><span class="comment">//log 찍기</span></span><br><span class="line"><span class="comment">//let log = NSString(data: apiData, encoding: String.Encoding.utf8.rawValue) ?? ""</span></span><br><span class="line"><span class="comment">//NSLog("result = \(log)")</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><code>Data(:)</code> 는 기존 <code>NSData</code> 객체를 참조하여 만들어진 객체이다. 따라서 서로간의 타입 캐스팅도 가능하며,  캐스팅 시 nil을 반환하지 않는다.</p>
</li>
<li>
<p><code>App Transport Security has blocked a cleartext HTTP (http://) resource load since it is insecure.</code></p>
<ul>
<li>iOS9부터 외부 네트워크 관련된 <strong>ATS</strong> (App Transport Security) 라는 보안 규칙이 신설되었다. SSL 보안 프로토콜을 사용하지 않는 네트워크에 접속하려면 <strong>info,plist</strong> 파일에서 특정 설정을 추가로 해주어야 한다. 이때 발생된 에러는 https 가 아닌 보안이 적용되어 있지 않은 http 이기 때문에 발생된 에러 이다.</li>
</ul>
</li>
</ul>
<ul>
<li>
<p>설정 : [OpenAs] -&gt; [Source Code] 에서 아래 코드를 추가해준다.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;key&gt;<span class="type">NSAppTransportSecurity</span>&lt;/key&gt;</span><br><span class="line">&lt;dict&gt;</span><br><span class="line">    &lt;key&gt;<span class="type">NSAllowsArbitraryLoads</span>&lt;/key&gt;</span><br><span class="line">    &lt;<span class="literal">true</span>/&gt;</span><br><span class="line">&lt;/dict&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<br>
<h4><span id="code-pasinghagi">CODE :: 파싱하기</span></h4>
<hr>
<ul>
<li>가져온 데이터는 <code>Data 타입</code> 으로 바로 꺼내쓰기 어렵기 때문에 <code>NSDictionary</code> or <code>NSArray</code> 타입으로 변환시켜주어야 한다.</li>
<li>파운데이션 프레임워크에서 제공하는 <code>JSONSerialization</code> 객체의 <code>.jsonObject()</code>메서드를 사용하여 파싱한다.</li>
<li>화면이 로드될때 데이터를 불러오기 적합하므로 viewDidLoad 에 구현해준다.</li>
<li><code>jsonObject()</code> 메서드는 파싱과정에서 오류가 발생하면 예외로 던지도록 설계되어 있기 때문에 <code>do ~ try ~ catch</code> 구문으로 감싸주어야 한다.</li>
<li>데이터 구조에 따라서 <strong>알맞는 데이터 구조로 타입캐스팅</strong>을 해주며 읽어온다.</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> url = <span class="string">"http://www.kobis.or.kr/kobisopenapi/webservice/rest/boxoffice/searchDailyBoxOfficeList.json?key=460956405726841da1ef0286a0945b34&amp;targetDt=20171116"</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//URL 형식으로 변환</span></span><br><span class="line">    <span class="keyword">let</span> apiURI : <span class="type">URL</span>! = <span class="type">URL</span>(string: url)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//REST API 호출</span></span><br><span class="line">    <span class="keyword">let</span> apiData = <span class="keyword">try</span>! <span class="type">Data</span>(contentsOf: apiURI)</span><br><span class="line">    </span><br><span class="line">  	<span class="comment">//log 찍기</span></span><br><span class="line">    <span class="comment">//let log = NSString(data: apiData, encoding: String.Encoding.utf8.rawValue) ?? ""</span></span><br><span class="line">    <span class="comment">//NSLog("result = \(log)")</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> apiDictionary = <span class="keyword">try</span> <span class="type">JSONSerialization</span>.jsonObject(with: apiData, options: []) <span class="keyword">as</span>! <span class="type">NSDictionary</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//데이터 구조에 따라 차례대로 캐스팅하며 읽어온다</span></span><br><span class="line">        <span class="keyword">let</span> result = apiDictionary[<span class="string">"boxOfficeResult"</span>] <span class="keyword">as</span>! <span class="type">NSDictionary</span></span><br><span class="line">        <span class="keyword">let</span> movies = result[<span class="string">"dailyBoxOfficeList"</span>] <span class="keyword">as</span>! <span class="type">NSArray</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> movies &#123;</span><br><span class="line">            <span class="keyword">let</span> info = row <span class="keyword">as</span>! <span class="type">NSDictionary</span></span><br><span class="line">            <span class="keyword">let</span> infoResult = dataObject(data: info)</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"영화제목 : <span class="subst">\(infoResult.movieName)</span> , 영화랭킹: <span class="subst">\(infoResult.rank)</span> , 영화상영수 : <span class="subst">\(infoResult.showCnt)</span>"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">catch</span>&#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"parsing error"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Technology </category>
            
        </categories>
        
        
        <tags>
            
            <tag> RESEful </tag>
            
            <tag> API </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[TableView]]></title>
      <url>/2017/11/27/iOS-tableview/</url>
      <content type="html"><![CDATA[<h1><span id="tableview">TableView</span></h1>
<h2><span id="teibeulbyu">테이블뷰</span></h2>
<hr>
<ul>
<li>UIKit 프레임워크에 UITableViewController 클래스로 구현되어 있다.</li>
<li>테이블뷰<strong>컨트롤러</strong> &gt; <strong>테이블뷰</strong> &gt; 여러개의 테이블뷰 <strong>섹션</strong> &gt; 테이블뷰 <strong>셀</strong> &gt; <strong>컨텐츠 뷰</strong></li>
</ul>
<br>
<h3><span id="peurototaib-sel">프로토타입 셀</span></h3>
<hr>
<ul>
<li>테이블 뷰의 셀을 원하는 대로 쉽게 디자인할 수 있도록 해주는 객체. Cell content 부분과 Accessory view부분으로 나뉜다.</li>
</ul>
<ul>
<li>프로토타입 셀은 실제로 화면에 표시되는 컨트롤이 아니기 때문에 소스에서 <strong><em>Cell identity</em></strong> 를 통해 참조가 이루어진다.</li>
<li>배열 형태의 데이터 소스를 테이블 뷰 각 행에 연결 (Data Binding) 하면 동적생성이 가능하다.</li>
</ul>
<br>
<h5><span id="value-object-pattern-vo">Value Object Pattern (VO)</span></h5>
<blockquote>
<p>데이터 저장을 전담하는 클래스를 별도로 분리하는 설계 방식. 데이터저장을 위한 클래스임을 쉽게 식별하기 위해서</p>
<p>클래스 명명시 VO를 붙여주기도한다. VO class에 담기는 각종 변수들은 해당 데이터를 담는 역할을 하며,</p>
<p>클래스 인스턴스 전체가 전달되기 때문에 내부 변수에 저장된 값도 함께 전달되어 용이하다.</p>
</blockquote>
<br>
<h3><span id="require-protocol">Require Protocol</span></h3>
<h5><span id="uitableviewdatasource">UITableViewDataSource</span></h5>
<hr>
<ol>
<li>
<p><code>tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int</code></p>
<blockquote>
<p>테이블이 몇개의 행으로 구성되는가?</p>
</blockquote>
<ul>
<li>테이블 뷰가 <strong>생성해야 할 행(row)의 개수</strong> 반환</li>
<li>iOS 시스템에게 알려주기 위한 메서드 . <em>이 메서드에 의해서 행의 갯수가 결정됨</em></li>
<li>Pamameter
<ol>
<li><code>tableView</code> : 하나의 테이블뷰컨트롤러 안에 두개 이상의 테이블뷰가 존재할 경우, 프로토콜에 의해 설계되어 모두 같은 메서드를 호출하게 된다. 이때 <strong><em>어떤 테이블 뷰에서 자신을 호출하는지</em></strong>를 알려주기 위한 파라미터</li>
<li><code>section</code> : 섹션에 대한 정보. 각 섹션마다 갖고있는 행의 수를 다르게 하기 위해서 설정해 준다.</li>
</ol>
</li>
</ul>
</li>
<li>
<p><code>func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell</code></p>
<blockquote>
<p>각 행의 내용은 어떻게 구성되는가?</p>
</blockquote>
<ul>
<li>각 행이 화면에 표현해야 할 내용을 구성하는 데 사용된다. 화면에 표현해야 할 목록의 수만큼 이 메서드가 반복적으로 호출된다.</li>
<li>이 함수에서 재사용 셀을 생성하는 구문을 넣어준다.</li>
<li>Pamameter
<ol>
<li><code>tableView</code> : 구성하고자하는 테이블뷰</li>
<li><code>IndexPath</code>  :  선택된 행에 대한 관련 속성들을 제공. <code>.row</code> 를 통해서 행의 번호를 알 수 있다.</li>
</ol>
</li>
</ul>
</li>
</ol>
<br>
<h3><span id="delegate">Delegate</span></h3>
<h5><span id="uitableviewdelegate-optional">UITableViewDelegate / optional</span></h5>
<hr>
<p>func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath)`</p>
<ul>
<li>사용자가 목록 중 <strong><em>특정 행을 선택했을 때</em></strong> 호출된다.</li>
<li>화면이동 및 상세 내용을 팝업으로 보여주는 등 다양한 기능구현가능</li>
</ul>
<br>
<h3><span id="reusablecell">ReusableCell</span></h3>
<hr>
<ul>
<li><strong><em>재사용 큐(Queue)</em></strong> 란, iOS에서는 기기의 메모리와 배터리를 절약하기 위해서 데이터만큼의 셀을 만들어 놓지 않는다.<br>
대신 화면에 표시되어야할 만큼만 셀을 만들어 놓고, 필요에 따라 셀을 그때그때 추가한다.<br>
매번 새로운 셀을 생성하면 메모리적으로 부담이 되기 때문에, 샐 객체를 저장해두는 공간을 만들어 놓고 필요할때 꺼내어 사용하게 된다. 필요 없어진 셀 객체는 여기에 다시 저장되게 된다.</li>
<li><code>.dequeueReusableCell(withIdentifier: &quot;customCell&quot;, for: indexPath)</code>
<ul>
<li>이 메서드를 입력받은 아이디(<code>withIdentifier</code>)를 이용하여 스토리보드에 정의된 <strong>프로토타입 셀</strong>을 찾고, 이를 인스턴스로 생성하여 제공한다.</li>
<li>만약 입력된 아이디에 맞는 인스턴스 큐가 없다면 새로 생성하여 제공하는 방식으로 동작한다.</li>
</ul>
</li>
<li><strong>재사용 메커니즘</strong>
<ol>
<li>테이블 뷰가 화면에 나타낼 셀 객체를 자신의 데이터 소스에게 요청</li>
<li>데이터 소스는 테이블 뷰의 재사용 큐 (ReUse Queue)에서 사용 가능한 셀이 있는지 확인하여 만일 있다면 그중 하나를 꺼내 전달하고 , 없으면 새로운 셀 생성</li>
<li><code>tableView(_:cellForRowAt:)</code> 메서드가 셀의 콘텐츠를 구성한 다음 반환하면 테이블 뷰는 이 셀을 받아 화면에 표시한다. <em>(단, 셀이 화면에 표시되기 위해서는 위 메서드를 거쳐야 하므로 해당 메서드는 셀 갯수 만큼 호출된다.)</em></li>
<li>사용자가 테이블 뷰를 스크롤함에 따라 화면을 벗어난 셀은 테이블 뷰에서 제거되지만 완전히 삭제하는 것이 아니라 재사용 큐에 추가된다.</li>
<li><code>1~4</code> 과정 반복!</li>
</ol>
</li>
</ul>
<br>
<h3><span id="self-sizing-cell">Self-Sizing Cell</span></h3>
<hr>
<ol>
<li>
<p><code>func tableView(_ tableView: UITableView, estimatedHeightForRowAt indexPath: IndexPath) -&gt; CGFloat</code></p>
<ul>
<li>
<p>행에 대한 인자를 받고 , 그 행의 높이를 얼마로 해줄지 계산하여 반환하는 메서드</p>
</li>
<li>
<p>Ex.) CGFloat 타입의 리턴값을 사용하므로, 타입캐스팅을 해주고 기본값 160높이로 지정 후 데이타의 글자수가 30을 넘을 때마다 20씩 늘려준다.</p>
<p>​</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> row = <span class="keyword">self</span>.listData[indexPath.row]  </span><br><span class="line"><span class="keyword">let</span> height = <span class="type">CGFloat</span>(<span class="number">160</span> + (row.description.<span class="built_in">count</span> / <span class="number">30</span>) * <span class="number">20</span>)</span><br><span class="line"><span class="keyword">return</span> height</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>이때 행의 높이는 늘어났으나 [ ……] 으로 텍스트가 짤리는 경우가 생기는데, 텍스트 레이블의 행 수가 default값인 1로 지정되어 한줄로밖에 표현안되기 때문이다. <code>cell.textLable?numberOfLines = 0</code> 으로 설정해주면 라인 제한이 없어진다.</p>
</li>
</ul>
</li>
</ol>
<ol>
<li>
<p>위 방법 대신 간단한 코드로 셀프사이징 셀을 구현할 수 있다.</p>
<ul>
<li>
<p><code>estimatedRowHeight</code> 프로퍼티 : 셀 전체의 임의 높이값을 설정해 준다.</p>
</li>
<li>
<p><code>UITableViewAutomaticDimension</code> 객체 : rowHeight 속성에 대입되어 높이값이 동적으로 설정될 것을 테이블 뷰에 알려주는 역할을 한다.</p>
</li>
<li>
<p><code>viewDidLoad()</code> 는 아직 뷰가 화면에 구현되기 전 시점이므로 적절하지 않으며, 뷰를 그려줄때 호출되는 <code>viewWillAppear(_:)</code> 에 구현해 주는것이 적합하다.</p>
</li>
<li>
<p>해당 방법을 쓰면 위 <code>tableView(_:estimatedHeightForRowAt:)</code> 메서드는 삭제해준다.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.tableView.estimatedRowHeight = <span class="number">160</span></span><br><span class="line"><span class="keyword">self</span>.tableView.rowHeight = <span class="type">UITableViewAutomaticDimension</span></span><br></pre></td></tr></table></figure>
<p>​</p>
</li>
</ul>
</li>
</ol>
<br>
<h5><span id="camgo-ios-peurogeuraeming-weoncig">참고 :: iOS 프로그래밍 원칙</span></h5>
<hr>
<ol>
<li>반복적으로 호출되는 메서드의 내부에는 네트워크 통신 등 처리 시간이 긴 로직을 포함하지 않아야 한다.</li>
<li>네트워크 통신을 통해 읽어온 데이터는 재사용할 수 있도록 캐싱(Cashing) 처리하여 될 수 있으면 네트워크 통신 횟수를 줄이는 것이 좋습니다.</li>
<li>네트워크 통신이나 시간이 오래 걸리는 코드를 사용할 때는 비동기(Asynchronize) 로 처리하는 것이 바람직하다.</li>
</ol>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> tableview </tag>
            
            <tag> cell </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Deletage Pattern]]></title>
      <url>/2017/11/26/iOS-Delegate/</url>
      <content type="html"><![CDATA[<h1><span id="delegate-pattern">Delegate Pattern</span></h1>
<h2><span id="delrigeiteu-paeteon">델리게이트 패턴</span></h2>
<br>
<h3><span id="design-pattern">Design Pattern</span></h3>
<hr>
<ul>
<li>크리스토퍼 알렉산더가 고안한 것을 시초로 컴퓨터 프로그래밍에서 다양한 설계 문제를 합리적으로 해결하기 위한 목적으로 쓰인다.</li>
<li>대표적 디자인 패턴
<ul>
<li>팩토리 패턴</li>
<li>옵저버 패턴</li>
<li>데코레이터 패턴</li>
<li>싱글톤 패턴</li>
<li>어댑터 패턴</li>
<li>이터레이터 패턴</li>
<li>델리게이트 패턴</li>
<li>그외 GoF(Gang of Foour) 선대 개발자들이 정의한 패턴들</li>
</ul>
</li>
</ul>
<br>
<h3><span id="delrigeiteu-paeteon">델리게이트 패턴</span></h3>
<hr>
<ul>
<li>객체 지향 프로그로그래밍에서 하나의 객체가 모든 일을 처리하는 것이 아니라 처리해야할 일 중 일부를 다른 객체에게 넘기는 것을 말한다. 이를 위임(delegate)한다고 하며, 효율성 관점에서 아주 중요한 역할을 한다.</li>
<li>기능을 위임할 수 있는 객체가 있다는 것은 그만큼 직접 구현해야 하는 부분이 적어지기 때문에 큰 규모의 프로그램을 빠르게 작성할 수 있다.</li>
<li>iOS 프로그래밍의 전반적으로 쓰이는 중요한 방법이다.</li>
<li>주로 이벤트를 감지하고 알려주는 역할을 하며 , 델리게이트에 의해 위임된 본래의 객체로 전달해주는 역할을 한다.</li>
<li>예 ) 웹뷰에서 이벤트를 캐치하는 (뷰가 로드될때, 뷰로드가 완료되었을때 등…) 메서드가 있는데 <em>웹뷰가 특정 시점을 알려줄</em> -&gt; 뷰 컨트롤러를 <strong>델리게이트로 위임</strong> 한다. <em>( 이때 뷰 컨트롤러가 웹뷰의 델리게이트 객체로 지정되었다고 한다. )</em></li>
<li>프로토콜 이름은 항상 <strong>객체의 클래스명 + Delegate</strong>로 이루어 진다. (ex, <code>UITextFieldDelegate</code>)</li>
<li>웹뷰가 자신의 델리게이트 객체에게 이벤트가 발생했음을 알려줄 때는 <strong>델리게이트 메서드</strong>를 이용한다.</li>
</ul>
<br>
<h5><span id="logic">Logic</span></h5>
<hr>
<ol>
<li>뷰컨트롤러에서  -&gt; 웹뷰에 대한 델리게이트 프로토콜을 구현한다.
<ul>
<li>클래스명 뒤에 해당 프로토콜을 준수한다고 선언한다.</li>
<li>프로토콜에 정의된 메서드를 실질적으로 정의한다. <em>단, @optional 키워드가 붙은 메서드는 선택적구현</em></li>
</ul>
</li>
<li>웹뷰의 델리게이트 속성을 뷰컨트롤러에 연결한다 (<code>웹뷰.delegate = self</code>)
<ul>
<li>특정 이벤트가 발생하면 웹뷰는 이를 알려 주기 위해 델리게이트 메서드가 구현되어 있는 객체를 찾게 되는데, 이를 위한 참조 포인터가 저장되는 곳이 delegate 속성이다.</li>
<li>Delegate 속성에 저장된 인스턴스는 델리게이트 메서드를 구현한 것으로 인식하고 <u>필요한 델리게이트 메서드를 호출</u>한다.</li>
</ul>
</li>
</ol>
<br>
<h5><span id="camjo"># 참조</span></h5>
<hr>
<p><strong>최초 응답자 (First Responder)</strong></p>
<ul>
<li>
<p>iOS에서 모바일 기기의 디스플레이에 앱 컨텐츠를 표현하기 위해 사용하는 <code>UIWindow</code>객체는 사용자로부터 발생하는 터치 관련 이벤트를 내부 객체로 전달하는 역할을 담당한다. 이를 위해 <code>UIWindow</code> 는 이벤트가 발생했을 때 우선적으로 응답할 객체를 가리키는 <strong>최초 응답자</strong>라는 포인터를 가지고 있다. 모바일 기기에서 발생하는 모션 이벤트는 <em>모두 최초 응답자 포인터에 연결된 객체로</em> 전달된다.</p>
</li>
<li>
<p>예시로 텍스트필드나 텍스트뷰가 최초응답자 객체가 되면, iOS에서 제공하는 가상 키보드가화면에 나타나 입력 가능한 상태가 된다. 만약 이들 객체가 <em>최초 응답자 상태를 잃게 되면</em> 키보드는 다시 사라진다. (Focus와 비슷한 개념)</p>
</li>
<li>
<p>대부분의 뷰들은 최초 응답자가 되기를 허용하지 않는다. ( 현재 선택된 텍스트 필드나 텍스트 뷰로 부터 포커스를 뺏고싶지 않기 때문에…)</p>
</li>
<li>
<p>화면에 키보드가 표시된 상태에서 다른 요소를 클릭해도 키보드가 사라지지 않는 것은 다른 요소를 터치하더라도 그 객체가 <code>UIResponder</code> 를 상속받지 않았다면 터치 이벤트만 발생할 뿐, <u>최초 응답자 포인터는 그대로 텍스트 필드를 가리키고 있기 때문</u>이다.</p>
</li>
<li>
<p>따라서 객체로 부터 최초 응답자 상태를 해제하고 싶을 때는 <code>resignFirstResponder()</code> 메서드를 호출하면 된다.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> tf = <span class="type">UITextField</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">//최초 응답자 객체로 지정</span></span><br><span class="line"><span class="comment">//대신 도크바에 가운데 아이콘을 클릭해서 연결해도 최초 응답자로 지정된다.</span></span><br><span class="line">tf.becomeFirtstResponder()</span><br><span class="line"></span><br><span class="line">...(필요한 코드삽입)</span><br><span class="line"></span><br><span class="line"><span class="comment">//입력이 완료되면 최초 응답자 객체를 해제한다 </span></span><br><span class="line">tf.resignFirstResponder()</span><br></pre></td></tr></table></figure>
<p>​</p>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> delegate </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS Local Push]]></title>
      <url>/2017/11/26/iOS-Localpush/</url>
      <content type="html"><![CDATA[<h1><span id="local-notification">Local Notification</span></h1>
<h2><span id="rokeol-alrim">로컬 알림</span></h2>
<hr>
<ul>
<li>앱 내부에서 만든 특정 메세지를 iOS의 알림 센터를 통해 전달하는 방법이다.</li>
<li>iOS 스케쥴러에 의해 발송되고 관리된다.</li>
<li>알림 센터에 표시된 메시지를 클릭해서 앱을 실행시키고, 원하는 기능이나 특정 화면으로 이동하게 끔 처리할 수 있다.</li>
<li><strong>앱 실행 여부와 상관없이 사용가능</strong>하기 때문에 사용자의 관심으로부터 멀어지는 상황에서 앱에 대한 주의 환기 목적으로 사용하기 적합하다.</li>
</ul>
<br>
<h3><span id="logic">Logic</span></h3>
<hr>
<ul>
<li><strong>로컬 알림 처리</strong>
<ul>
<li>iOS 10 이전버전 <code>UILocalNotification</code> 로컬알림용 객체가 사용됨</li>
<li>iOS 11 이후버전 <code>USerNotification</code> 프레임워크에 의해서 관리됨.</li>
</ul>
</li>
<li>로컬 알림 등록과정
<ol>
<li><code>UIUserNotificationSettings</code> 객체를 이용하여 미리 알림 설정 환경을 <strong>정의</strong></li>
<li>이것을 어플리 케이션 객체에 <strong>등록</strong></li>
</ol>
</li>
<li>주로 앱이 처음 실행될 때 동의를 받는 것이 가장 자연스러우므로 <code>AppDelegate</code> 의 <code>application(_:, didFinishLaunchingWithOptions:)</code> 메서드 내에서 구현한다</li>
<li><code>UILocalNotification</code> 객체를 생성후 설정해야할 속성은 <em>발송시각/타임존/메시지/버튼명/배지/사운드/사용자 정의 데이터</em> 등이 있다.</li>
</ul>
<br>
<h4><span id="code-alrim-deungroghagi-for-ios-10-iha">CODE :: 알림 등록하기 (for iOS 10 이하)</span></h4>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 앱이 처음 실행될때 런치 스크린이 표시되고 있는 동안 호출되는 메서드</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">application</span><span class="params">(<span class="number">_</span> application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 알림 환경 설정 : 경고창, 배지, 사운드를 통해 알림을 표시해도 되는지 사용자로부터 확인을 받는다.</span></span><br><span class="line">    <span class="keyword">let</span> setting = <span class="type">UIUserNotificationSettings</span>(types: [.alert, .badge, .sound], categories: <span class="literal">nil</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 애플리케이션에 설정 저장</span></span><br><span class="line">    application.registerUserNotificationSettings(setting)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//앱이 활성화를 잃었을때 실행되는 메서드 (ex, 전화가 오거나 홈버튼을 눌러 백그라운드로 진입햇을 때)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">applicationWillResignActive</span><span class="params">(<span class="number">_</span> application: UIApplication)</span></span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//if 문으로 플랫폼 버전에 따라서 구분히여 check!!</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> #available(iOS <span class="number">11.0</span>, *) &#123;</span><br><span class="line">        <span class="comment">// 새 방식의로컬 알림 구현 코드</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 알림 설정 check</span></span><br><span class="line">        <span class="keyword">let</span> setting = application.currentUserNotificationSettings</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*  알림이 설정이 거부되면 UIUserNotificationType.none 으로 설정되어 있음</span></span><br><span class="line"><span class="comment">         알림 설정이 되어 있지 않다면 로컬 알림을 보내도 받을 수 없으므로 종료 */</span></span><br><span class="line">        <span class="keyword">guard</span> setting?.types != .<span class="keyword">none</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"can't Schedule"</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 로컬 알람 인스턴스 생성</span></span><br><span class="line">        <span class="keyword">let</span> noti = <span class="type">UILocalNotification</span>()</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//noti.fireDate = Data(timeIntervalSinceNow :10) //10초후 발송, 메서드 사라짐</span></span><br><span class="line">        noti.timeZone = <span class="type">TimeZone</span>.autoupdatingCurrent    <span class="comment">// 현재위치에 따라 타임존 설정</span></span><br><span class="line">        noti.alertBody = <span class="string">"어서 다시 접속하세요!!"</span>    <span class="comment">//표시될 메세지</span></span><br><span class="line">        noti.alertAction = <span class="string">"접속하기"</span>   <span class="comment">//잠금상태 일때 표시될 액션</span></span><br><span class="line">        noti.applicationIconBadgeNumber = <span class="number">1</span> <span class="comment">//모서리에 표시될 배지</span></span><br><span class="line">        noti.soundName = <span class="type">UILocalNotificationDefaultSoundName</span>    <span class="comment">//로컬 알람 도착시 사운드</span></span><br><span class="line">        noti.userInfo = [<span class="string">"name"</span>:<span class="string">"정현아"</span>]  <span class="comment">//로컬 알람 실행시 함께 전달하고 싶은 값!! (화면에는 표시되지 않음)</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 생성된 알람 객체를 스케쥴러에 등록</span></span><br><span class="line">        <span class="comment">//application.scheduledLocalNotifications(noti)     //메서드 사라짐</span></span><br><span class="line">        application.presentLocalNotificationNow(noti)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>
<h4><span id="code-meseodeu-jeongri">CODE :: 메서드 정리</span></h4>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">UIApplication</span>.shared( <span class="comment">//앱 델리겡트에서는 application 매개변수)</span></span><br><span class="line">    <span class="comment">//  알림 허용 여부를 사용자에게 확인받고, 선택을 어플리케이션에 등록하는 역할</span></span><br><span class="line">    .registerUserNotificationSettings(<span class="number">_</span>:)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 현재 설정된 알림 허용 여부 정보를 읽어온다</span></span><br><span class="line">        .currentUserNotificationSettings</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 생성된 알림 객체를 iOS 스케쥴러에 등록한다. 등록된 알림 객체는 fireDate 속성에 설정된 시간에 맞게 발송된다 (iOS 10)</span></span><br><span class="line">        .scheduleLocalNotification(<span class="number">_</span>:)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 생성된 알림 객체의 fireDate 속성을무시하고 즉각 발송한다</span></span><br><span class="line">        .presentLocalNotificationNow(<span class="number">_</span>:)</span><br></pre></td></tr></table></figure>
<br>
<h4><span id="code-badeun-alrim-ceorihagi">CODE :: 받은 알림 처리하기</span></h4>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/*  알림이 도착한다면 활성화/비활성화 상태와 관계업싱 해당 메서드가 실행된다.</span></span><br><span class="line"><span class="comment">     따라서 활성화/비활성화 상태에 따라서 로직을 처리해주어야한다. */</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">application</span><span class="params">(<span class="number">_</span> application: UIApplication, didReceive notification: UILocalNotification)</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>((notification.userInfo?[<span class="string">"name"</span>])!)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> application.applicationState == <span class="type">UIApplicationState</span>.active &#123;</span><br><span class="line">            <span class="comment">//앱이 활성화 된 상태일 때 실행할 로직</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> application.applicationState == .inactive &#123;</span><br><span class="line">            <span class="comment">//앱이 비활성화된 상태일 때 실행할 로직</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>
<h3><span id="usernotifications-peureimweokeureul-iyonghan-rokeolalrim">UserNotifications 프레임워크를 이용한 로컬알림</span></h3>
<hr>
<ul>
<li><code>UserNotifications</code> 는 <u>사용자 알림을 처리하기위해 iOS 10부터 새롭게 도입된 알림 전용 프레임워크.</u> 알림을 위해 필요한 여러 가지 객체를 포함하고 있으며 User &amp; Notificaiton의 철자를 따서 <strong>UN</strong>으로 객체명을 정의했다.</li>
<li>프레임 워크기 때문에 <code>import</code> 해주어야 한다.</li>
<li>기존 <code>UILocalNotification</code> 객체를 통해 정의했던 각종 속성들은 <strong><em>알림컨텐츠, 알림 발송조건, 알림 요청</em></strong> 세가지 객체로 분화되었다.</li>
<li>주요 객체
<ul>
<li><code>UNMutableNotificationContent</code>
<ul>
<li><strong><em>알림에 필요한 메세지와 같은 기본적인 속성을 담는 알림 컨텐츠 역활</em></strong>을 한다. 이 객체를 통해 로컬 알림 타이틀, 서브 타이틀 및 알림 메세지를 설정할 수 있으며 앱 아이콘에 표시될 배지나 사운드 설정도 모두 이 객체를 통해 설정가능하다.</li>
<li>비슷한 객체로 <code>UNNotificationContent</code> 가 있는데, 이 객체는 수정이 불가능하며 객체로 부터 속성을 읽어 들일 수만 있는 특성을 가진다.</li>
</ul>
</li>
<li><code>UNTimeIntervalNotificationTrigger</code>
<ul>
<li>알림 발송조건을 관리하며 <strong>발생시각</strong> 과 <strong>반복여부</strong> 를 설정할 수 있다.</li>
<li><code>Data()</code> 타입을 통해 발송 시각을 설정했던 것과 달리 새로운 방식에서는 시간 간격을 사용하여 발송하며 단위는 sec(초) 이다.</li>
<li>하루 중 특정 시간에 맞추어 알림 메세지를 전송하고 싶다면 <code>UNCalendarNotificationTrigger</code> 객체를 사용하면 된다.</li>
</ul>
</li>
<li><code>UNNotificationRequest</code>
<ul>
<li>알림 컨텐츠 + 알림 조건이 준비되면 <strong>알림 요청 객체</strong> 를 생성 한다.</li>
<li>두 인자값으로 초기화를 하면 그 결과로 알림 요청 객체가 생성된다.</li>
</ul>
</li>
<li><code>UNUserNotificationCenter</code>
<ul>
<li>기존 방식에서 스케쥴러의 역활을 대신 한다.</li>
<li>@기존방식 : application scheduler 가 iOS의 스케줄러에 필요한 알림 내용을 등록해두면 iOS가 이를 인식하고 발송하는 방식</li>
<li>Singleton 방식으로 인스턴스를 생성하지 않고 <code>current()</code> <em>메서드를 통해 참조 정보</em>만 가져올 수 있다.  --&gt; <code>add(_:)</code> 메서드를 사용해서 앞에서 생성한 알림 요청 객체를 추가해주면 알림 등록 과정이 완료된다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4><span id="code">CODE</span></h4>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> #available(iOS <span class="number">10.0</span>, *) &#123; </span><br><span class="line">	<span class="comment">// 새 방식의로컬 알림 구현 코드</span></span><br><span class="line">    <span class="comment">// 1. 알림허용상태인지 check</span></span><br><span class="line">    <span class="keyword">let</span> settiing = application.currentUserNotificationSettings</span><br><span class="line">    <span class="keyword">guard</span> setting?.types != .<span class="keyword">none</span> <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"can't Schedule"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 알림 컨텐츠 객체생성</span></span><br><span class="line">    <span class="keyword">let</span> nContent = <span class="type">UNMutableNotificationContent</span>()</span><br><span class="line">    </span><br><span class="line">    nContent.badge = <span class="number">1</span></span><br><span class="line">    nContent.body = <span class="string">"지금 접속하세요!!"</span></span><br><span class="line">    nContent.title = <span class="string">"50% 할인쿠폰"</span></span><br><span class="line">    nContent.subtitle = <span class="string">"지금접속"</span></span><br><span class="line">    nContent.sound = <span class="type">UNNotificationSound</span>.<span class="keyword">default</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 알림 발송 조건 객체</span></span><br><span class="line">    <span class="comment">// 시간간격 : 5초 , 반복X</span></span><br><span class="line">    <span class="keyword">let</span> trigger = <span class="type">UNTimeIntervalNotificationTrigger</span>(timeInterval: <span class="number">5</span>, repeats: <span class="literal">false</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. 알림 요청 객체생성 ( 알림이름 , 컨텐츠객체 , 타임트리거 객체)</span></span><br><span class="line">	<span class="comment">// 참고) indentifier는 등록된 알람을 취소할 경우 사용된다.</span></span><br><span class="line">    <span class="keyword">let</span> request = <span class="type">UNNotificationRequest</span>(identifier: <span class="string">"coupon"</span>, content: nContent, trigger: trigger)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 5. 생성된 알림 요청 객체를 노티피케이션 센터에 추가! (알림 관리자)</span></span><br><span class="line">	<span class="comment">// 노티피케이션 센터는 iOS의 스케줄링 센터에 이 값을 등록하고 정해진 시간에 발송되도록 처리해준다.</span></span><br><span class="line">    <span class="type">UNUserNotificationCenter</span>.current().add(request)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> push </tag>
            
            <tag> alert </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS Alert]]></title>
      <url>/2017/11/25/iOS-alert/</url>
      <content type="html"><![CDATA[<h1><span id="alert-message">Alert Message</span></h1>
<h2><span id="sayongjaege-meseji-jeondalhagi">사용자에게 메세지 전달하기</span></h2>
<hr>
<ul>
<li><strong>메세지창 (알림창)</strong><br>
앱이 실행 중일 때만 동작한다</li>
<li><strong>Local Notification (로컬 푸시)</strong><br>
앱 내부에서 특정 프로세스에 의해서 등록된 메세지를 iOS가 전달하는 방식</li>
<li><strong>Server Notification (서버 푸시)</strong><br>
별도의 서버를 통해 APNs(Apple Push Notification Service) 라는 애플 고유의 메시징 시스템에게 보낸 메세지가 네트워크를 통해 전달되는 방식</li>
</ul>
<p><img src="/image/serverPush.png" alt="서버푸쉬"></p>
<br>
<h3><span id="meseji-alrimcang">메세지 알림창</span></h3>
<h5><span id="uialertcontroller">UIAlertController</span></h5>
<hr>
<p>메시지 창은 앱 실행 도중에 <strong><em>사용자에게 메세지를 전달하고 의사를 입력받기 위한 목적</em></strong>으로 제공되는 객체이며 <em>두가지</em> 형태로 제공된다.</p>
<ul>
<li>
<p><strong>알림창</strong></p>
<ol>
<li>모달(modal) 방식으로 화면에 표시되며, 따라서 사용자가 알림창에 표시된 버튼 중 어느 하나를 선택하기 전에는 다른 어떤 기능도 사용할 수 없다.</li>
<li>긍정/부정 or 허용/비허용과 같은 사용자의 선택을 입력받는 용도</li>
<li>텍스트 필드 추가 <em>가능</em></li>
<li><s>이전 버전에서 <code>UIAlertView</code> 클래스에서 담당했었다. (현재 <code>UIAlertController</code>로 통합)</s></li>
</ol>
</li>
<li>
<p><strong>액션시트</strong></p>
<ol>
<li>모달방식이 아니여서 메세지 창이 아는 다른 부분을 건드릴 수 있으며 그 것으로 인해서 창이 닫히게 된다.</li>
<li>여러개의 항목 중에서 사용자가 고를 수 있도록 할 때 사용</li>
<li>텍스트 필드 추가 <em>불가능</em></li>
<li><s>이전 버전에서 <code>UIActionSheet</code>클래스가 담당했었다.</s></li>
</ol>
<p><img src="/image/alertForm.png" alt="알림창"></p>
</li>
</ul>
<br>
<h4><span id="code">CODE</span></h4>
<hr>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Alert Property */</span></span><br><span class="line"><span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> resultAlertLable: <span class="type">UILabel</span>!</span><br><span class="line"><span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">alert</span><span class="params">(<span class="number">_</span> sender: UIButton)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 1. 컨트롤러 초기화</span></span><br><span class="line"><span class="keyword">let</span> alert = <span class="type">UIAlertController</span>(title: <span class="string">"프로그램 실행"</span>, message: <span class="string">"실행하시겠습니까?"</span>, preferredStyle: .alert)</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 2. 버튼 생성</span></span><br><span class="line"><span class="comment">// 클로져나 함수로 해당 액션이 선택되었을때 실행될 삽입 가능하다. (생략가능)</span></span><br><span class="line"><span class="keyword">let</span> cancelAcion = <span class="type">UIAlertAction</span>(title: <span class="string">"취소"</span>, style: .cancel)</span><br><span class="line"><span class="keyword">let</span> okAction = <span class="type">UIAlertAction</span>(title: <span class="string">"확인"</span>, style: .<span class="keyword">default</span>) &#123; (<span class="number">_</span>) <span class="keyword">in</span>                                                           <span class="built_in">print</span>(<span class="string">"확인버튼이 눌렸습니다."</span>)</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">let</span> absoluteAction = <span class="type">UIAlertAction</span>(title: <span class="string">"강제종료"</span>, style: .destructive) &#123; (<span class="number">_</span>) <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">self</span>.resultAlertLable.text = <span class="string">"강제종료되었습니다"</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 3. 버튼을 컨트롤러에 등록</span></span><br><span class="line">alert.addAction(cancelAcion)</span><br><span class="line">alert.addAction(okAction)</span><br><span class="line">alert.addAction(absoluteAction)</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 4. 메세지 창 실행</span></span><br><span class="line"><span class="comment">// 하나의 ViewController로 간주하기 때문에 presenting 형식으로 화면을 전환해준다. (자동으로 닫히기 때문에 dismiss 메서드는 구현할 필요X)</span></span><br><span class="line"><span class="keyword">self</span>.present(alert, animated: <span class="literal">true</span>)</span><br><span class="line">        </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>preferredStyle</strong> 의 경우 알림창이냐 액션시트냐를 결정해 주는 인자값인데, 따로 설정하지 않을 경우 액션시트가 디폴트 값으로 생성된다. <code>.alert</code> or <code>.actionSheet</code>  를 인자값으로 넣어준다.<br>
( 축<em>약형으로써 열거형 타입으로 변수나 상수가 이미 정의되어 있다면, 값을 대입할 때 열거형 객체의 이름을 생략하고 값만 선택해서 입력가능하다.</em>)</li>
<li><code>style: .destructive</code> 의 경우 중요한 내용을 변경하거나 삭제해서 되돌릴 수 없는 결정을 하는 버튼에 주로 적용된다. <em>적용된 버튼은 빨간색으로 강조된다</em>.</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ID와 PW 입력받기</span></span><br><span class="line"><span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">loginAlert</span><span class="params">(<span class="number">_</span> sender: Any)</span></span> &#123;</span><br><span class="line"><span class="keyword">let</span> msg = <span class="string">"Login"</span></span><br><span class="line"><span class="keyword">let</span> alert = <span class="type">UIAlertController</span>(title: <span class="literal">nil</span>, message: msg, preferredStyle: .alert)</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 버튼추가</span></span><br><span class="line"><span class="keyword">let</span> cancel = <span class="type">UIAlertAction</span>(title: <span class="string">"cancel"</span>, style: .cancel)</span><br><span class="line"><span class="keyword">let</span> submit = <span class="type">UIAlertAction</span>(title: <span class="string">"submit"</span>, style: .destructive) &#123;</span><br><span class="line">    (<span class="number">_</span>) <span class="keyword">in</span></span><br><span class="line">            </span><br><span class="line">    <span class="comment">// 제출 버튼을 누르면 ID값과 PW값을 체크한다</span></span><br><span class="line">    <span class="comment">// textField는 생성되어 배열로 처리되기 때문에 아래와 같이 접근한다.</span></span><br><span class="line">    <span class="keyword">let</span> userID = alert.textFields?[<span class="number">0</span>].text</span><br><span class="line">    <span class="keyword">let</span> userPW = alert.textFields?[<span class="number">1</span>].text</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">if</span> userID == <span class="string">"user"</span> &amp;&amp; userPW == <span class="string">"1234"</span> &#123;</span><br><span class="line">       <span class="keyword">self</span>.resultAlertLable.text = <span class="string">"인증완료"</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.resultAlertLable.text = <span class="string">"인증실패"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">        </span><br><span class="line">      alert.addAction(cancel)</span><br><span class="line">      alert.addAction(submit)</span><br><span class="line">        </span><br><span class="line">      <span class="comment">//텍스트 필드 추가 - 아이디</span></span><br><span class="line">      alert.addTextField &#123; (tf) <span class="keyword">in</span></span><br><span class="line">      <span class="comment">// 텍스트 필드의 속성 설정하는 클로저</span></span><br><span class="line">        tf.placeholder = <span class="string">"ID"</span></span><br><span class="line">        tf.isSecureTextEntry = <span class="literal">false</span></span><br><span class="line">    	&#125;</span><br><span class="line">        </span><br><span class="line">      <span class="comment">//텍스트 필드 추가 - 비밀번호</span></span><br><span class="line">      alert.addTextField &#123; (tf) <span class="keyword">in</span></span><br><span class="line">          tf.placeholder = <span class="string">"PassWord"</span></span><br><span class="line">          tf.isSecureTextEntry = <span class="literal">true</span></span><br><span class="line">       &#125;</span><br><span class="line">        </span><br><span class="line">      <span class="comment">//마지막으로 화면전환</span></span><br><span class="line">     <span class="keyword">self</span>.present(alert, animated: <span class="literal">true</span>)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<br>
<h3><span id="local-notification">Local Notification</span></h3>
<hr>
<ul>
<li>앱 내부에서 만든 특정 메세지를 iOS의 알림 센터를 통해 전달하는 방법이다.</li>
<li>iOS 스케쥴러에 의해 발송되고 관리된다.</li>
<li>알림 센터에 표시된 메시지를 클릭해서 앱을 실행시키고, 원하는 기능이나 특정 화면으로 이동하게 끔 처리할 수 있다.</li>
<li><strong>앱 실행 여부와 상관없이 사용가능</strong>하기 때문에 사용자의 관심으로부터 멀어지는 상황에서 앱에 대한 주의 환기 목적으로 사용하기 적합하다.</li>
<li><strong>로컬 알림 처리</strong>
<ul>
<li>iOS 10 이전버전 <code>UILocalNotification</code> 로컬알림용 객체가 사용됨</li>
<li>iOS 11 이후버전 <code>USerNotification</code> 프레임워크에 의해서 관리됨.</li>
</ul>
</li>
<li>로컬 알림 등록과정
<ol>
<li><code>UIUserNotificationSettings</code> 객체를 이용하여 미리 알림 설정 환경을 <strong>정의</strong></li>
<li>이것을 어플리 케이션 객체에 <strong>등록</strong></li>
</ol>
</li>
<li>주로 앱이 처음 실행될 때 동의를 받는 것이 가장 자연스러우므로 <code>AppDelegate</code> 의 <code>application(_:, didFinishLaunchingWithOptions:)</code> 메서드 내에서 구현한다</li>
<li><code>UILocalNotification</code> 객체를 생성후 설정해야할 속성은 <em>발송시각/타임존/메시지/버튼명/배지/사운드/사용자 정의 데이터</em> 등이 있다.</li>
</ul>
<br>
<h4><span id="code-alrim-deungroghagi-for-ios-10-iha">CODE :: 알림 등록하기 (for iOS 10 이하)</span></h4>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 앱이 처음 실행될때 런치 스크린이 표시되고 있는 동안 호출되는 메서드</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">application</span><span class="params">(<span class="number">_</span> application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 알림 환경 설정 : 경고창, 배지, 사운드를 통해 알림을 표시해도 되는지 사용자로부터 확인을 받는다.</span></span><br><span class="line">    <span class="keyword">let</span> setting = <span class="type">UIUserNotificationSettings</span>(types: [.alert, .badge, .sound], categories: <span class="literal">nil</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 애플리케이션에 설정 저장</span></span><br><span class="line">    application.registerUserNotificationSettings(setting)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//앱이 활성화를 잃었을때 실행되는 메서드 (ex, 전화가 오거나 홈버튼을 눌러 백그라운드로 진입햇을 때)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">applicationWillResignActive</span><span class="params">(<span class="number">_</span> application: UIApplication)</span></span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//if 문으로 플랫폼 버전에 따라서 구분히여 check!!</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> #available(iOS <span class="number">11.0</span>, *) &#123;</span><br><span class="line">        <span class="comment">// 새 방식의로컬 알림 구현 코드</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 알림 설정 check</span></span><br><span class="line">        <span class="keyword">let</span> setting = application.currentUserNotificationSettings</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*  알림이 설정이 거부되면 UIUserNotificationType.none 으로 설정되어 있음</span></span><br><span class="line"><span class="comment">         알림 설정이 되어 있지 않다면 로컬 알림을 보내도 받을 수 없으므로 종료 */</span></span><br><span class="line">        <span class="keyword">guard</span> setting?.types != .<span class="keyword">none</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"can't Schedule"</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 로컬 알람 인스턴스 생성</span></span><br><span class="line">        <span class="keyword">let</span> noti = <span class="type">UILocalNotification</span>()</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//noti.fireDate = Data(timeIntervalSinceNow :10) //10초후 발송, 메서드 사라짐</span></span><br><span class="line">        noti.timeZone = <span class="type">TimeZone</span>.autoupdatingCurrent    <span class="comment">// 현재위치에 따라 타임존 설정</span></span><br><span class="line">        noti.alertBody = <span class="string">"어서 다시 접속하세요!!"</span>    <span class="comment">//표시될 메세지</span></span><br><span class="line">        noti.alertAction = <span class="string">"접속하기"</span>   <span class="comment">//잠금상태 일때 표시될 액션</span></span><br><span class="line">        noti.applicationIconBadgeNumber = <span class="number">1</span> <span class="comment">//모서리에 표시될 배지</span></span><br><span class="line">        noti.soundName = <span class="type">UILocalNotificationDefaultSoundName</span>    <span class="comment">//로컬 알람 도착시 사운드</span></span><br><span class="line">        noti.userInfo = [<span class="string">"name"</span>:<span class="string">"정현아"</span>]  <span class="comment">//로컬 알람 실행시 함께 전달하고 싶은 값!! (화면에는 표시되지 않음)</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 생성된 알람 객체를 스케쥴러에 등록</span></span><br><span class="line">        <span class="comment">//application.scheduledLocalNotifications(noti)     //메서드 사라짐</span></span><br><span class="line">        application.presentLocalNotificationNow(noti)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>
<h4><span id="code-meseodeu-jeongri">CODE :: 메서드 정리</span></h4>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">UIApplication</span>.shared( <span class="comment">//앱 델리겡트에서는 application 매개변수)</span></span><br><span class="line">    <span class="comment">//  알림 허용 여부를 사용자에게 확인받고, 선택을 어플리케이션에 등록하는 역할</span></span><br><span class="line">    .registerUserNotificationSettings(<span class="number">_</span>:)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 현재 설정된 알림 허용 여부 정보를 읽어온다</span></span><br><span class="line">        .currentUserNotificationSettings</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 생성된 알림 객체를 iOS 스케쥴러에 등록한다. 등록된 알림 객체는 fireDate 속성에 설정된 시간에 맞게 발송된다 (iOS 10)</span></span><br><span class="line">        .scheduleLocalNotification(<span class="number">_</span>:)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 생성된 알림 객체의 fireDate 속성을무시하고 즉각 발송한다</span></span><br><span class="line">        .presentLocalNotificationNow(<span class="number">_</span>:)</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Alert </tag>
            
            <tag> message </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS 화면간 데이터 전달]]></title>
      <url>/2017/11/20/view-dataTrade/</url>
      <content type="html"><![CDATA[<h1><span id="ios-view-to-view">iOS View to View</span></h1>
<h2><span id="hwamyeonjeonhwansi-data-jeondalbeob">화면전환시 Data 전달법</span></h2>
<hr>
<ol>
<li>직접전달 방식 (동기 방식)
<ul>
<li>뷰 컨트롤러에 직접 값을 전달하는 방식으로 영속적으로 값을 저장할 필요가 없는 화면 전환에서 사용된다. ( 예: 테이블뷰 -&gt; 디테일뷰 )</li>
<li>전달 받는 쪽의 뷰컨트롤러가 전달 받을 값의 명세를 모두 파악하고, 대입할 변수를 미리 준비해두어야한다.</li>
</ul>
</li>
<li>간접 전달 방식 (비동기 방식)
<ul>
<li>저장소를 이용하여 값을 전달하는 방식은 주로 <strong><em>지속적으로 값을 저장할 필요가 있는 화면 전환에서 사용</em></strong>된다. ( 예 : 로그인시 로그인 정보가 계속적으로 유지되어야 한다. 메모장 앱)</li>
<li>받는쪽과 보내는 쪽 모두 저장소의 위치를 사전에 공유하고 있어야 한다.</li>
<li>데이터가 도달하는 시간과 화면전환이 완료된 시점이 상이하므로 맞춰주어야 한다.</li>
<li>값을 전달한다기 보다 , 값을 저장하고 그 저장된 값을 불러오는 행위이다.</li>
</ul>
</li>
</ol>
<h3><span id="jigjeobjeondal-bangsig-sunseo">직접전달 방식 순서</span></h3>
<hr>
<p>VC1 -&gt; VC2 라고 가정한다.</p>
<ol>
<li>V1 : V2로 전달할 값을 준비한다.</li>
<li>V2 : 값을 대입받을 프로퍼티를 정의한다.</li>
<li>VC1: V2의 인스턴스를 직접 생성하거나, 이미 생성되어 있는 인스턴스의 참조를 읽어온다.</li>
<li>VC1 : <code>2번</code>에서 정의된 VC2 인스턴스의 프로퍼티에  <strong>값을 대입한다</strong>.</li>
<li>VC1에서 VC2로 <em>화면전환을 한다</em>.</li>
</ol>
<ul>
<li>여러개의 데이터 값을 주고 받을 시에는 <code>NSMutableDictionary</code> 같은 집합 자료형을 사용하면 편리하다.</li>
</ul>
<br>
<h4><span id="code-jigjeob-jeondal-bangsig">CODE :: 직접 전달 방식</span></h4>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//outlet 변수</span></span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> emailText: <span class="type">UITextField</span>!</span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> isUpdate: <span class="type">UISwitch</span>!</span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> interval: <span class="type">UIStepper</span>!</span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> isUpdateLabel: <span class="type">UILabel</span>!</span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> intervalLabel: <span class="type">UILabel</span>!</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Action</span></span><br><span class="line">    <span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">onSwitch</span><span class="params">(<span class="number">_</span> sender: UISwitch)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> sender.isOn &#123;</span><br><span class="line">            <span class="keyword">self</span>.isUpdateLabel.text = <span class="string">"갱신함"</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">self</span>.isUpdateLabel.text = <span class="string">"갱신안함"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">onStepper</span><span class="params">(<span class="number">_</span> sender: UIStepper)</span></span> &#123;</span><br><span class="line">        <span class="comment">//현재수치 프로퍼티에 저장</span></span><br><span class="line">        <span class="keyword">let</span> value = <span class="type">Int</span>(sender.value)</span><br><span class="line">        <span class="keyword">self</span>.intervalLabel.text = <span class="string">"<span class="subst">\(value)</span>분마다"</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">submitAction</span><span class="params">(<span class="number">_</span> sender: UIButton)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//rvc 가 옵셔널 타입이므로 guard 구문을 통해서 옵셔널 바인딩 처리</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> rvc = <span class="keyword">self</span>.storyboard?.instantiateViewController(withIdentifier: <span class="string">"RVC"</span>) <span class="keyword">as</span>? <span class="type">ResultViewController</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//아니면 종료</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        rvc.receivedEmail = <span class="keyword">self</span>.emailText.text!</span><br><span class="line">        rvc.receivedUpdate = <span class="keyword">self</span>.isUpdate.isOn <span class="comment">//bool 타입으로 전달해야하므로 .isOn사용</span></span><br><span class="line">        rvc.receivedInterval = <span class="type">Int</span>(<span class="keyword">self</span>.interval.value)</span><br><span class="line">        </span><br><span class="line">      	<span class="comment">//화면전환</span></span><br><span class="line">        <span class="keyword">self</span>.present(rvc, animated: <span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ResultViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> resultUpdate: <span class="type">UILabel</span>!</span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> resultInterval: <span class="type">UILabel</span>!</span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> resultEmail: <span class="type">UILabel</span>!</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//전화면에서 값을 전달해줄때 쓰일 parameter를 만들어준다.</span></span><br><span class="line">    <span class="comment">//중요!!</span></span><br><span class="line">    <span class="keyword">var</span> receivedEmail = <span class="string">""</span></span><br><span class="line">    <span class="keyword">var</span> receivedUpdate = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">var</span> receivedInterval = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        resultEmail.text = <span class="keyword">self</span>.receivedEmail</span><br><span class="line">        resultUpdate.text = (<span class="keyword">self</span>.receivedUpdate == <span class="literal">true</span> ? <span class="string">"자동갱신"</span> : <span class="string">"갱신안함"</span>)</span><br><span class="line">        resultInterval.text! = <span class="string">"<span class="subst">\(<span class="keyword">self</span>.receivedInterval)</span>분마다 갱신"</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Do any additional setup after loading the view.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>instantiateViewController(withIdentifier:)</code> 메소드를 호출하여 생성된 인스턴스는 기본 적으로 <code>UIViewController</code> 타입으로 생성된다. 단순 화면 전환시에는 문제가 되지 않으나, 지금은<u> <code>ResultViewController</code>의 프로퍼티를 참조하고 값을 대입</u>해야 하기 때문에 <code>ResultViewController</code> 타입의 뷰컨트롤러로 <em>다운캐스팅</em>을 해야한다!!</li>
</ul>
<br>
<h4><span id="code-nebigeisyeoneul-tonghan-jeondal-bangsig">CODE :: 네비게이션을 통한 전달 방식</span></h4>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 네비게이션 방식으로 화면전환!!</span></span><br><span class="line"><span class="comment">// 직접전달방식 : self.present(rvc, animated: true)</span></span><br><span class="line"><span class="keyword">self</span>.navigationController?.pushViewController(rvc, animated: <span class="literal">true</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>직접 전달방식과는 다르게 <code>present</code>방식이 아닌 <code>pop,push</code>방식으로 화면을 전환해야 한다.</li>
<li>나머지는 소스는 동일</li>
</ul>
<br>
<h4><span id="code-seguereul-tonghan-jeondal-bangsig">CODE :: Segue를 통한 전달 방식</span></h4>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 메뉴얼 세그일 경우는 아래 performSegue 메서드 써줘서 활성화시키기</span></span><br><span class="line"><span class="comment">// @IBAction func submitAction(_ sender: UIButton) &#123;</span></span><br><span class="line"><span class="comment">//        self.performSegue(withIdentifier: "ActionSegue", sender: self)</span></span><br><span class="line"><span class="comment">//        </span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//세그웨이로 넘겨주기전 전처리단계</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">prepare</span><span class="params">(<span class="keyword">for</span> segue: UIStoryboardSegue, sender: Any?)</span></span> &#123;</span><br><span class="line">        <span class="comment">//destView : UIViewController</span></span><br><span class="line">        <span class="keyword">let</span> destView = segue.destination</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//ResultViewController로 타입캐스팅</span></span><br><span class="line">        <span class="comment">//캐스팅시에는 항상 실패할 상황을 염두하여 옵셔널바인딩을 한다.</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> rvc = destView <span class="keyword">as</span>? <span class="type">ResultViewController</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//타입캐스팅 후 값 할당</span></span><br><span class="line">        rvc.receivedEmail = <span class="keyword">self</span>.emailText.text!</span><br><span class="line">        rvc.receivedUpdate = <span class="keyword">self</span>.isUpdate.isOn <span class="comment">//bool 타입으로 전달해야하므로 .isOn사용</span></span><br><span class="line">        rvc.receivedInterval = <span class="type">Int</span>(<span class="keyword">self</span>.interval.value)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>
<p><code>Viewcontroller</code>와 <code>ResultViewController</code>를 연결하여 <strong>Segueway</strong>를 연결해준다. (Manual segue -&gt; Show)</p>
</li>
<li>
<p>메뉴얼 세그를 사용하기 위해서는 소스 코드에서 직접 호출(performSegue)해주어야 한다.</p>
<p>그러기 위해서 세그웨이에 ID값을 지정해준다. (불러올때 쓰임)</p>
</li>
<li>
<p>어트리뷰트 인스펙터 -&gt; Identifier : <em>ManualSubmit</em>  라고 설정해준다.</p>
</li>
<li>
<p><code>prepare(for:sender:)</code>메소드에 값을 전달하는 코드를 삽입해준다. 그렇지 않으면 화면은 넘어갔는데, 값은 그 후에 넘어오는 불상사가 일어난다. (시점불일치)</p>
</li>
<li>
<p>RVC대신 세그의 <code>.destination</code>을 이용하여 목적지 뷰 컨트롤러의 참조값을 가져온다.<br>
( ResultViewController로 타입캐스팅 잊지 말것!! )</p>
</li>
<li>
<p>값을 할당한다.</p>
</li>
</ol>
<br>
<h2><span id="ijeon-hwamyeoneuro-gabseul-jeondalhagi">이전 화면으로 값을 전달하기</span></h2>
<hr>
<ol>
<li>현존하는 뷰 컨트롤러의 인스턴스의 참조값을 얻어온다.</li>
<li>화면 전환 메소드 대신 복귀 메서드를 쓴다.</li>
<li>이미 화면이 초기화 된 상태이므로, <code>ViewDidLoad()</code>메서드에 코드를 작성 하면 실행되지 않는다. 대신 화면을 보여질때 마다 실행되는 <code>viewWiillAppear(_:)</code>메서드에 작성한다.
<ul>
<li>이전 화면으로 전달하는 값은 대부분 반영구적으로 저장해야 하는 값이 많기 때문에 동기 방식으로 전달하면 전달 값이 소실된다. (VC2 -&gt; VC1 -&gt; VC2 : 과정에서 VC2는 초기화됨)</li>
</ul>
</li>
</ol>
<br>
<h3><span id="jeojangsoreul-sayonghayeo-gabseul-jugo-badgi-bidonggi">저장소를 사용하여 값을 주고 받기 (비동기)</span></h3>
<hr>
<ul>
<li>뷰 컨트롤러들이 모두 접근할 수 있는 공용의 저장소를 이용하여 값을 저장한 후 이전 화면으로 복귀하면 이전 화면에서 적절한 시점에 저장소에 저장된 값을 읽어오는 방식을 구현한다.</li>
<li>스크린에 다시 등장하는 시점에서 값을 읽어와야 하므로 <code>viewWillAppear(_:)</code>메서드에 읽어오는 소스를 삽입한다.</li>
<li>가장 쉽게 쓰이는 방법은 앱이 종료되기 전까지 유지되는 <code>AppDelegate.swift</code>파일에 임시로 저장해 두는 방법이다.</li>
<li>코코아 터치 프레임워크에서 제공하는 <u><strong>UserDefaults</strong>객체와 **코어 데이터(Core Data)**객체</u>를 통해서 반영구적으로 데이터를 저장가능하다.</li>
</ul>
<br>
<h3><span id="appdelegate-gaegcereul-sayonghayeo-gabseul-jugobadgi">AppDelegate 객체를 사용하여 값을 주고받기</span></h3>
<hr>
<p>AppDelegate는 iOS 시스템에 의해서 앱 전체를 통틀어 하나의 인스턴스만 존재하도록 보장된다.  이를 <em>Singleton(싱글톤)</em> 이라고 하는데, 이 때문에 AppDelegate class는 <strong>직접생성할 수 없으며</strong> <code>UIApplication.shared.delegate</code> 구문을 통해 생성되어 있는 객체를  참조해야 한다. 단, AppDelegate 객체는 앱의 생명주기와 함께 하므로 <strong><em>앱이 종료되면 데이터 역시 메모리에서 사라지게 된다.</em></strong></p>
<p>참조 ) 경우에 따라서는 AppDelegate를 대체할 클래스를 생성한다. 단, 아래 원칙을 지켜서 생성한다.</p>
<ul>
<li>UIResponse 클래스를 상속받아야 한다.</li>
<li>UIApplicationDelegate 프로토콜 구현을 선언해야 한다
<ul>
<li>@UIApplicationMain 어노테이션을 붙여주어야 한다.</li>
</ul>
</li>
</ul>
<br>
<h5><span id="logic">Logic</span></h5>
<hr>
<ol>
<li>AppDelegate에 만들어 놓은 프로퍼티에 값을 <strong>저장</strong>후, 화면전환을 한다.</li>
<li>화면을 복귀(혹은 전환)와 동시에 AppDelegate 객체에 저장된 <strong>값을 읽어 온다.</strong> <em>(In func viewWillAppear(_ animated: Bool))</em></li>
</ol>
<br>
<h4><span id="code-deiteo-badneun-jjog-vc">CODE :: 데이터 받는 쪽 VC</span></h4>
<hr>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewWillAppear</span><span class="params">(<span class="number">_</span> animated: Bool)</span></span> &#123;</span><br><span class="line">  <span class="comment">//참조 후 AppDelegate타입으로 캐스팅</span></span><br><span class="line">  <span class="comment">//캐스팅이 완료 되어야 해당 객체의 인스턴스를 사용 가능하다.</span></span><br><span class="line">    <span class="keyword">let</span> ad = <span class="type">UIApplication</span>.shared.delegate <span class="keyword">as</span>? <span class="type">AppDelegate</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> email = ad?.receivedEmail &#123;</span><br><span class="line">        emailText.text = email</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>
<h3><span id="userdefaults-gaegcereul-sayonghayeo-gabseul-jugo-badgi">UserDefaults 객체를 사용하여 값을 주고 받기</span></h3>
<hr>
<ul>
<li>CocoaTouch FW에서 제공하는 <code>UserDefaults</code> 객체를 사용하여 값을 저장하면 앱이 삭제되기 전까지는 저장된 값이 유지된다.</li>
<li>단순하면서도 값이 유지되어야 하는 로그인 여부, 간단한 설정 정보 등을 저장하는 경우가 많다.</li>
<li><code>UserDefaults</code> 객체의 인스턴스를 가져올때는 <code>UserDefaults.standard</code> 프로퍼티를 사용하며, 이 프로퍼티는 class 타입 프로퍼티이므로 인스턴스 생성없이 호출 가능하다.</li>
<li>스위프트 기본 자료형을 그대로 저장할 수 있다.</li>
<li><code>set(_:forKey:)</code> 메소드를 사용하여 값을 저장하며, 저장된 key를 통해 구분이 된다.</li>
</ul>
<br>
<h4><span id="code-send-amp-save">CODE :: send &amp; save</span></h4>
<hr>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">submitAction</span><span class="params">(<span class="number">_</span> sender: UIButton)</span></span> &#123;      </span><br><span class="line">    <span class="comment">/* UserDefault 저장소를 이용햔 객체 저장 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//UserDefault 객체의 인스턴스를 가져온다.</span></span><br><span class="line">    <span class="keyword">let</span> ud = <span class="type">UserDefaults</span>.standard</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//그곳에 키로 값을 저장한다.</span></span><br><span class="line">    ud.<span class="keyword">set</span>(<span class="keyword">self</span>.emailText.text, forKey: <span class="string">"email"</span>)</span><br><span class="line">    ud.<span class="keyword">set</span>(<span class="keyword">self</span>.isUpdate.isOn, forKey: <span class="string">"isUpdate"</span>)</span><br><span class="line">    ud.<span class="keyword">set</span>(<span class="keyword">self</span>.interval.value, forKey: <span class="string">"interval"</span>)</span><br><span class="line">         </span><br><span class="line">    <span class="comment">//이전 화면으로 복귀한다. (이전화면이 있을 경우)</span></span><br><span class="line">    <span class="comment">//self.presentingViewController?.dismiss(animated: true)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>
<h4><span id="code-receive-amp-get">CODE :: Receive &amp; Get</span></h4>
<hr>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewWillAppear</span><span class="params">(<span class="number">_</span> animated: Bool)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line"><span class="comment">//UserDefaults 객체의 인스턴스를 가져온다</span></span><br><span class="line">  <span class="keyword">let</span> ud = <span class="type">UserDefaults</span>.standard</span><br><span class="line">        </span><br><span class="line"><span class="comment">// string(forKey:) : Return the String Associate with the specialed key</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 반환될 타입에 따라서 메서드를 다르게 사용하면 캐스팅 없이 바로 사용가능하다.</span></span><br><span class="line"><span class="comment"> 또는 반환타입을 명확히 알 수 없을 경우 Any 타입의 값을 반환하는 아래 메소드들을 쓰면된다.</span></span><br><span class="line"><span class="comment"> let email = ud.value(forKey: "email") as? String</span></span><br><span class="line"><span class="comment"> let email = ud.object(forKey: "email") as? String</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">        </span><br><span class="line">   <span class="keyword">if</span> <span class="keyword">let</span> email = ud.string(forKey: <span class="string">"email"</span>)&#123;</span><br><span class="line">          resultEmail.text = email</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"><span class="comment">//Boolean 값으로 return해주는 메서드</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Bool 타입이나 Double 타입의 메서드는 타입별 기본값으로 값을 반환하기 때문에</span></span><br><span class="line"><span class="comment">  옵셔널 해제 없이 바로 사용가능하다.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">        </span><br><span class="line">  <span class="keyword">let</span> update = ud.bool(forKey: <span class="string">"isUpdate"</span>)&#123;</span><br><span class="line">            resultUpdate.text = (<span class="keyword">self</span>.update == <span class="literal">true</span> ? <span class="string">"자동갱신"</span> : <span class="string">"갱신안함"</span>)</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<br>
<h5><span id="tip">#TIP</span></h5>
<hr>
<ul>
<li>Action 인자값을 개별타입을 선택해야할 때
<ol>
<li>액션 메서드를 호출한 컨트롤의 속성값이 필요하거나, 이를 제어해야할 때<br>
​</li>
</ol>
</li>
<li>Action 인자값을 <strong>AnyObject</strong> 타입을 선택해야 할때
<ol>
<li>서로 다른 타입의 컨트롤이 동일한 액션 메소드를 호출하게끔 처리하고 싶을 때</li>
<li>액션메서드를 호출한 컨트롤의 정보가 필요 없을 때</li>
<li>개별 타입을 반드시 사용해야 하는 경우를 제외한 나머지 경우</li>
</ol>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 화면전환 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS 화면 전환 기법]]></title>
      <url>/2017/11/18/viewChange/</url>
      <content type="html"><![CDATA[<h1><span id="hwamyeon-jeonhwan-gibeob">화면 전환 기법</span></h1>
<h2><span id="ioseseoyi-hwamyeon-jeonhwan-gaenyeom">iOS에서의 화면 전환 개념</span></h2>
<hr>
<ol>
<li>뷰 컨트롤러의 뷰 위에 다르나 뷰를 가져와 바꿔치기하기 (특수사항/제한적으로 사용)</li>
<li>뷰 컨트롤러에서 다른 뷰 컨트롤러를 호출하여 화면 전환하기</li>
<li>네비게이션 컨트롤러를 사용하여 화면 전환하기</li>
<li>화면 전환용 객체 세그웨이(SegueWay)를 사용하여 화면 전환하기</li>
</ol>
<br>
<h4><span id="ioseseo-hwamyeon-jeonhwan-teugseong">iOS에서 화면 전환 특성</span></h4>
<hr>
<ol>
<li>다음 화면으로 이동하는 방법과 이전화면으로 되돌아가는 방법이 다름</li>
<li>화면 전환 방식에 따라 이전 화면으로 되돌아가는 방법이 다름</li>
</ol>
<br>
<h3><span id="hwamyeon-jeonhwan-gibeob1-byureul-iyonghan-hwamyeon-jeonhwan">화면 전환 기법1 :: 뷰를 이용한 화면 전환</span></h3>
<hr>
<ul>
<li>하나의 뷰 컨트롤러에 두개 이상의 루트 뷰를 준비한 다음, 상태에 따라 뷰를 적절히 교체해준다 (완전히 바꿔치기하거나, 기존뷰 위에 덮어쓰기 등)</li>
<li>하지만 MVC패턴에 어긋나고 이전 화면으로 되돌아가는 방식에 대한 처리 등 고려해야할 사항이 많아 될수 있으면 지양하는 방법이다. (1뷰컨트롤러 - 1루트뷰)</li>
<li>뷰를 이용한 화면전환을 하려면 <strong>커스텀 세그</strong>로 해결한다.</li>
</ul>
<br>
<h3><span id="hwamyeon-jeonhwan-gibeob2-byu-keonteurolreo-jigjeob-hocule-yihan-hwamyeon-jeonhwan">화면 전환 기법2 :: 뷰 컨트롤러 직접 호출에 의한 화면 전환</span></h3>
<hr>
<ul>
<li>
<p>현재의 뷰 컨트롤러에서 이동할 대상 뷰 컨트롤러를 직접 호출해서 화면에 표시한다. <strong><em>Presentation 방식</em></strong>이라고 부르기도한다.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">present(&lt;새로운 뷰컨트롤러 인스턴스&gt;, animated:&lt;애니메이션 여부/boolean&gt;)</span><br><span class="line"><span class="comment">// 화면 전환이 완료되는 시점에 맞추어 특정 로직을 실행해 주어야 할 경우, 아래 메서드를 사용한다.</span></span><br><span class="line">present(<span class="number">_</span>:animated:completion:&lt;실행구문을 클로저나 함수형식으로 입력&gt;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//이전 화면으로 복귀할 때 쓰는 복귀메서드</span></span><br><span class="line"><span class="comment">//이전화면으로 돌아가는 것이기 때문에 따로 인자값은 받지 않는다.</span></span><br><span class="line">dismiss(animated:completion:&lt;실행구문을 클로저나 함수형식으로 입력&gt;)</span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 화면 전환은 *비동기 방식*으로 전환되기 때문에 화면 전환이 끝나기 전에 다음 코드를 실행한다. 따라서 위 메서드를 이용해야 한다.</span><br><span class="line"></span><br><span class="line">  - 비동기 방식 : 하나의 처리가 끝나기를 기다리지 않고 다음 작업을 바로 이어서 수행하는 방식을 비동기 방식이라고 부른다. </span><br><span class="line"></span><br><span class="line">- *present 메서드*를 이용한 화면 전환은 기존 뷰 컨트롤러를 유지한 채, 그 위에 새로운 뷰 컨트롤러의 화면을 덮는 방식이다.</span><br><span class="line"></span><br><span class="line">- dismiss 메서드에 의해서 걷어내진 viewcontroller화면은 운영체제에 의해 곧 메모리에서 해제된다.</span><br><span class="line"></span><br><span class="line">- dismiss 메서드를 써서 화면을 전환하면 화면을 걷어내는 주체가 자기자신viewcontorller가 아니라 &lt;u&gt;자신을 띄우고 있는 이전화면 viewcontroller 라는 점이다!&lt;/u&gt;  (즉, 이전화면이 현재화면을 걷어내는것임.)</span><br><span class="line"></span><br><span class="line">- 즉 viewcontroller가 주체가 되어서 메서드를 호출하는게 아니라 presentatingViewController를 통해서 메서드를 호출한다. (두 view의 관리자)</span><br><span class="line"></span><br><span class="line">- 이전 뷰를 띄울 때 이전화면을 복귀가 아닌 <span class="type">PresentatingViewController</span>를 통해서 이전화면을 새로 호출하면 안된다. 이유는 그럼 ***뷰가 계속 중복해서 쌓이게 되어  메모리상 비효율적***이다.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;br&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### <span class="type">CODE</span> :: 예제</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">moveNextAction 버튼을 누르면 화면전환이 된다.</span><br><span class="line"></span><br><span class="line">- 두번째 뷰 <span class="type">ID</span> : secondView</span><br><span class="line"></span><br><span class="line">​```<span class="type">Swift</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">moveNextAction</span><span class="params">(<span class="number">_</span> sender: Any)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//이동할 뷰 컨트롤러 객체를 stroyboardID 정보를 이용하여 참조</span></span><br><span class="line">		<span class="comment">//let storyboard = UIStoryboard(name: "Main", bundle: Bundle.main)</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> uvc = storyboard?.instantiateViewController(withIdentifier:<span class="string">"secondView"</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 화면 전환할 때의 애니메이션 타입</span></span><br><span class="line">        <span class="comment">// UIModalTransitionStyle.&lt;변환스타일&gt;</span></span><br><span class="line">        <span class="comment">// 1. coverVertical : 모달형식으로 등장</span></span><br><span class="line">        <span class="comment">// 2. crossDissolve : 번인아웃되면서 화면변경</span></span><br><span class="line">        <span class="comment">// 3. partialCurl : 책넘김 효과</span></span><br><span class="line">        <span class="comment">// 4. flipHorizontal : 화면돌아가는 효과(flip)</span></span><br><span class="line">        uvc.modalTransitionStyle = <span class="type">UIModalTransitionStyle</span>.flipHorizontal</span><br><span class="line"></span><br><span class="line">        <span class="comment">//인자값으로 뷰 컨트롤러 인스턴스를 넣고 프레젠트 메서드 호출</span></span><br><span class="line">        <span class="comment">// 첫번째 인자 : 전환될 뷰</span></span><br><span class="line">        <span class="keyword">self</span>.present(uvc, animated: <span class="literal">true</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<br>
<h4><span id="custom-class-for-viewcontroller">Custom Class for ViewController</span></h4>
<hr>
<p><em>하나의 뷰컨트롤러에는 하나의 뷰컨트롤러 <strong>클래스</strong>가 있어야 한다.</em></p>
<ol>
<li><code>customClass.swift</code> 파일 추가 (UIViewController 상속받아 생성)</li>
<li>storyboard에서 해당 뷰컨트롤러를 클릭 후 인스펙터창에서 <code>Cumstom Class</code> 영역에서 만들어준 <code>customClass.swift</code> 를 class란에 써넣어준다.</li>
<li>소스 - 뷰 연결 완료!</li>
</ol>
<br>
<h3><span id="hwamyeon-jeonhwan-gibeob2-nebigeisyeon-keonteurolreoreul-iyonghan-hwamyeon-jeonhwan">화면 전환 기법2 :: 네비게이션 컨트롤러를 이용한 화면 전환</span></h3>
<hr>
<ul>
<li>
<p>navigationController</p>
<ul>
<li>
<p><strong><em>뷰 컨트롤러들의 계층적 구조를 관리하는 역할</em></strong>을 한다. 직접 컨텐츠를 담고 화면을 구성하지 않지만, 대신 다른 뷰를 포함하고 있으며 포함된 <u>모든 뷰 컨트롤러에 내비게이션 바를 생성하는 특징</u>이 있다. (스토리보드상 보이지 않더라도 빌드하면 포함되어져 있다.)</p>
</li>
<li>
<p>항상 컨텐츠 계층구조의 시작점 역할을 하는 뷰 컨트롤러와 함께 붙어 다니는데, 이를 <strong>Root View Controller</strong>라고 한다.</p>
</li>
<li>
<p>Stack 구조를 갖고 있다.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//최상위에 뷰 컨트롤러를 추가할 때</span></span><br><span class="line">pushViewController(:animated:)</span><br><span class="line"></span><br><span class="line"><span class="comment">//최상위 뷰 컨트롤러를 제거할 때</span></span><br><span class="line">popViewController(animated:)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>도중에 네비게이션컨트롤러를 추가할 경우 [Editor] -&gt; [Embed in]-&gt;[Navigation Controller]를 눌러줘서 삽입시켜준다. 혹은 segue( -&gt; Root view controller)를 통해 지정해준다.</p>
</li>
<li>
<p>네비게이션 컨트롤러를 사용하여 화면을 전환시켜주지 않았을 경우,  <em>더이상 네이게이션 컨트롤러의 제어하에 있지 않게 된다</em>.</p>
</li>
</ul>
</li>
</ul>
<br>
<h3><span id="segeuweireul-iyonghan-hwamyeon-jeonhwan">세그웨이를 이용한 화면 전환</span></h3>
<hr>
<ul>
<li>
<p>Manual Segue<br>
<code>performSegue(withIdentifier:sender:)</code> 메서드 사용하여 화면전환</p>
</li>
<li>
<p>Action Segue<br>
버튼, 테이블 셀의 이벤트 트리거에 자동으로 연결하여 화면전환</p>
</li>
<li>
<p>[Show] 타입 세그웨이<br>
네비게이션 컨트롤러를 통한 화면 이동이 발생함</p>
</li>
<li>
<p>[Present Modally]타입 세그웨이<br>
<code>present(:animate:)</code> 메서드를 이용한 화면이동과 동일한 효과</p>
</li>
<li>
<p><strong>Unwind Segue</strong><br>
화면 전환되는 것을 Wind라고 한다면 , 반대로 돌아가는 것은 Unwind라고한다.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 돌아올곳을 표기해놓은 이정표! (돌아갈곳에서 구현해주어야 한다.)</span></span><br><span class="line"><span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">unwindToVC</span><span class="params">(<span class="number">_</span> sugue: UIStoryboardSegue)</span></span>&#123;</span><br><span class="line">  ..</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>위와 같이 돌아가고자 하는 곳에 <code>UIStoryboardSegue</code> 를 파라미터로 받는 함수를 구현한 후 , 돌아가려고했던 화면에서 [버튼 + Ctrl] -&gt; Exit 로 드래그해서 해당 함수를 지정해주면, 되돌아갈때 <em>그 해당함수가 있는 곳으로</em> (이정표) 돌아가게 된다.</p>
<ul>
<li>unwind를 통한 이동을 하면 사이에 있던 뷰들은 메모리에서 **dealloc (해제)**되게 된다.</li>
</ul>
</li>
</ul>
<br>
<h5><span id="custom-segue">Custom Segue</span></h5>
<ul>
<li>cumstom class 만드는 것과 같이 먼저 소스상으로 파일로 구현하고 (UIstoryboardSegue 상속) 스토리보드상에서 연결해주고 custom class로 지정할때 class부분에 custom class 명을 써주면 연결된다.</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">customSegue</span>: <span class="title">UIStoryboardSegue</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">perform</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">//세그웨이의 출발지 뷰 컨트롤러</span></span><br><span class="line">        <span class="keyword">let</span> starVC = <span class="keyword">self</span>.source</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//세그웨이의 도착지 뷰 컨트롤러</span></span><br><span class="line">        <span class="keyword">let</span> destVC = <span class="keyword">self</span>.destination</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// duration : &lt;화면전환에 소요되는 시간(sec)&gt;</span></span><br><span class="line">        <span class="comment">// option : &lt;애니메이션 전환 옵션&gt;</span></span><br><span class="line">        <span class="type">UIView</span>.transition(from: starVC.view, to: destVC.view, duration: <span class="number">2</span>, options: .transitionCurlDown)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>prepare(for segue:UIStoryboardSegue, sender: Any?){…}</code> 과 같은 전처리 메서드도 있다. (세그웨이로 넘어가기 전 처리해야할 사항들을 체크하고 넘어간다.)</p>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 화면전환 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[App Life Cycle]]></title>
      <url>/2017/11/18/App-lifeCycle/</url>
      <content type="html"><![CDATA[<h1><span id="app-life-cycle">App Life Cycle</span></h1>
<h2><span id="aebyi-saengmyeongjugi">앱의 생명주기</span></h2>
<hr>
<p>앱의 상태변화는 다음과 같이 나눌 수 있다.</p>
<ul>
<li>Not Running : 앱이 시작되지 않았거나 실행되었지만 시스템에 의해 종료된 상태</li>
<li>Inactive : 앱이 전면에서 실행 중이지만, 아무런 <strong>이벤트를 받지 않고 있는 상태</strong></li>
<li>Active : 앱이 전면에서 실행 중이며, 이벤트를 받고 있는 상태</li>
<li>Background : 앱이 백그라운드에 있지만 여전히 코드가 실행되고 있는 상태. 대부분의 앱은 <strong><em>Suspended</em></strong> 상태로 이행하는 도중에 일시적으로 이 상태에 진입하지만, 파일 다운로드나 업로드, 연산처리 등 여분의 실행 시간이 필요한 앱일 경우 특정 시간동안 이 상태로 남아 있게 되는 경우도 있다.</li>
<li>Suspended : 앱이 메모리에 유지되지만 <strong>실행되는 코드가 없는 상태</strong>. 메모리가 부족한 상황이 오게되면 iOS시스템은 포그라운드에 있는 앱의 여유 메모리 공간을 확보하기 위해 <u>Suspended 상태에 있는 앱들을 특별한 알림 없이 정리</u>한다.</li>
</ul>
<p>앱이 Not Running 상태에서 Suspended를 거처 다시 Not Running 상태로 돌아가기 까지의 과정을 <strong><em>앱 라이프사이클(App Life Cycle, 앱 생명주기)</em></strong> 라고 한다.</p>
<br>
<p>뷰 컨트롤러는 다음과 같이 네 가지 상태로 나눌 수 있다.</p>
<ul>
<li>Appearing : 뷰 컨트롤러가 스크린에 등장하기 시작한 순간부터 등장을 완료하기 직전까지의 상태. 퇴장 중인 다른 뷰 컨트롤러와 교차하기도 하며 , 이때 퇴장중인 다른 뷰 컨트롤러의 상태는 Disappering가 된다.</li>
<li>Appeared : 뷰 컨트롤러가 스크린 전체에 완전히 등장한 상태</li>
<li>Disappearing : 뷰 컨트롤러가 스크린에서 가려지기 시작해서 완전히 가려지기 직전까지의 상태, 또는 퇴장하기 시작해서 완전히 퇴장하기 진전까지의 상태.</li>
<li>Disappeared : 뷰 컨트롤러가 스크린에서 완전히 가려졌거나 혹은 퇴장한 상태를 나타낸다.</li>
</ul>
<br>
<p><img src="/image/applifecycle.png" alt="앱생명주기"></p>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> lifeCycle </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Cocoa Touch FrameWork]]></title>
      <url>/2017/11/18/CocoaTouchFW/</url>
      <content type="html"><![CDATA[<h1><span id="cocoa-touch-framework">Cocoa Touch FrameWork</span></h1>
<h2><span id="kokoa-teoci-peureimweokeu">코코아 터치 프레임워크</span></h2>
<hr>
<p>애플 환경에서 터치 기반의 애플리케이션을 제작하기 위한 도구들의 모음이다.</p>
<br>
<h3><span id="peureim-weokeu-framework">프레임 워크 (Framework)</span></h3>
<hr>
<p>&quot;뼈대, 기본구조&quot;를 의미한다.  소프트웨어에서 사용하는 프레임워크는 애플리케이션 제작을 빠르고 편리하게 할 수 있도록 <strong><em>미리 뼈대를 이루는 각종 코드를 제작하여 모아둔 것</em></strong>이다. 따라서 프레임워크를 사용하면 몇 줄의 코드만으로 손쉽게 버튼을 구현할 수 있다.</p>
<p>집을 짓는 과정으로 예를 들면,  <strong>Framwork</strong>는 철근, 콘크리트, 유리 , 문, 배선 등이고 반면 <strong>Swift</strong>는</p>
<p>망치, 드라이버, 톱과 같은 도구에 해당한다.</p>
<br>
<h4><span id="juyo-frameworks">주요 Frameworks</span></h4>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation	<span class="comment">//앱의 핵심 객체와 네트워크, 문자열 처리 등의 서비스를 제공하는 프레임워크(내부)</span></span><br><span class="line"><span class="keyword">import</span> UIkit		<span class="comment">//애플 App에서 실행되는 유저인터페이스를 제공하는 프레임워크(외부)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> AddressBookUI	<span class="comment">//</span></span><br><span class="line"><span class="keyword">import</span> UserNotifications	<span class="comment">//사용자 알림 프레임워크</span></span><br><span class="line"><span class="keyword">import</span> GameKit	<span class="comment">//게임을 만들기위한 프레임워크 </span></span><br><span class="line"><span class="keyword">import</span> iAd	<span class="comment">//앱 내에 베너형태 또는 팝업 형태의 광고를 삽입할 수 있도록 해주는 광고 프레임워크</span></span><br><span class="line"><span class="keyword">import</span> MapKit	<span class="comment">//위치정보나 지도 관련 서비스를 이용할 수 있도록 해주는 프레임워크</span></span><br><span class="line"><span class="keyword">import</span> EventKitUI	<span class="comment">//이벤트 처리에 필요한 유저 인터페이스를 제공하는 프레임워크</span></span><br><span class="line"><span class="keyword">import</span> MessageUI	<span class="comment">//문자관련 프레임워크</span></span><br><span class="line"><span class="keyword">import</span> UserNotifications	<span class="comment">//사용자 알림을 처리하기 위해 필요한 객체들을 제공하는 프레임워크</span></span><br></pre></td></tr></table></figure>
<br>
<h3><span id="peureimweokeu-gyeceunggwangye">프레임워크 계층관계</span></h3>
<hr>
<p>하위계층으로 갈수록 추상적이고 하드웨어 쪽에 가까워 우리가 다루기에는 다소 번거롭기 때문에 사용자에 가깝고 구체적으로 구현되어 있는 상위계층 프레임워크를 통해 간접적으로 하드웨어를 제어 가능하게 된다. 상위 프레임워크는 하위 프레임워크에 의존적이며, 하위 프레임워크를 통해 구현된 기능에 보다 구체적인 기능만 붙여진 것이다.</p>
<p>iOS 프레임워크는 다음과 같다.</p>
<ul>
<li>
<p>Cocoa Touch (최상위 &lt;—&gt; Application)<br>
어플리케이션 프레임워크 계층. 어플리케이션을 직접 지원하는 역활을 한다.  모든 애플리케이션은 코코아 터치 프레임워크를 통해 구현되고 동작한다.</p>
</li>
<li>
<p>Media<br>
코코아 터치 프레임워크에 그래픽 관련 서비스나 멀티미디어 관련 서비스를 제공한다. 코어 그래픽스, 코어 텍스트, 코어 오디오, AV파운데이션 등이 있다.<br>
쉽게 말해서 mp4 와 같은 비디오 파일을 아이폰에서 재생할 때 미디어 계층이 관여한다.</p>
</li>
<li>
<p>Core Service<br>
문자열 처리, 데이터 집합관리, 네트워크, 주소록 관리, 환경설정 등 핵심적인 서비스들을 제공한다.  GPS, 가속도 센서 등 디바이스의 하드웨어 특성에 기반한 서비스도 제공한다.<br>
예로 <em>코어 파운데이션 프레임워크</em>가 이에 속한다.</p>
</li>
<li>
<p>Core OS (최하위 &lt;—&gt; HardWare)</p>
<p>커널, 파일 시스템, 네트워크, 보안, 전원관리 , 디바이스 드라이버 등이 포함되어있다. <em>iOS가 운영체제로서 기능</em>을 하기 위한 핵심적인 영역이라고 할 수 있다.</p>
</li>
</ul>
<br>
<h3><span id="peureimweokeuyi-jeobdueo">프레임워크의 접두어</span></h3>
<hr>
<p>주요 프레임워크들은 자신들에게 속해있는 <strong><em>객체의 이름에 특정 접두어를 붙이는 경향</em></strong>이 있다. 이를 통해 객체가 어떤 프레임워크에 속해 있는지 쉽게 파악할 수 있다.</p>
<ul>
<li>Foundation : NS</li>
<li>UIKit : UI</li>
<li>UserNotifications : UN</li>
<li>MapKit : MK</li>
<li>Core Foundation : CF</li>
<li>Core Graphics : CG</li>
<li>AVFoundation : AV</li>
</ul>
<br>
<h3><span id="viewwa-window">View와 Window</span></h3>
<hr>
<p>iOS에서 실행되는 모든 애플리케이션은 최소한 하나 이상의 윈도우와 뷰를 가진다. 계층상 Window객체가 최상위에 위치하며 여러 view들이 중첩되어 화면을 구성한다.</p>
<blockquote>
<p>Window &gt; Tab bar View &gt; Navigation View &gt; Custom View</p>
</blockquote>
<br>
<h4><span id="view-controller">View Controller</span></h4>
<hr>
<p>Window와 View는 항상 뷰 컨트롤러를 통해 연결된다. 뷰 컨트롤러는 뷰의 계층을 관리하여 윈도우에 전달하고 , 모바일 디바이스에서 감지된 터치 이벤트를 윈도우로부터 전달받아 처리하는 역할을 한다. 또한 화면과 데이터 사이의 상호 작용까지 관리한다.  이와 같이 뷰 컨트롤러가 중재를 해주는 덕분에 <u>윈도우 객체에 커스텀 코드가 난입하는 것을 차단하며, 뷰를 관리해야하는 불상사를 막아준다.</u><br>
뷰 컨트롤러는 각자 하나씩의 화면을 담당하며 이를 **씬(Scene)**이라는 용어로 부른다.</p>
<br>
<h4><span id="view">View</span></h4>
<hr>
<p>뷰들은 자기 자신을 스크린상에 표시하기도 하지만, 동시에 다른 뷰 객체를 포함하는 컨테이너 역할도 수행한다. 이를***뷰의 계층구조 (View hierachy)***라고 한다. 따라서 다른 뷰를 포함하는 뷰는 <strong>Superview</strong>라고 하며 속해있는 뷰는 <strong>Subview</strong> 가 된다. 뷰의 계층 구조상에서 뷰들은 서로 상대적인 레이아웃을 이룬다.</p>
<ul>
<li>뷰계층 구조 상 최상위에는 하나의 뷰가 존재하는데 이를 <strong>Root View</strong> 또는 <strong>Contents View</strong> 라고 한다.</li>
</ul>
<br>
<h4><span id="navigation-controller">Navigation Controller</span></h4>
<hr>
<p><strong><em>앱의 화면 이동에 대한 관리와 그에 연관된 처리를 담당해주는 컨트롤러</em></strong> . 내부적으로 다른 컨트롤러를 포함하면서 컨트롤러끼리의 <u>화면 이동을 처리해주고, 현재 페이지 위치에 대한 네비게이션 역활</u>을 한다. UINavigationController 클래스를 상속받아 구현한다.</p>
<br>
<h4><span id="table-view-controller">Table View Controller</span></h4>
<hr>
<p>내부에 <strong><em>리스트 형식의 테이블 뷰를 포함하고 있어 여러 항목이나 데이터를 화면에 나열</em></strong>하기 위한 목적으로 사용되는 컨트롤러.  UITableViewController 클래스를 상속받아 구현한다</p>
<br>
<h4><span id="tab-bar-controller">Tab Bar Controller</span></h4>
<hr>
<p>화면을 나타내는 여러 개의 탭이 있고,<strong><em>탭을 터치하면 화면이 전환되는 형태의 앱</em></strong>을 만들고자 할 때 사용되는 컨트롤러.  UITabbarController 클래스를 상속받아 구현한다</p>
<br>
<h4><span id="split-view-controller">Split View Controller</span></h4>
<hr>
<p>Master-Detail Application 템플릿을 선택하면 생성되는 기본 컨트롤러. 목록을 나열하는 마스터 페이지와 그 목록 각각에 대한 세부 내용을 보여주는 디테일 페이지로 구성되는 스플릿 뷰 컨트롤러는 <strong><em>화면 크기에 따라 두 페이지를 하나의 화면에 조합하여 보여줄 것인지 아니면 두 개의 화면으로 나누어 보여줄 것인지 자동으로 처리</em></strong>해주는 특징이 있다. 직접 화면을 구현하지는 않으나 화면의 크기에 따라 적절히 조합해주는 역할을 한다.</p>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Framework </tag>
            
            <tag> iOS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CH19. Protocol]]></title>
      <url>/2017/11/03/chap19-protocol/</url>
      <content type="html"><![CDATA[<h1><span id="protocol">Protocol</span></h1>
<p>Swift 는 프로토콜 지향 언어이다. 객체지향 프로그래밍 패러다임에 기반을 둔 언어는 대부분 클래스의 상속을 사용해 공통된 기능을 구현하지만, 프로토콜 프로그래밍에서는 같은 프로토콜을 준수함으로이냏서 공통된 프레임을 가질 수 있다.</p>
<h2><span id="peurotokol-gaegceyi-seolgyedo">프로토콜 (객체의 설계도)</span></h2>
<hr>
<p>스위프트가 제고하는 캡슐화 중 한 가지 형태이다. 프로토콜을 적용하면 타입 자체를 몰라도 타입의 인터페이스를 지정하는 등 타입을 다룰 수 있다.</p>
<ul>
<li>
<p>클래스나 구조체가 어떤 기준을 만족하거나 또는 특수한 목적을 달성하기 위해 구현해야 하는 메소드와 프로퍼티의 목록이다.</p>
</li>
<li>
<p>프로토콜에서는 프로퍼티의 종류/이름/변수,상수/타입/읽기or쓰기전용에 대해서만 정의할 뿐 초기값을 할당할 수 없다.</p>
</li>
<li>
<p>구체적인 내용이 없는 프로퍼티나 메소드의 단순한 선언 형태로 구성된다. ( 구체적인 내용은 프로토콜을 이용하는 객체에서 담당한다. -&gt; 이것을 <strong>프로토콜을 구현</strong>한다고 한다.)</p>
</li>
<li>
<p>프로토콜은 타입이 이런 프로퍼티와 메서드만큼은 가져야 한다는 최소 요건을 정의한다. (제시하는 요건을 모두 만족한다면 추가적으로 프로퍼티나 메서드를 추가할 수 있다.)</p>
</li>
<li>
<p>프로토콜을 구현한 객체의 메서드나 속성을 은닉하고 프로토콜에서 선언된 명세의 내용만 제공하는 기능을 하기도 한다.</p>
</li>
<li>
<p><code>:Protocol</code> 의 형태로 (superclass 선언하는 방식과 동일)</p>
</li>
<li>
<p>프로퍼티나 메서드 뿐만 아니라 이니셜라이저도 가질 수 있다.</p>
</li>
<li>
<p>프로퍼티는 항상 <code>var</code>  키워드를 사용한 변수 프로퍼티로 정의한다.</p>
</li>
</ul>
<blockquote>
<p>맥이나 iOS 앱들은 기본적으로 <strong><em>데이터의 표현과 소스를 분리</em></strong>한다. 이러한 패턴은 데이터의 저장 방식을 전적으로 사용자에게 맡길 수 있다는 점에서 대단히 유용하다.</p>
</blockquote>
<p><img src="classProtocol.png" alt="클래스와프로토콜의관계"></p>
<br>
<h3><span id="peurotokolyi-junsu-conform">프로토콜의 준수(conform)</span></h3>
<hr>
<ol>
<li>타입은 모두 프로토콜을 준수할 수 있다.</li>
</ol>
<ul>
<li>구조체 (struct)</li>
<li>클래스 (class)</li>
<li>열거형 (enum)</li>
<li>익스텐션 (extension)</li>
</ul>
<ol start="2">
<li>
<p>타입이 여러 프로토콜을 준수하는 것도 가능하다. (<code>,</code>로 연결하여 선언)</p>
</li>
<li>
<p>슈퍼 클래스를 상속 받고도 프로토콜을 준수할 수 있다.</p>
</li>
</ol>
<ul>
<li>슈퍼클래스 이름이 먼저 오고 그 뒤에 프로토콜들이 온다.</li>
</ul>
<ol start="4">
<li>
<p>메서드의 외부 변수명은 준수해야 하지만 내부 변수명은 구현시 변경가능하다.</p>
<p>​</p>
</li>
</ol>
<br>
<h3><span id="kiweodeu-mutating-gabyeon-meseodeu-statics">키워드 mutating (가변 메서드), statics</span></h3>
<hr>
<ul>
<li>클래스와 같은 참조 타입은 mutating 키워드를 붙이지 않아도 메소드 내에서 마음대로 프로퍼티를 수정할 수 있다.</li>
</ul>
<ul>
<li>
<p>구조체나 열거형은 내부의 <u>메서드가 프로퍼티를 변경하는 경우</u>, 메서드 앞에 반드시 <code>mutating</code> 키워드를 붙여 이 메소드가 값을 수정하는 메소드임을 표시하도록 강제하고 있습니다. 이때 그 메서드가 만약 프로토콜에서 선언된 메서드라면 <code>mutating</code> 키워드를 붙이기 위해서는 <em>반드시 프로토콜에 <code>mutating</code> 키워드가 추가</em>되어 있어야 한다.</p>
</li>
<li>
<p>이런 측면에서 프로토콜은 자신을 구현하는 구조체가 마음대로 프로퍼티를 수정하지 못하도록 통제할 수 있는 권한이 있다.</p>
</li>
<li>
<p>일반적으로 프로토콜에서 메소드 선언에 <code>mutating</code> 키워드가 붙지 않는 것은 다음과 같은 경우이다.</p>
<ol>
<li>구조체나 열거형 등 값 타입의 객체에서 내부 프로퍼티의 값을 <strong>변경하기를 원치 않을 때</strong></li>
<li>주로 <strong>클래스를 대상으로 간주</strong>하고 작성된 프로토콜일 때</li>
</ol>
</li>
<li>
<p><code>mutating</code> 키워드가 있더라도 프로퍼티의 변경이 없다면 굳이 붙이지 않고 생략해도 오류는 발생하지 않는다.</p>
</li>
<li>
<p>타입 메소드나, 타입 프로퍼티도 프로토콜에 정의할 수 있다. (<code>static</code>)</p>
</li>
<li>
<p>단, 클래스에서 타입 메소드를 선언할 때 사용 되는 <code>class</code> 키워드는 클래스에서만 사용가능하므로 모든 형식에 사용된느 <strong>프로토콜에서는 <code>static</code>만 사용 가능</strong>하다. ( 단 , <em>클래스에서 프로토콜 구현시에는</em>  필요에 따라 두 키워드를 선택해서 사용할 수 있다. )</p>
</li>
</ul>
<br>
<h3><span id="peurotokolgwa-cogihwa-mesodeu">프로토콜과 초기화 메소드</span></h3>
<hr>
<ul>
<li>구조체는 멤버와이즈 메소드가 기본적으로 제공되나, 프로토콜에 멤버와이즈 메소드가 선언되었다면 모두 직접 구현해주어야 한다.</li>
<li><strong>클래스</strong>에서 <strong>초기화 메소드</strong>를 구현할 때는 반드시 <code>required</code> 키워드를 붙여야 한다. (일반 메서드나 프로퍼티에는 붙지않음)</li>
<li>final 클래스는 상속할 수 없기 때문에, <code>required</code> 키워드를 붙이지 않아도 된다. ( 반드시 구현되어야 한다는 점을 알리는게 무의미 하기 때문에!!)</li>
<li>부모 클래스에서 물려받은 초기화 구문과 프로토콜로 부터 구현해야하는 <em>초기화 메서드가 동일해 충돌하는 경우</em>, 부모 클래스 입장에서 볼 때는 이 이니셜 라이져가 상속된것이므로 <code>override</code> 키워드도 붙여주어야 한다. (키워드 순서는 무관)<br>
ex) <code>override required init()</code></li>
</ul>
<br>
<h4><span id="code">CODE</span></h4>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Classname</span>: <span class="title">Superclass</span>, <span class="title">Protocol_1</span>,<span class="title">Protocol_1</span> </span>&#123;</span><br><span class="line">  	<span class="comment">// 외부로 드러나는 매개변수명은 일치해야 한다. (내부 변수명은 임시로 변경가능하다)</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">name</span><span class="params">(cmd: String, desc: String)</span></span> -&gt; <span class="type">String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>
<h3><span id="taibeuroseoyi-peurotokol">타입으로서의 프로토콜</span></h3>
<hr>
<ul>
<li>상수, 변수, 프로퍼티의 타입으로 사용 가능 (<code>Int</code>와 같은 타입을 말하는 것임!)</li>
<li>함수, 메서드 또는 초기화 구문에서 매개 변수 타입이나 반환 타입으로 프로토콜 사용가능</li>
<li>배열이나 사전, 혹은 다른 컨테이너의 타입으로 사용할 수 있음.</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Wheel</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">spin</span><span class="params">()</span></span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">hold</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> trans:<span class="type">Wheel</span> = <span class="type">Bike</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 컴파일러가 trans를 Wheel 타입으로 읽어들여 두 메서드만 사용 가능하다.</span></span><br><span class="line"><span class="comment">// Delegate 패턴 로직</span></span><br><span class="line">trans.spin()</span><br><span class="line">trans.hold()</span><br></pre></td></tr></table></figure>
<br>
<h3><span id="peurotokol-sangsog">프로토콜 상속</span></h3>
<hr>
<ul>
<li>여러 프로토콜을 상속받을 수 있는 <strong>다중 프로토콜 상속</strong>을 지원한다.</li>
<li>상속을 통해 프로토콜들의 명세를 하나의 프로토콜에 담을 수 있습니다.</li>
</ul>
<ul>
<li>싱속받은 프로토콜에서 준수 타입이 이 두 프로토콜에 필요한 프로퍼티와 메서드를 구현해야 한다.</li>
<li>클래스 상속에서는 슈퍼클래스와 서브클래스 사이의 밀접한 관계를 정의한다는 점에서 다르다. 따라서 <code>override</code> 키워드를 붙이지 않아도 된다.</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">C</span>: <span class="title">A</span>, <span class="title">B</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">doC</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//실질적 protocol C</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">doA</span><span class="params">()</span></span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">doB</span><span class="params">()</span></span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">doC</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>
<h3><span id="peurotokol-guseong">프로토콜 구성</span></h3>
<hr>
<ul>
<li>프로토콜 상속은 기존 프로토콜에 일정 요건이 더해진 새 프로토콜을 쉽게 만들 수 있는 강력한 도구라고 할 수 있지만, <em>타입을 만들 때 잘못된 선택</em>을 할 가능성이 농후해진다. <strong>이를 해결하기 위한 방안</strong>이다.</li>
<li>다중 프로토콜을 단일 요구사항인 프로토콜 구성으로 결합할 수 있다.</li>
<li><code>&amp;</code> 중위 연산자를 사용하여 여러 프로토콜을 하나의 요건으로 결합한다.<br>
Ex) <code>var imp: A&amp;B = Do()</code></li>
<li>읽기전용, 혹은 저장 프로퍼티, 읽기 쓰기 전용 으로 반드시 구현해야할 때는 지정이 가능하다.</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">AnyProtocol</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> settableProperty: <span class="type">String</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;	<span class="comment">//읽기쓰기 전용</span></span><br><span class="line">    <span class="keyword">var</span> notNeedToBeSettableProperty: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;	<span class="comment">//읽기 전용</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>
<h3><span id="seontaegjeog-peurotokol">선택적 프로토콜</span></h3>
<ul>
<li><code>@objc</code> 속성을 부여한다. (이때 Foundation Framework를 임포트 해야한다.)
<ul>
<li>단, 위 속성이 부여되려면 Objective-C 클래스를 상속받은 클래스에서만 채택할 수 있다. 따라서 <strong>열거형이나 구조체 등에서는 채택불가</strong>.</li>
</ul>
</li>
<li><code>optional</code> 식별자를 붙인다</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@objc</span> <span class="class"><span class="keyword">protocol</span> <span class="title">Moveable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">walk</span><span class="params">()</span></span></span><br><span class="line">    @bjc <span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">fly</span><span class="params">()</span></span>	<span class="comment">//특정 타입만 구현해준다.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>
<h3><span id="peurotokol-cogiguhyeon">프로토콜 초기구현</span></h3>
<p>프로토콜의 요구사항을 익스텐션을 통해 구현하는 것이다.</p>
<p>단, 저장 프로퍼티는 구현할 수 없다.</p>
<br>
<h3><span id="delegate-pattern">Delegate Pattern</span></h3>
<hr>
<ul>
<li>델리게이트 <u>참조를 통해 메소드를 호출할 인스턴스 객체를 전달</u>받고, 이 인스턴스 객체가 구현하고 있는 프로토콜에 선언된 메소드를 호출하는 것이 델리게이션이다.</li>
<li>프로토콜을 통해 델리게이션을 구현하는 것은 클래스가 단일 상속만을 지원하기 때문에 더는 다를 클래스를 상속받을 수 없으므로 기능을 덧붙이기에는 제한적이다. 이를 극복하기 위해 구현 개수에 제한이 없는 프로토콜을 이용하여 필요한 기능 단위별 객체를 작성하는 것이다.</li>
</ul>
]]></content>
      
        <categories>
            
            <category> SWIFT </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 프로토콜 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CH18. Value vs Reference]]></title>
      <url>/2017/11/03/chap18-valueVSref/</url>
      <content type="html"><![CDATA[<h1><span id="value-vs-reference">Value vs Reference</span></h1>
<h2><span id="gabs-taib-vs-camjo-taib">값 타입 VS 참조 타입</span></h2>
<br>
<h3><span id="gabs-value-yi-semantigseu">값(Value)의 세만틱스</span></h3>
<hr>
<ul>
<li>
<p>인스턴스에 대입될 때 또는 함수의 인수로 전달될 때 항상 <strong><em>복사(copy)</em></strong> 된다.</p>
</li>
<li>
<p>보이지 않는 곳에서 해당 데이터가 임의로 변경되지 않음을 보장할 수 있다.</p>
</li>
<li>
<p><code>Array, Dictionary, Int, String</code> 등은 모두 구조체로 구현되어 있으며, 값 타입이다.</p>
</li>
<li>
<p>값이 복사될 때 swift에서는 <strong>얕은 복사</strong>만을 지원한다.</p>
<ul>
<li>
<p><em>얕은 복사(shallow copy)</em> : 객체는 별도로 생성하지만, 그 안에 들어가는 내용은 원래 복사했던 객체를 가리키고 있다.<br>
<img src="/image/shallowCopy.png" alt="얕은복사"></p>
</li>
<li>
<p><em>깊은 복사(deep copy)</em> : 객체도 별도로 생성하고,그 안에 들어가는 내용까지 복사해온다.<br>
<img src="/image/deepCopy.png" alt="깊은복사"></p>
</li>
</ul>
<blockquote>
<p>shallow copy : 객체만 별도 생성, 내용은 동일한 객체<br>
deep copy : 객체도 별도 생성, 그 내용도 재귀적으로 복사</p>
</blockquote>
</li>
</ul>
<br>
<h3><span id="camjo-reference-yi-semantigseu">참조(Reference)의 세만틱스</span></h3>
<hr>
<ul>
<li>값 타입과 달리 참조타입의 인스턴스는 <strong><em>같은 인스턴스를 가리키는 참조</em></strong>가 하나 더 만들어진다.</li>
<li>따라서 같은 인스턴스를 가리키는 참조 중 한쪽에서 그 값을 변경하면 <em>다른쪽에서도 영향을 받게 된다</em>.</li>
</ul>
<br>
<h3><span id="dongilseong-vs-jeongceseong">동일성 vs 정체성</span></h3>
<hr>
<ul>
<li>동일성(equality) : 두 인스턴스가 <strong><em>동일한 값</em></strong>을 가질 때</li>
<li>정체성(identity) : 두 변수나 상수가 <strong><em>메모리에서 같은 인스턴스</em></strong>를 가리킬 때</li>
<li><code>==</code>는 동일성 비교함수이다.</li>
<li><code>===</code> 는 정체성 비교함수이다.</li>
</ul>
<br>
<h3><span id="use-case">Use Case</span></h3>
<hr>
<h5><span id="value-type">Value Type</span></h5>
<ul>
<li><code>==</code> 를 사용하여 인스턴스를 비교하는 것이 합당한 경우</li>
<li>독립적인 상태로 각각의 사본을 만들고자 하는 경우</li>
<li>여러 스레드에서 사용될 데이터인 경우<br>
​</li>
</ul>
<h5><span id="reference-type">Reference Type</span></h5>
<ul>
<li><code>===</code> 를 사용하여 인스턴스(포인터)를 비교하는 것이 합당한 경우</li>
<li>공유된 상태, 변경이 가능한 상태를 원하는 경우</li>
</ul>
]]></content>
      
        <categories>
            
            <category> SWIFT </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 참조타입 </tag>
            
            <tag> 값타입 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CH17. Initializer]]></title>
      <url>/2017/11/02/chap17-initializer/</url>
      <content type="html"><![CDATA[<h1><span id="initializer">Initializer</span></h1>
<h2><span id="cogihwa">초기화</span></h2>
<hr>
<ul>
<li>인스턴스를 설정하는 과정으로 <code>Init</code> (Initializer) 키워드로 시작한다.</li>
<li>인스턴스가 만들어질 때 <em>저장형 프로퍼티</em>가 값을 가지도록 하는 방법이다.</li>
<li>초기화가 완료되었을 때, <u>타입의 프로퍼티에 값이 있다는 것을 보장</u>하는 데 목적이 있다.</li>
</ul>
<br>
<h3><span id="gujoce-cogihwa-gibon-inisyeolraijeo">구조체 초기화 :: 기본 이니셜라이저</span></h3>
<hr>
<ul>
<li>빈 이니셜라이저를 호출하면 지정한 기본값이 새 인스턴스의 프로퍼티로 설정된다.</li>
<li><strong>멤버와이즈 이니셜라이저</strong>는 값이 필요한 모든 저장형 프로퍼티의 인수를 담당한다. 자동으로 처리된다.</li>
</ul>
<br>
<h3><span id="gujoce-cogihwa-keoseuteom-inisyeolraijeo">구조체 초기화 :: 커스텀 이니셜라이저</span></h3>
<hr>
<ul>
<li>초기화 과정을 세부적으로 건드려야 할 상황일때 사용한다.</li>
<li>커스텀 이니셜라이저를 사용하면 기존 <em>빈 이니셜라이저는 제공되지 않는다</em>.</li>
<li><code>init</code>키워드를 통해</li>
</ul>
<br>
<h4><span id="code">CODE</span></h4>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomInit</span> </span>&#123; <span class="comment">//참조타임</span></span><br><span class="line">    <span class="keyword">var</span> name:<span class="type">String</span></span><br><span class="line">    <span class="keyword">init</span>(name:<span class="type">String</span>) &#123; <span class="comment">//parameter</span></span><br><span class="line">        <span class="comment">//statement</span></span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="keulraeseu-cogihwa-gibon">클래스 초기화 :: 기본</span></h3>
<hr>
<ul>
<li>빈 기본 이니셜라이저를 가진다. <code>let mem = Member()</code></li>
<li>구조체와 다르게 멤버와이즈 <em>이니셜라이저를 가지지 않는다</em>. 참조타입이기 때문이다. 따라서 클래스는 기본값을 지정해야한다.</li>
<li>일반적으로 클래스는 <u>슈퍼클래스의 이니셜라이저를 상속하지 않는다</u>. (새로 추가된 서브클래스 타입의 프로퍼티가 값을 갖지 않은 채로 제공되지 않게 하기 위해서!)</li>
<li>하지만 <strong>부분적으로</strong> 이니셜라이저를 상속하는 경우가 있다.
<ul>
<li>서브 클래스에 지정형 이니셜라이저가 정의되어 있지 않다면, 슈퍼클래스의 지정형 이니셜라이저를 상속한다.</li>
<li>서브 클래스에 슈퍼클래스의 모든 지정형 이니셜라이저가 구현되어 있다면 명시적인 방법이든 상속을 통해서든 슈퍼클래스의 모든 편의성 이니셜라이저를 상속한다.</li>
</ul>
</li>
</ul>
 <br>
<h3><span id="keulraeseu-cogihwa-jijeonghyeong-inisyeolraijeo">클래스 초기화 :: 지정형 이니셜라이저</span></h3>
<hr>
<ul>
<li>클래스의 주 이니셜라이저 형태이다. 모두 초기화 완료 전에 값을 받는지 확인한다.</li>
<li>슈퍼클래스가 지정된 클래스의 지정형 이니셜라이저는 <u>슈퍼클래스의 지정형 이니셜라이저도 함께 호출</u>해야 한다.</li>
</ul>
 <br>
<h3><span id="keulraeseu-cogihwa-pyeonyiseong-inisyeolraijeo">클래스 초기화 :: 편의성 이니셜라이저</span></h3>
<hr>
<ul>
<li><code>convenience</code> 키워드를 사용한다.</li>
<li>다른 이니셜라이저에 자신이 정의된 목적 등을 전달한다.</li>
<li>이니셜라이저는 같은 클래스의 다른 이니셜라이저를 호출할 수 있다.</li>
<li>클래스의 저장형 프로퍼티가 초깃값을 받는 방법의 정의라 할 수 있다.</li>
</ul>
<p><img src="/image/convenience.png" alt="편의성이니셜라이저"></p>
<br>
<h3><span id="keulraeseu-cogihwa-yoguhyeong-inisyeolraijeo">클래스 초기화 :: 요구형 이니셜라이저</span></h3>
<hr>
<ul>
<li><code>required</code>키워드를 붙여 이 타입의 모든 서브클래스에서 해당 이니셜라이저를 제공할 수 있다.</li>
<li>서브클래스들은 요구형으로 지정된 이니셜라이저를 구현해야 한다.</li>
<li><code>override</code> 키워드를 붙일 수 없다.</li>
</ul>
<br>
<h3><span id="haeje-deinitializer">해제(Deinitializer)</span></h3>
<hr>
<ul>
<li>해제는 인스턴스가 더 이상 필요하지 않을 때 <em>메모리에서 제거하는 과정</em>을 가리킨다.</li>
<li>디이니셜라이저는 인스턴스가 메모리에서 <strong><em>제거되기 바로 직전</em></strong>에 호출된다. 메모리 할당이 취소되기 전에 최종 관리를 위한 여유를 제공하는 것으로 생각할 수 있다.</li>
<li><code>deinit</code> 키워드로 정의되며, class 안에서 쓰인다.</li>
<li>해제될 수 있는 인스턴스는 옵셔널로 지정한다. (삭제되면 nil이 되므로)</li>
</ul>
<br>
<h4><span id="code">CODE</span></h4>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">deinit</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\(name)</span>'s memory is Deinitialized"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>
<h3><span id="silpae-gineung-inisyeolraijeo-failable">실패 기능 이니셜라이저 (failable)</span></h3>
<hr>
<ul>
<li>인스턴스를 <em>초기화할 수 없다</em>는 사실을 알리는 기능을 한다.</li>
<li>쓰이는 이유는 nil로 설정된 인스턴스가 프로퍼티에 잘못된 데이터가 채워진 인스턴스보다 훨씬 낫기 때문이다.</li>
<li>유효하지 않은 파라미터를 받거나 (인구수인데 음수를 받는다던가) 리소스가 존재하지 않아서 인스턴스를 만들 수 없을 때 -&gt; nil을 리턴한다.</li>
<li><code>init?</code> 키워드로 표기한다.</li>
<li><code>init!</code> 키워드는 암묵적으로 언래핑되는 옵셔널을 리턴하는 페일어블 이니셜라이저를 만들 수도 있다. (단, 안정성이 떨어지므로 주의요함)</li>
</ul>
<br>
<h3><span id="cogihwayi-gwajeong">초기화의 과정</span></h3>
<hr>
<p>1단계. 최종적으로 클래스의 지정형 이니셜라이저가 호출된다.</p>
<ul>
<li>선언된 모든 프로퍼티가 지정형 이니셜라이저의 정의 내 적절한 값으로 초기화 되도록 담보한다.</li>
<li>그 지정형 이니셜라이저는 자신의 슈퍼클래스의 지정형 이니셜라이저에 위임을 한다.</li>
<li>슈퍼클래스의 지정형 이니셜라이저는 자신의 모든 지정형 프로퍼티가 적절한 값으로 초기화되도록 담보한다.</li>
</ul>
<p>2단계. 클래스에 그 저장형 프로퍼티의 값을 이렇게 저렇게 다룰 수 있는 기회를 제공한다.<br>
3최종단계. 두 단계를 거치며 온전하게 초기화되며, 모든 프로퍼티와 메소드는 사용될 준비를 끝낸다.</p>
<br>
]]></content>
      
        <categories>
            
            <category> SWIFT </category>
            
        </categories>
        
        
        <tags>
            
            <tag> initalizer </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CH16. Property]]></title>
      <url>/2017/11/01/chap16-property/</url>
      <content type="html"><![CDATA[<h1><span id="chapter16-property">CHAPTER16 / Property</span></h1>
<h2><span id="peuropeoti">프로퍼티</span></h2>
<hr>
<ul>
<li>값과 타입을 연계 내지 연동하는 방식으로 타입이 나타내는 엔터티(entity) 특징을 구체화한다.</li>
<li><strong>저장형 프로퍼티</strong>는 기본값을 가진다.</li>
<li><strong>계산형 프로퍼티</strong>는 사용 가능한 정보에 따라 계산한 결과를 리턴한다.</li>
<li>프로퍼티 가시성에 관해 규칙을 세울 수도 있다.</li>
</ul>
<br>
<h3><span id="jeojanghyeong-peuropeoti">저장형 프로퍼티</span></h3>
<hr>
<ul>
<li><strong>저장형 프로퍼티</strong>가 하는 일은 데이터 저장이다.</li>
<li><code>let</code>(상수)는 읽기전용 프로퍼티이다.</li>
<li><code>var</code>(변수)는 읽기/쓰기용 프로퍼티이다.</li>
<li>중첩타입은 어떤 타입 안에서 정의된 타입이다. 주로 어떤 타입의 기능을 지원할 목적으로 사용된다.</li>
</ul>
<br>
<h3><span id="jiyeon-jeojanghyeong-peuropeoti-lazy">지연 저장형 프로퍼티 (lazy)</span></h3>
<hr>
<p>경우에 따라서 저장형 프로퍼티의 값이 곧바로 지정될 수 없을 때도 있다.<br>
혹은 만약 해당 프로퍼티의 인스턴스가 메모리를 많이 먹는다면 필요할 때 생성되도록(lazy) 선언해 두면 <strong>메모리 관리 효율</strong>이 좋아질 것이다.</p>
<ul>
<li>곧 바로 프로퍼티의 값을 계산하려면 메모리나 시간적 측면에서 낭비일 경우.</li>
<li>인스턴스가 만들어져야 알 수 있는 타입의 외적 요소에 프로퍼티가 의존하는 경우.<br>
위 와 같은 경우를 <strong>지연로딩(lazy loading)</strong> 이라고 부른다.
<ul>
<li>프로퍼티의 값이 필요해야 계산한다. 따라서 <u>인스턴스가 초기화되고 나서야 계산</u>되며, 추후에 값이 변경되므로 <code>var</code>로 정의해야 한다.</li>
</ul>
</li>
</ul>
<br>
<h4><span id="code-basic">CODE :: Basic</span></h4>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Beef</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> price = <span class="number">3000</span></span><br><span class="line">    <span class="keyword">var</span> weight = <span class="number">30</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Size</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> small</span><br><span class="line">        <span class="keyword">case</span> medium</span><br><span class="line">        <span class="keyword">case</span> large</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//지연 프로퍼티</span></span><br><span class="line">    <span class="comment">// 클로저를 이용하여 값 할당</span></span><br><span class="line">    <span class="comment">// ()로 끝남으로써 beefSize가 처음 엑세스될 때 클로저가 리턴한 결과를 beefSize에 지정한다.</span></span><br><span class="line"></span><br><span class="line">     <span class="built_in">lazy</span> <span class="keyword">var</span> beefSize: <span class="type">Size</span> = &#123;</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span>.weight &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>...<span class="number">20</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="type">Size</span>.small</span><br><span class="line">        <span class="keyword">case</span> <span class="number">21</span>...<span class="number">40</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="type">Size</span>.medium</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="type">Size</span>.large</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>클로저는 <code>self.</code>를 참조해야 내부에서 인스턴스의 <code>weight</code> 프로퍼티에 액세스가 가능하다.<br>
<code>lazy</code>를 생략하고 <code>self.</code>를 사용할 시에는, 컴파일에러가 나는데,<br>
그 이유는 클로저가 안전하게 <code>self.</code>에 엑세스하기 위해서 <em>컴파일러는 <code>self.</code>가 온전히 초기화되었는지</em> 알고 있어야 한다.<br>
<code>lazy</code>를 붙이므로써 지금 당장 <code>self.</code>에 해당하는 값이 만들어질 필요가 없으며, 처음 엑세스 될 때 만들어 져야한다고 파악하여 <strong>ready</strong>상태에 있게 된다.</p>
<br>
<h4><span id="code-aegseseu">CODE :: 액세스</span></h4>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> newBeef = <span class="type">Beef</span>()</span><br><span class="line"><span class="keyword">var</span> newBeefWeight = newBeef.weight</span><br><span class="line">newBeefWeight = <span class="number">50</span></span><br><span class="line"><span class="built_in">print</span>(newBeef.beefSize)     <span class="comment">//출력 : medium</span></span><br></pre></td></tr></table></figure>
<p>위 와 같이 생성후 인스턴스의 <code>weight</code>값을 변경 시켜 주었으나,<br>
이미 첫 초기화 될 때 <code>beefSize</code>프로퍼티가 지정되었다.</p>
<br>
<h4><span id="code-sae-gabseuro-cogihwa-hu-jaeseoljeong">CODE :: 새 값으로 초기화 후 재설정</span></h4>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> secondBeef = <span class="type">Beef</span>.<span class="keyword">init</span>(price: <span class="number">2000</span>, weight: <span class="number">50</span>, beefSize: <span class="literal">nil</span>)</span><br><span class="line"><span class="built_in">print</span>(secondBeef.beefSize) <span class="comment">//출력 : large</span></span><br></pre></td></tr></table></figure>
<br>
<h3><span id="gyesanhyeong-peuropeoti">계산형 프로퍼티</span></h3>
<hr>
<ul>
<li>값을 저장하지 않으며 <strong>게터(getter)</strong>,<strong>세터(setter)</strong> 라는 것을 제공한다.</li>
<li><strong>게터</strong>는 프로퍼티의 값을 가져온다. (읽기용)</li>
<li><strong>세터</strong>는 값을 설정하여 프로퍼티의 값을 변경시킨다.(쓰기용) <em>단, 필수 요소는 아니다</em>.</li>
<li><em>read-only</em> 일지라도 <code>var</code> 키워드로 정의해야 한다.</li>
<li>getter,setter 모두 함수와 같이 상속시 <code>override</code>가 가능하다.</li>
<li>반드시 <strong>타입 정보를 명시</strong>해야 한다. 컴파일러가 게터가 <em>무엇을 리턴</em> 해야 하는지를 파악할 수 있게 하기 위해!</li>
</ul>
<h4><span id="code">CODE</span></h4>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Doubling</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">0</span></span><br><span class="line">    <span class="comment">//반드시 타입어노테이션을 해줘야 한다.</span></span><br><span class="line">    <span class="keyword">var</span> data: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> a + b</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> (value)&#123;</span><br><span class="line">            <span class="comment">//self를 통해서 엑세스</span></span><br><span class="line">            <span class="keyword">self</span>.a = value / <span class="number">2</span></span><br><span class="line">            <span class="keyword">self</span>.b = value / <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 클로저를 통해 인스턴스가 생성될 때 함께 실해오디어 초기값을 반환하며, 이후 재실행되지 않는다.</span></span><br><span class="line"><span class="keyword">var</span> age :<span class="type">Int</span> = &#123;</span><br><span class="line">  <span class="keyword">let</span> number = now() - birthDate()</span><br><span class="line">  <span class="keyword">return</span> number</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> doubling = <span class="type">Doubling</span>()</span><br><span class="line">doubling.data = <span class="number">80</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"a:<span class="subst">\(doubling.a)</span> , b: <span class="subst">\(doubling.b)</span>"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//출력 : a:40 , b: 40</span></span><br></pre></td></tr></table></figure>
<h4><span id="code-cugyaghyeong-getter-setter">CODE :: 축약형 getter, setter</span></h4>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// getter 축약형</span></span><br><span class="line">lass <span class="type">Doubling</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> data: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// setter 축약형 : newValue</span></span><br><span class="line">lass <span class="type">Doubling</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> data: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> a + b</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.a = newValue / <span class="number">2</span></span><br><span class="line">            <span class="keyword">self</span>.b = newValue / <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>getter 축약조건 : read-only로 정의하려는 경우</li>
<li>setter 축약조건 : 새 값에 명시적 이름을 붙이는 것 대신, <code>set</code>코드 내부에서 정의된 <code>newValue</code>라는 심볼이 쓰일 수 있다.</li>
</ul>
<br>
<h4><span id="code-overriding">CODE :: overriding</span></h4>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubDoubling</span>: <span class="title">Doubling</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> data: <span class="type">Int</span>&#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (a + b) * <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.a = newValue / <span class="number">2</span></span><br><span class="line">            <span class="keyword">self</span>.b = newValue / <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> subDoubling = <span class="type">SubDoubling</span>()</span><br><span class="line"><span class="built_in">print</span>(subDoubling.data)</span><br><span class="line"><span class="comment">// 출력 : 4</span></span><br></pre></td></tr></table></figure>
<br>
<h3><span id="peuropeoti-gwancalja-property-observer">프로퍼티 관찰자(Property Observer)</span></h3>
<hr>
<ul>
<li>프로퍼티의 변화를 추적해서 실시간으로 대응하고자 할 때 사용한다.</li>
<li><code>willSet</code> : 프로퍼티가 <strong>변경되기 직전에</strong> 실행된다. 즉, 프로퍼티의 이전값을 처리할 수 있는 방법</li>
<li><code>didSet</code> : 프로퍼티가 <strong>변경된 후</strong> 실행된다. 즉, 프로퍼티의 새 값을 처리할 수 있는 방법</li>
<li>옵저버 기능을 이용하면 <em>getter,setter 사용이 불가능</em> 한데, 이는 <u>getter,setter에서 옵저버 기능을 구현할 수 있기 때문</u>이다.</li>
</ul>
<h4><span id="code">CODE</span></h4>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObserverbingClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a: <span class="type">Int</span> = <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">willSet</span>(value) &#123;</span><br><span class="line">            <span class="built_in">println</span>(<span class="string">".a will change to <span class="subst">\(value)</span>"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">didSet</span> &#123;</span><br><span class="line">            <span class="built_in">println</span>(<span class="string">".a did changed to <span class="subst">\(<span class="keyword">self</span>.a)</span>"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="type">ObserverbingClass</span>()</span><br><span class="line">obj.a = <span class="number">10</span></span><br></pre></td></tr></table></figure>
<br>
<h3><span id="taib-peuropeoti-jeongjeog-peuropeoti">타입 프로퍼티 (정적 프로퍼티)</span></h3>
<hr>
<ul>
<li>인스턴스에 소속되지 않고 <strong>클래스와 구조체 자체에 소속</strong>되어 값을 가지는 프로퍼티.</li>
<li>모든 인스턴스들이 공유하고 있는 값으로 하나의 값이다.</li>
<li>타입 메서드가 참조할 수 있는 프로퍼티는 오직 타입 프로퍼티 뿐이다. (메모리상 같은 위치에 있기 때문! -&gt; Data Segment)</li>
<li>타입 프로퍼티는 메모리 내의 static 공간에 정의되어 있기 때문에</li>
<li>인스턴스에 소속되어있지 않기 때문에 <code>.</code> 구문으로 접근 불가능하다.</li>
<li>이름앞에 <code>static</code> 키워드를 붙여준다.</li>
<li>인스턴트 메서드와는 달리 <code>self</code>가 타입 자체를 가리킨다.</li>
<li>타입 프로퍼티의 값들은 타입의 인스턴스들 사이에서 모두 똑같이 취급될 정보를 저장한다.</li>
<li>타입은 이니셜라이저를 가지지 않기 때문에 <em>자신의 값을 콜러에게 전달하기 위해 필요한 모든 정보</em>를 가져야 한다.(초기값을 반드시 할당해야한다는 뜻)</li>
<li>정적 프로퍼티에는 <strong>정적 타입 프로퍼티</strong><code>static func</code> 와 <strong>클래스 타입 프로퍼티</strong><code>class func</code>가 존재한다.
<ul>
<li><code>static</code>타입 : 인스턴스화 없이 호출가능. <code>override</code> 불가능</li>
<li><code>class</code>타입 : 인스턴스화 없이 호출가능. <code>override</code> <strong>가능</strong> , 클래스의 프로퍼티에서만 사용 가능.
<ul>
<li><strong>클래스</strong>에서 연산 프로퍼티에만 붙일 수 있는 키워드.</li>
<li>즉, class 타입은 <strong>오버라이드가 가능한</strong> 정적 프로퍼티이다.<em>(class final = static 개념)</em></li>
<li>반면 값 타입(<code>enum</code>, <code>struct</code>)은 class 타입 프로퍼티를 쓸 수 없다. (상속할수 없기 때문에 <code>override</code> 불가)</li>
<li>class 내부에서는 static 메서드나 class 메서드가 같은 의미로 인식되기 때문에 <u> static 메서드 -&gt; class 메서드 , class 메서드 -&gt; static 메서드로 오버라이드 </u>는 가능하다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<br>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//swift에는 세가지 메서드 타입이 존재한다.</span></span><br><span class="line"><span class="comment">// 인스턴스 메서드, 스태틱메서드, 클래스 매서드</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KindOfClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">instanceMethod</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"instanceMethod"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">staticMethod</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"staticMethod"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">classMethod</span>() </span>&#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"classMethod"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">KindOfClass</span>.instanceMethod()      <span class="comment">//컴파일에러 -&gt; 인스턴스생성없이 접근불가.</span></span><br><span class="line"><span class="type">KindOfClass</span>.staticMethod()      <span class="comment">//출력 : staticMethod</span></span><br><span class="line"><span class="type">KindOfClass</span>.classMethod()        <span class="comment">//출력 : classMethod</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//override 가능유무</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">subClass</span>: <span class="title">KindOfClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">staticMethod</span><span class="params">()</span></span> &#123;       <span class="comment">// compile error : Cannot override static method</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"subClass :staticMethod : override성공! "</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">classMethod</span>() </span>&#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"subClass :classMethod : override성공! "</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">subClass.classMethod()      <span class="comment">//출력 : subClass :classMethod : override성공!</span></span><br></pre></td></tr></table></figure>
<br>
<h3><span id="egseseu-jeeo">엑세스 제어</span></h3>
<hr>
<ul>
<li>필요에 따라 프로퍼티의 가시성을 제어하여 숨기거나 드러낼 수 있다.</li>
<li>프로퍼티의 데이터를 <strong><em>캡슐화</em></strong>하여 외부 코드에서 건드리지 못하게 된다.</li>
<li>모듈(module)은 하나의 유닛으로 배포되는 코드다. ex) Foundation, Cocoa</li>
<li>소스(source)파일은 하나의 파일이며, 구체적인 모듈에 포함된다.</li>
<li>엑세스 제어는 소스와 모듈 중심으로 구성된다.</li>
<li>모듈은 <code>import</code>키워드를 통해 가져온다.</li>
</ul>
<br>
<p><img src="/image/access.png" alt="접근제어"></p>
<br>
<ul>
<li>일반적으로 어떤 타입의 엑세스 수준은 그 프로퍼티나 메서드의 액세스 수준과 일관되야 한다.</li>
<li><em>상위타입 접근 제한성</em> &gt; 타입의 프로퍼티의 접근 제한성</li>
<li>스위프트의 기본 제어 수준은 <strong><em>internal</em></strong> 이다. (선언생략 가능)</li>
<li>게터와 세터에 가시성을 따로따로 제어할 수 있다. BUT, 세터는 게터보다 가시성이 높을 수 없다.</li>
</ul>
<br>
<h3><span id="taib-kaeseuting">타입 캐스팅</span></h3>
<hr>
<p>제한된 범위 내에서 타입을 캐스팅할 수 있다.</p>
<ol>
<li>실제로 할당된 인스턴스 타입</li>
<li>인스턴스가 구현한 프로토콜 타입</li>
<li>클래스가 상속을 받았을 경우 모든 상위 클래스</li>
<li>프로토콜 타입이 상속을 받았을 경우 모든 상위 프로토콜</li>
</ol>
<br>
<h3><span id="keulraeseu-jeonyong-peurotokol">클래스 전용 프로토콜</span></h3>
<hr>
<ul>
<li><code>class</code> 키워드를 사용하여 클래스 전용 프로토콜임을 컴파일러에 알려주면 된다.</li>
</ul>
<br>
<h3><span id="optional">optional</span></h3>
<hr>
<ul>
<li>프로토콜 앞에 <code>@obj</code> 어노테이션을 붙인후 <code>optional</code> 키워드를 붙인다.</li>
</ul>
<br>
<hr>
<p><a href="https://medium.com/ios-development-with-swift/%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0-get-set-didset-willset-in-ios-a8f2d4da5514" target="_blank" rel="noopener">참조1</a><br>
<a href="http://seorenn.blogspot.kr/2014/06/swift-properties.html" target="_blank" rel="noopener">참조2</a><br>
<a href="https://medium.com/@miles3898/swift%EC%9D%98-static-%EB%A9%94%EC%84%9C%EB%93%9C%EC%99%80-class-%EB%A9%94%EC%84%9C%EB%93%9C-975d367c4c19" target="_blank" rel="noopener">static메서드와 class메서드</a></p>
]]></content>
      
        <categories>
            
            <category> SWIFT </category>
            
        </categories>
        
        
        <tags>
            
            <tag> getter </tag>
            
            <tag> setter </tag>
            
            <tag> static </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[분할정복]]></title>
      <url>/2017/11/01/sort-quick/</url>
      <content type="html"><![CDATA[<h1><span id="divide-and-conquer">Divide and Conquer</span></h1>
<h2><span id="bunhaljeongbog">분할정복</span></h2>
<hr>
<p>전체를 작은 범위로 <em>나누어서(Divide)</em> 각각 처리하고, 다시 <em>병합(Conquer)</em> 하여 문제의 답을 얻는 알고리즘이다.</p>
<br>
<blockquote>
<ol>
<li>Divide : 전체가 분할이 가능한 경우, 2개 이상의 문제로 나눈다.</li>
<li>Conquer : 나누어진 문제가 여전히 분할이 가능하면, 또 다시 Divide를 수행한다. 그렇지 않으면 문제를 수행한다.</li>
<li>Combine : Conquer한 문제들을 병합(Merge)하여 원래 구하고자했던 답을 도출한다.</li>
</ol>
</blockquote>
<br>
<h3><span id="habbyeong-jeongryeol-merge-sort">합병 정렬(Merge Sort)</span></h3>
<hr>
<p>배열을 계속 반으로 <em>분할</em> 하여 각각 따로 정렬한 후, <em>다시 병합</em> 하며 정렬하는 방식이다.</p>
<br>
<h4><span id="logic">LOGIC</span></h4>
<ol>
<li>Divde : 배열을 n/2로 분할한다.</li>
<li>Conquer : 정렬함으로써 각 부분을 정복한다(solve). 배열이 충분히 작지 않으면 재귀호출을 한다.</li>
<li>Combine : 부분배열에 대한 답들을 합병하여 하나의 정렬된 배열을 만든다.</li>
</ol>
<br>
<h4><span id="siganbogjabdo">시간복잡도</span></h4>
<h4><span id="gongganbogjabdo">공간복잡도</span></h4>
<h4><span id="code-swift">CODE :: swift</span></h4>
<br>
<h3><span id="kwig-jeongryeol-quick-sort">퀵 정렬(Quick Sort)</span></h3>
<hr>
<p>기준원소(pivot)을 선정하고, 기준원소보다 작은 원소는 모두 <strong>왼쪽배열</strong>로, 기준원소보다 큰 원소는 모두 <strong>오른쪽배열</strong>로 가도록 분할한다. 분할된 범위를 각각 따로 정렬한 후 다시 병합하여 정렬한다.</p>
<ul>
<li>
<h2><span id="deiteo-jeongryeol-sangtaee-ddara-seongneungyi-yeonghyangeul-badneunda">데이터 정렬 상태에 따라 성능의 영향을 받는다.</span></h2>
</li>
</ul>
<br>
<h4><span id="logic">LOGIC</span></h4>
<ol>
<li>Divde : 배열을</li>
<li>Conquer : 정렬함으로써 각 부분을 정복한다(solve). 배열이 충분히 작지 않으면 재귀호출을 한다.</li>
<li>Combine : 부분배열에 대한 답들을 합병하여 하나의 정렬된 배열을 만든다</li>
</ol>
<h4><span id="siganbogjabdo">시간복잡도</span></h4>
<h4><span id="gongganbogjabdo">공간복잡도</span></h4>
<h4><span id="code-swift">CODE :: swift</span></h4>
]]></content>
      
        <categories>
            
            <category> ALGORISM </category>
            
        </categories>
        
        
        <tags>
            
            <tag> merge </tag>
            
            <tag> quick </tag>
            
            <tag> 분할정복 </tag>
            
            <tag> sort </tag>
            
            <tag> 재귀함수 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CH15. Structure & Class]]></title>
      <url>/2017/10/30/chap15-struct-Class/</url>
      <content type="html"><![CDATA[<h1><span id="chapter15-structure-amp-class">CHAPTER15 / Structure &amp; Class</span></h1>
<h2><span id="gujocewa-keulraeseu">구조체와 클래스</span></h2>
<hr>
<p>구조체와 클래스는 하나의 큰 코드 블록으로써 <u>다른 종류의 객체에 의존하지 않고 자체적으로 값을 저장하거나 함수적인 기능을 구현</u>할 수 있다. 구조체나 클래스 내부에서 정의된 변수는 <strong>프로퍼티(Properties)</strong>, 함수는 **메서드(Method)**라고 불린다. 특별한 성격을 갖게 되기 때문이다. (이 둘을 가리켜 멤버라고 한다.)</p>
<p>이때 클래스나 구조체를 통해 메모리 공간을 할당받아 생성된 것을 <em>인스턴스</em>라고 한다.</p>
<br>
<h3><span id="gujoce-struc">구조체(Struc)</span></h3>
<hr>
<ul>
<li>클래스 인스턴스가 전달될 때에는 <strong>복사에 의해 전달</strong>된다. (값타입)</li>
<li>데이터를 어떤 하나의 타입에 두고 싶을 때 사용한다.(하나의 타입으로 캡슐화 됨)</li>
<li>구조체와 열거형은 <strong>값 타입</strong>이기 때문에 기본적으론 프로퍼티 변경이 불가하다, 인스턴스의 프로퍼티 값을 변경할 메서드에는 <code>mutating</code> 키워드가 붙어야 한다. (단, 클래스 내의 메서드는 참조타입이므로 기본적으로 mutating이며 변경하면 해당 인스턴스를 가리키는 모든 값이 변경된다.)</li>
<li>대입 명령 시 내용이 복사된다. (단 데이터 변동이 없으면 레퍼런스 대입 형태로 동작한다)</li>
<li>참조 카운트가 없어서 메모리 관리에 안전하다.</li>
<li>레퍼런스 형태가 아니기 때문에 공유가 불가능하다.</li>
<li>멀티스레딩에 안전하다. (임의로 변경되지 않기 때문)</li>
<li>상속이 불가능하다. 하지만 프로토콜은 사용 할 수 있다.</li>
<li>캡슐화된 데이터에 상속이 필요하지 않거나, 원본 데이터를 보존해야할 때 쓰인다.</li>
</ul>
<br>
<h4><span id="code">CODE</span></h4>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Market</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> price = <span class="number">1500</span></span><br><span class="line">    <span class="keyword">var</span> product = <span class="string">"Beef"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 값 타입이기 때문에 mutating 키워드가 붙어야 한다.</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">changePrice</span><span class="params">(raise: Int)</span></span>  &#123;</span><br><span class="line">        price += raise</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> newMarket = <span class="type">Market</span>()</span><br><span class="line">newMarket.changePrice(raise: <span class="number">500</span>)</span><br><span class="line"><span class="built_in">print</span>(newMarket.product)    <span class="comment">// 출력 :beef</span></span><br><span class="line"><span class="built_in">print</span>(newMarket.price)      <span class="comment">// 출력 :2000</span></span><br></pre></td></tr></table></figure>
<br>
<h5><span id="structreul-sseumyeon-yurihan-gyeongu">Struct를 쓰면 유리한 경우</span></h5>
<hr>
<ul>
<li>불변성(Immutable)이 필요한 데이터 타입</li>
<li>적은 데이터, 즉 멤버 프로퍼티의 갯수나 차지하는 메모리 용량이 적은 타입</li>
<li>대입 보다는 생성되는 경우가 많은 타입</li>
<li>공유될 필요가 없는 타입</li>
<li>클래스 타입 등 레퍼런스에 기반한 자료형을 저장용 프로퍼티로 쓰지 않는 경우</li>
</ul>
<br>
<h3><span id="keulraeseu-class">클래스(Class)</span></h3>
<hr>
<ul>
<li>클래스 인스턴스가 전달될 때에는 <strong>참조 형식으로 제공</strong>되며, 이때 참조 가능 개수는 무제한이다.</li>
<li>실행시 컴파일러가 클래스 인스턴스의 타입을 미리 파악하고 검사할 수 있다. (<strong>타입 캐스팅 가능</strong>)</li>
<li><strong>소멸화 구문</strong>을 사용하여 인스턴스가 소멸 직전에 처리해야할 구문을 미리 등록해 놓을 수 있다.</li>
<li>Class 타입에서만 AnyObject로의 캐스팅이 //다시수정</li>
<li>구조체와는 다르게 <strong>상속</strong> 으로 인해 매우 <em>일반적인 관점</em> 에서 정의된다.
<ul>
<li><code>final</code> 키워드는 하위 클래스에서 <strong>오버라이딩되는 것을 차단</strong>할 수 있다.</li>
<li>오버라이딩을 통해 충분히 확장이 가능하며, 이는 상위 클래스가 모든 기능을 완벽하게 갖출 필요가 없다는 것을 의미한다.</li>
<li>상속(inheritance) : 한 클래스가 다른 클래스 안에서 정의되는 관계. <strong><em>클래스 타입만이 상속이 가능하다</em></strong></li>
<li>상속으로 정의된 클래스는 <strong>서브클래스</strong> 라고 부르며, 이 서브클래스를 포함한 클래스를 <strong>슈퍼클래스</strong> 라고 부른다.</li>
<li>서브클래스는 슈퍼클래스의 <em>프로퍼티와 메서드</em> 를 상속한다.</li>
<li>오버라이드 (<strong>override</strong>) : 슈퍼클래스에 정의된 메서드를 다시 정의한다는 뜻이다.
<ul>
<li>오버라이드 막기 : 오버라이드를 금지해야 할 경우에 <strong>final</strong> 키워드나 <strong>static</strong> 키워드를 사용한다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<br>
<h4><span id="code-superclass">CODE :: SuperClass</span></h4>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">getBaby</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> eyeColor: <span class="type">String</span> = <span class="string">"black"</span></span><br><span class="line">    <span class="keyword">var</span> age = <span class="string">"1"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">born</span><span class="params">(Color:String)</span></span>  &#123;</span><br><span class="line">        eyeColor = <span class="type">Color</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"<span class="subst">\(eyeColor)</span> 눈동자인 <span class="subst">\(age)</span>살 애기가 태어났습니다."</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="code-subclass">CODE :: Subclass</span></h4>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">newBaby</span>: <span class="title">getBaby</span> </span>&#123; <span class="comment">//getBaby 클래스를 상속</span></span><br><span class="line">    <span class="comment">//name 프로퍼티를 추가</span></span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">"hyunah"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//born 함수를 override</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">born</span><span class="params">(Color: String)</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"<span class="subst">\(Color)</span>색 눈동자 입니다. "</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//부모class의 born 메소드를 의미한다</span></span><br><span class="line">        <span class="keyword">super</span>.born(<span class="type">Color</span>: <span class="string">"yellow"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hyun = newBaby()</span><br><span class="line">hyun.born(<span class="type">Color</span>: <span class="string">"pink"</span>)  </span><br><span class="line"></span><br><span class="line"><span class="comment">//출력 : pink색 눈동자 입니다.</span></span><br><span class="line"><span class="comment">//ellow 눈동자인 1살 애기가 태어났습니다.</span></span><br></pre></td></tr></table></figure>
<br>
<h3><span id="we-use-struct-this-situation">We use <em>Struct</em> this situation</span></h3>
<hr>
<ol>
<li>값을 전달하는 타입이 필요하면</li>
<li>서브클래스에서 상속해야 하는 타입이 아니라면</li>
<li>타입으로 표현해야 할 동작이 비교적 직관적이고 단순 값 몇 가지를 포함하는 경우 (추후에 Class 타입으로 변경해도 된다!)</li>
</ol>
<blockquote>
<p><u>참조 타입의 장점을 분명하게 원하는 경우</u>가 아니라면 <strong>구조체</strong>로 시작하는 것을 권장한다.</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> SWIFT </category>
            
        </categories>
        
        
        <tags>
            
            <tag> class </tag>
            
            <tag> structure </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CH14. Enumeration]]></title>
      <url>/2017/10/30/chap14-enum/</url>
      <content type="html"><![CDATA[<h1><span id="chapter14-enumeration">CHAPTER14 / Enumeration</span></h1>
<h2><span id="yeolgeohyeong">열거형</span></h2>
<hr>
<p>swift가 제공하는 자신만의 타입을 만들 수 있는 기능으로 줄여서 <code>enum</code>으로 표기한다.<br>
<u>리스트 형태로 정의된 여러 케이스(case)로 인스턴스</u>를 만들 수 있는 방법이다.</p>
<ul>
<li>열거형 타입의 이름은 <strong>대문자</strong>로 시작하는 것이 관례! ( 변수,함수, 열거형 케이스는 소문자로 시작 )</li>
<li><strong>케멀케이스</strong>로 네이밍을 한다.</li>
<li>컴파일러가 타입추론이 가능할 경우 타입을 생략 가능하다</li>
</ul>
<br>
<h3><span id="switchreul-sayonghan-enum">switch를 사용한 Enum</span></h3>
<hr>
<ul>
<li>모든 경우의 수에 케이스를 하나씩 포함하여 소모적인 <code>switch</code>로 작성하는 것을 권장한다.</li>
<li>열거형의 <code>switch</code>문에서는 <code>default</code>가 필수가 아니다. 컴파일러가 이미 모든 가능한 값을 알고 있기 때문이다.</li>
<li>열거형 타입에는 <code>default</code>를 쓰지 않는 것을 권장한다. 모든 논리적 허점을 막아줄 수 없기 때문이다.</li>
<li>새로 케이스를 추가할 경우 컴파일러는 자동으로 업데이트 할 곳을 모두 표시해준다.</li>
</ul>
<br>
<h3><span id="weonsigabs-raw-value">원시값(raw Value)</span></h3>
<hr>
<ul>
<li>변수에 일일히 열거형을 담아 처리하는 함수를 만들지 않아도 <code>rawValue</code>를 사용하면 변수를 해당 원시값으로전환할 수 있다.</li>
<li>원시값을 통해서 Enum을 생성가능하다.</li>
<li>컴파일러가 자동으로 지정된 값을 기준으로 +1씩 증가되어 rawValue값이 지정된다.</li>
<li>원시값이 <em>Int형</em>인데 원시값이 생략되었을 경우, 0,1,2… 순으로 rawValue값이 지정된다.</li>
<li>원시값이 <em>String형</em>인데 원시값이 생략되었을 경우 <em>케이스 자체의 이름</em>이 rawValue값이 지정된다.</li>
</ul>
<br>
<h4><span id="code-basic">CODE :: Basic</span></h4>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Month</span>: <span class="title">Int</span> </span>&#123;  <span class="comment">//타입은 반드시 기재안해도 됨.</span></span><br><span class="line">    <span class="keyword">case</span> january = <span class="number">1</span></span><br><span class="line">    <span class="keyword">case</span> feburary</span><br><span class="line">    <span class="keyword">case</span> march</span><br><span class="line">    <span class="keyword">case</span> april</span><br><span class="line">    <span class="keyword">case</span> may</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">toString</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123; <span class="comment">//self = Month 객체자신</span></span><br><span class="line">        <span class="keyword">case</span> .january:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"1월"</span></span><br><span class="line">        <span class="keyword">case</span> .feburary:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"2월"</span></span><br><span class="line">        <span class="keyword">case</span> .march:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"3월"</span></span><br><span class="line">        <span class="keyword">case</span> .april:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"4월"</span></span><br><span class="line">        <span class="keyword">case</span> .may:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"5월"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> whatMonth: <span class="type">Month</span> = .feburary</span><br><span class="line"><span class="built_in">print</span>(whatMonth)    <span class="comment">//출력 : feburary</span></span><br><span class="line"><span class="built_in">print</span>(whatMonth.rawValue)     <span class="comment">//출력 : 2 (원시값)</span></span><br><span class="line"><span class="built_in">print</span>(whatMonth.<span class="built_in">toString</span>())  <span class="comment">// 출력: 2월</span></span><br></pre></td></tr></table></figure>
<br>
<h4><span id="code-weonsigabs-gt-enum-casero-jeonhwan">CODE :: 원시값 -&gt; Enum Case로 전환</span></h4>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 원시값 생성</span></span><br><span class="line"><span class="keyword">let</span> turnToCase = <span class="number">5</span></span><br><span class="line"><span class="comment">// 생성된 원시값에 해당하는 case가 없을 수 있으므로 옵셔널 바인딩</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> toCase = <span class="type">Month</span>(rawValue: turnToCase) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"case : <span class="subst">\(toCase)</span>"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"전환실패"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 일반 열거형 생성</span></span><br><span class="line"><span class="keyword">let</span> whatMonth: <span class="type">Month</span> = .may</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"case : <span class="subst">\(whatMonth)</span>"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//출력 결과상동 : case : may</span></span><br></pre></td></tr></table></figure>
<br>
<h3><span id="gabstaib-value-type-meseodeu">값타입(value type) 메서드</span></h3>
<hr>
<p>swift에서 열거형은 <strong>값 타입</strong>이며, 값 타입의 메서드는 <em>self를 변경 불가능</em>하다.<br>
따라서 메서드가 self를 변경하려고 하면 <code>Cannot assign to value : self is immutable</code> 이라는 컴파일 에러가 발생한다. 즉, 메서드에 <code>mutating</code> 이라는 키워드를 붙여야 한다.</p>
<h4><span id="code">CODE</span></h4>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">button</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> on</span><br><span class="line">    <span class="keyword">case</span> off</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">surfaceTemperature</span> <span class="params">(temp: Double)</span></span> -&gt; <span class="type">Double</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> .on:</span><br><span class="line">            <span class="keyword">return</span> temp + <span class="number">36.5</span></span><br><span class="line">        <span class="keyword">case</span> .off:</span><br><span class="line">            <span class="keyword">return</span> temp * <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// on,off케이스를 전환해주는 함수 생성</span></span><br><span class="line">    <span class="comment">// 값자체를 변경 가능하도록 mutating을 붙여줘야 한다.</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">toggle</span> <span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">switch</span>  <span class="keyword">self</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> .on:</span><br><span class="line">            <span class="keyword">self</span> = .off</span><br><span class="line">        <span class="keyword">case</span> .off:</span><br><span class="line">            <span class="keyword">self</span> = .on</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 값이 변경 가능하도록 let이 아닌 var로 선언</span></span><br><span class="line"><span class="keyword">var</span> bulb:button = .on</span><br><span class="line">bulb.toggle()</span><br><span class="line"><span class="built_in">print</span>(bulb) <span class="comment">// case : on -&gt; off</span></span><br></pre></td></tr></table></figure>
<br>
<h3><span id="yeongwangabs-associated-values">연관값(Associated Values)</span></h3>
<hr>
<p>데이터를 열거형의 인스턴스에 연동할 수 있고, 그럼으로써 케이스마다 다른 연동값을 가질 수 있다.</p>
<h4><span id="code">CODE</span></h4>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//연관값</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">dimension</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 점은 연동값이 없다.</span></span><br><span class="line">    <span class="keyword">case</span> point</span><br><span class="line">    <span class="keyword">case</span> square(side: <span class="type">Int</span>)</span><br><span class="line">    <span class="keyword">case</span> rectangle(width: <span class="type">Int</span>, height: <span class="type">Int</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">area</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">          <span class="comment">// self의 연동값을 새 변수들에 바인딩 했다.</span></span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">let</span> .square(side: side):</span><br><span class="line">            <span class="keyword">return</span> side * side</span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">let</span> .rectangle(width: w, height:h):</span><br><span class="line">            <span class="keyword">return</span> w * h</span><br><span class="line">        <span class="keyword">case</span> .point:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> rectangleObj:dimension = .rectangle(width: <span class="number">5</span>, height: <span class="number">6</span>)</span><br><span class="line"><span class="built_in">print</span>(rectangleObj.area())</span><br></pre></td></tr></table></figure>
<br>
<h3><span id="jaegwijeog-yeolgeohyeong">재귀적 열거형</span></h3>
<hr>
<p>데이터 구조 중 트리(Tree)에서 쓰일 수 있다.<br>
case에서 연관값으로 자기 자신타입이 재귀된다면 컴파일러는 Enum의 크기를 가늠하기 어려워 지며, <em>메모리를 무한대로 요구</em>하게 된다.<br>
대신 <u> <code>indirect</code>키워드가 붙게 되면, 열거형의 데이터가 포인터 뒤에 저장</u>된다.<br>
즉, 열거형의 인스턴스에 데이터가 담길 충분한 메모리를 제공하지 않고 메모리 내 다른 공간에 데이터를 둔다. 메모리 관리 차원에서 반드시 필요한 부분이다.<br>
또한 <code>indirect</code> 키워드는 case에 개별적으로 붙일 수있다.</p>
<br>
<h3><span id="obsyeoneolgwa-enum">옵셔널과 Enum</span></h3>
<hr>
<p>옵셔널은 Enum이다.<br>
옵셔널의 구조를 보면 아래와 같다.</p>
<h4><span id="code-obsyeoneol-naebugujo">CODE :: 옵셔널 내부구조</span></h4>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Optional</span>&lt;<span class="title">wrapped</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">case</span> some(wrapped)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>
<h4><span id="code-obsyeoneoleseo-enumgujo-hwalyong">CODE :: 옵셔널에서 Enum구조 활용</span></h4>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> height:<span class="type">Int</span>? = <span class="number">165</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> height &#123;</span><br><span class="line"><span class="keyword">case</span> .<span class="keyword">none</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"nothing"</span>)</span><br><span class="line"><span class="keyword">case</span> .some(<span class="keyword">let</span> x) <span class="keyword">where</span> x &lt; <span class="number">150</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"키가 작습니다"</span>)</span><br><span class="line"><span class="keyword">case</span> .some(<span class="keyword">let</span> x) <span class="keyword">where</span> x &lt; <span class="number">170</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"키가 적당합니다"</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"키가 큽니다"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>따라서 옵셔널은 Enum 타입이기 때문에 위와 같이 <code>switch</code>문 적용이 가능하다.</p>
<br>
<br>
<p><a href="https://devxoul.gitbooks.io/ios-with-swift-in-40-hours/content/Chapter-3/enums.html" target="_blank" rel="noopener">참고 사이트</a></p>
]]></content>
      
        <categories>
            
            <category> SWIFT </category>
            
        </categories>
        
        
        <tags>
            
            <tag> enum </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[함수형 프로그래밍]]></title>
      <url>/2017/10/27/functionalProgramming/</url>
      <content type="html"><![CDATA[<h1><span id="functional-programming">Functional Programming</span></h1>
<h2><span id="hamsuhyeong-peurogeuraemingiran">함수형 프로그래밍이란?</span></h2>
<br>
<h3><span id="mutatable-han-sangtaereul-immutableyi-sangtaero-mandeuleo-sideeffectreul-eobsaeja"># mutatable 한 상태를 immutable의 상태로 만들어 sideEffect를 없애자</span></h3>
<hr>
<ul>
<li>값이 변경되지 않도록 변수(var)보다는 **상수(let)**를 선호한다.</li>
<li>함수에 어떤 값을 넣으면 일정한 결과값이 나와야하는데, 함수안에서 상태를 관리하고 상태에 따라서<br>
결과값이 달리지면 안된다.</li>
</ul>
<br>
<h3><span id="modeungeoseun-gaegceida"># 모든것은 객체이다</span></h3>
<hr>
<ul>
<li>
<p>변수나 데이터에 할당 할 수 있어야한다.</p>
</li>
<li>
<p>객체의 *인자(parametor)*로 넘길 수 있어야 한다.</p>
</li>
<li>
<p>객체의 리턴값으로 <em>리턴할 수</em> 있어야 한다.</p>
</li>
<li>
<p>위 3가지를 만족시키는 함수가 *1급객체(First-class-citizen)*라고 한다</p>
</li>
<li>
<p><em>함수를 파라미터</em>로 전달받거나 , <em>함수를 리턴</em>하는 함수를 <strong>고차함수 (higher-order function)</strong> 이라고 한다.</p>
</li>
</ul>
<br>
<h3><span id="kodeureul-gangyeolhage-hago-gadogseongeul-nopyeo-rojige-jibjungsikyeoya-handa"># 코드를 간결하게 하고 가독성을 높여 로직에 집중시켜야 한다.</span></h3>
<br>
<h3><span id="dongsiseong-jageobeul-boda-swibgo-anjeonhage-guhyeonhaja"># 동시성 작업을 보다 쉽고 안전하게 구현하자.</span></h3>
<hr>
<ul>
<li><strong>immutable값</strong>을 통해 여러 쓰레드에서 접근을 하더라도 <strong>sideEffect</strong>를 일으키지 않도록 한다.</li>
<li>그러면 Lock, unLock 같은 보호 장치가 필요없다.</li>
</ul>
<h3><span id="ilgeub-hamsu-first-class-function-yi-teugseong">일급 함수(First-class-function)의 특성</span></h3>
<p>함수형 언어에서는 <strong>함수가 일급 객체로 대우</strong>받는다. 따라서 swift에서는 함수가 다음과 같은 특성을 갖게 된다.</p>
<hr>
<ul>
<li>함수가 런타임에도 생성가능해야 한다.</li>
<li>인자값으로 함수를 전달할 수 있어야 한다.</li>
<li>리턴값으로 함수를 사용할 수 있어야 한다. (Ex, 콜백함수, 클로저)</li>
<li>변수나 데이터 구조 안에 저장할 수 있어야 한다.</li>
<li>할당에 사용된 이름과 관계없이 고유한 구별이 가능해야 한다.</li>
</ul>
<h4><span id="code">CODE</span></h4>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//특성 1. 리턴값으로 객체를 사용할 수 있어야 한다.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">go</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"go리턴값입니다"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pass</span><span class="params">()</span></span> -&gt; (<span class="type">Void</span>) -&gt; <span class="type">String</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> go	<span class="comment">//함수를 리턴값으로 사용</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = pass()		<span class="comment">// 특성2. 함수를 변수에 저장</span></span><br><span class="line">p() <span class="comment">//"go리턴값입니다"</span></span><br></pre></td></tr></table></figure>
<br>
]]></content>
      
        <categories>
            
            <category> Technology </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 프로그래밍 </tag>
            
            <tag> 함수 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CH13. Closure]]></title>
      <url>/2017/10/26/chap13-closure/</url>
      <content type="html"><![CDATA[<h1><span id="chapter13-closure">CHAPTER13 / Closure</span></h1>
<hr>
<p>클로저는 애플리케이션에서 특정 태스크를 수행하기 위해 사용 될 수 있는 각종 기능들의 개별 묶음을 말한다. 그 예로 함수는 클로저의 일종으로 *‘이름있는 클로저’*라 할 수 있다.</p>
<ul>
<li>클로저는 문법 구조가 간결하다.</li>
<li>클로저는 일회용 함수이다.</li>
<li>온전한 선언 구조를 따르지 않아도 함수와 비슷한 구조를 만들 수 있는 장점이 있다.</li>
<li>유연성 높은 클로저의 구조 덕분에 함수의 인수나 리턴값을 쉽게 전달할 수 있다.</li>
<li>타 언어에서는 <em>람다함수, 익명함수</em> 등으로 불린다.</li>
</ul>
<h5><span id="keulrojeoyi-hyeongsig">클로저의 형식</span></h5>
<ul>
<li>전역함수 : 이름이 있으며, 주변 환경에서 캡쳐할 어떤 값도 없는 클로저</li>
<li>중첩함수 : 이름이 있으며, 자신을 둘러싼 함수내부로부터 값을 캡쳐할 수 있는 클로저</li>
<li>클로저 표현식 : 이름이 없으며, 주변 환경으로 부터 값을 캡쳐할 수 있는 경량 문법으로 작성된 클로저</li>
</ul>
<br>
<h3><span id="keulrojeo-pyohyeonsig">클로저 표현식</span></h3>
<hr>
<ul>
<li>기본적으로 <code>{}</code> 안에 클로저 수식을 두며, <code>in</code> 키워드를 기준으로 파라미터와 리턴 타입을 실행코드와 구별시킨다.</li>
<li>클로저를 통해 밖에 따로 함수를 정의하고 사용하는 것이아니라, 인수 안에 인라인으로 정의하여 코드가 한결 간결해진다.</li>
<li>반환값이 없을 경우 일반 함수처럼 생략하는 것이 아니라 <em>빈괄호()로 반환값이 없음을 명식적으로 표현</em>해주어야 한다.</li>
<li>단, 파라미터와 반환값의 형식은 <strong>생략이 가능</strong>하다. ( 컴파일러가 클로저 구문을 통해 추론한다)</li>
</ul>
<ul>
<li>
<p>할당된 내부 상수를 인자로 받을때 <code>$0, $1, $2 ...</code>등을 사용 가능하다. ( 단, 할당된 순서대로 매칭된다)</p>
<p>​</p>
</li>
</ul>
<br>
<h4><span id="code-basic">CODE :: Basic</span></h4>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 기본형태</span></span><br><span class="line">&#123;(parameters) -&gt; <span class="keyword">return</span> type <span class="keyword">in</span></span><br><span class="line">    <span class="comment">//코드</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 표현1. 변수에 클로저 할당하기</span></span><br><span class="line"><span class="keyword">let</span> f = &#123; () -&gt; <span class="type">Void</span> <span class="keyword">in</span> </span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"클로저"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f()	<span class="comment">// 실행: 클로저</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//표현2. 전체를 소괄호로 묶어 함수호출연산자 ()를 붙여 실행한다.</span></span><br><span class="line">(&#123; () -&gt; <span class="type">Void</span> <span class="keyword">in</span> </span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"클로저"</span>)</span><br><span class="line">&#125;)()	<span class="comment">//실행: 클로저</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// sorted 함수에서의 클로저 사용예</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> unsortedNum = [<span class="number">10</span>,<span class="number">34</span>,<span class="number">22</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">25</span>, <span class="number">21</span>]</span><br><span class="line"><span class="keyword">let</span> unsortedName = [<span class="string">"hyunah"</span>,<span class="string">"hyunsik"</span>,<span class="string">"wooni"</span>,<span class="string">"alert"</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">//true일경우 인자 위치를 바꾸지 않으며, false일 경우 인자 위치를 변경한다</span></span><br><span class="line"><span class="keyword">let</span> sortNum = unsortedNum.<span class="built_in">sort</span>(by: &#123;</span><br><span class="line">    (i:<span class="type">Int</span>, j:<span class="type">Int</span>) -&gt; <span class="type">Bool</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> i &lt; j</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//아래와 같이 간결화 할 수 있다!!</span></span><br><span class="line"><span class="keyword">let</span> sortNum = unsortedNum.<span class="built_in">sort</span>(by: &#123; <span class="keyword">return</span> $<span class="number">0</span> &lt; $<span class="number">1</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//연산자 함수를 통해 아래와 같이 초 간결하게도 가능하다</span></span><br><span class="line"><span class="keyword">let</span> sortNum = unsortedNum.<span class="built_in">sort</span>(by: &lt; )</span><br></pre></td></tr></table></figure>
<br>
<h4><span id="code-more-simple">CODE :: more simple</span></h4>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sortNum = unsortedNum.sorted(by: &#123; i,j <span class="keyword">in</span> i &lt; j &#125;)</span><br></pre></td></tr></table></figure>
<p>컴파일러가 자동으로 i,j를 인식하여 인수가 두개이며, 이 두 인수를 비교하여 수식의 결과가 Bool 인스턴스 임을 인식하기 때문에 위와 같이 생략 가능하다.<br>
위와 같은 상황에서는 return 값이 하나이기 때문에 생략이 가능하다.</p>
<br>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//예시 1</span></span><br><span class="line"><span class="keyword">let</span> sortNum = unsortedNum.sorted(by: &#123; $<span class="number">0</span> &lt; $<span class="number">1</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//예시 2</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">plus</span><span class="params">(message: String)</span></span> -&gt; (<span class="type">String</span>,<span class="type">String</span>) -&gt; <span class="type">String</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; $<span class="number">1</span> + $<span class="number">0</span> + message &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>$0</code>을 통해서도 축약형 인수명 문법 구조를 적용할 수 있다.<br>
첫번째 인수를 <code>$0</code>으로, 두번째 인수를 <code>$1</code>로 나타내며, 인수가 2개 이상일 경우 <code>$2</code>,<code>$3</code> 등으로도 나타낼 수 있다.</p>
<br>
<h3><span id="hamsuhyeong-peurogeuraeming">함수형 프로그래밍</span></h3>
<hr>
<p>swift는 함수형 프로그래밍을 지향한다.<br>
따라서 함수가 <em>리턴타입</em> 및 <em>파라미터</em>의 역활도 한다.</p>
<h4><span id="code-return">CODE :: return</span></h4>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//return type 역활을 하는 함수</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Bake</span><span class="params">()</span></span> -&gt; (<span class="type">Int</span>,<span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">ovenEnergy</span> <span class="params">(heat:Int, ea: Int )</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> heat + ea</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ovenEnergy</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> macaroon = <span class="type">Bake</span>()</span><br><span class="line"><span class="keyword">let</span> needEnergy = macaroon(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"macaroon needs <span class="subst">\(needEnergy)</span> energy"</span>)</span><br><span class="line"><span class="comment">//출력 : macaroon needs 5 energy</span></span><br></pre></td></tr></table></figure>
<p>위 코드에서 <code>ovenEnergy</code>는 <code>Bake()</code> 함수에서 <strong>리턴타입</strong> 으로 쓰였으며, 중첩된 함수로 쓰였다.</p>
<br>
<h4><span id="code-parameter">CODE :: parameter</span></h4>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//인수 역활을 하는 함수</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Bake</span><span class="params">()</span></span> -&gt; (<span class="type">Int</span>,<span class="type">Int</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">ovenEnergy</span> <span class="params">(heat:Int, ea: Int )</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> heat  &gt; ea</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ovenEnergy</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> macaroon = <span class="type">Bake</span>()</span><br><span class="line"><span class="keyword">let</span> needEnergy = macaroon(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(needEnergy)</span><br><span class="line"><span class="comment">//출력 : false</span></span><br></pre></td></tr></table></figure>
<br>
<h3><span id="keulrojeoyi-teugjing">클로저의 특징</span></h3>
<hr>
<ol>
<li>클로저는 값을 붙잡고 있는다 : 자신의 영역에서 정의된 변수에 캡슐화된 내부 정보를 추적할 수 있다.</li>
<li>클로저는 참조 타입이다. 즉 복사본이 만들어 지는 것이 아니라 그 함수를 가리키도록 설정되는 것이다.</li>
<li>함수형 프로그래밍 피턴을 일부 도입했다.</li>
</ol>
<br>
<h3><span id="hamsuhyeong-peurogeuraeming">함수형 프로그래밍</span></h3>
<hr>
<ul>
<li>
<p><strong>일급 함수(first-class function)</strong> : 다른 함수에서 리턴되거나 인수로 전달 될 수 있고 변수에 저장될 수도 있는 함수.</p>
</li>
<li>
<p><strong>순수 함수(pure function)</strong> : 부작용이 없는 함수. 수정되지 않으며 출력이 언제나 같다(인수에 따라서 출력이 변하지 않는다). 그 예로 수학 함수 대부분은 순수함수이다.</p>
</li>
<li>
<p><strong>불변경성</strong> : <em>mutable</em>은 경시된다.</p>
</li>
<li>
<p>**강력한 타입지정 ** : 강력한 타입 시스템은 <em>코드의 런타임 안전성을 높인다</em> 예를 들어 let은 변경할 수 없는 인스턴스를 선언한다.</p>
</li>
<li>
<p>함수형 프로그래밍의 장점은 <em>코드가 간결</em>해지며 표현력이 높아지고, <em>안정성을 확보</em>할 수 있게된다.</p>
</li>
<li>
<p>스위프트의 함수들은 **일급 객체(first-class-citizen)**를 나타낸다.</p>
</li>
</ul>
<br>
<h3><span id="gocahamsu-higher-order-function">고차함수(higher-order function)</span></h3>
<hr>
<p>인수로 <strong>함수</strong>를 받는 함수.<br>
아래 대표적 고차함수 세가지를 설명한다.</p>
<br>
<h4><span id="map">map(_:)</span></h4>
<hr>
<ul>
<li>배열의 내용물을 변형하는 데 사용할 수 있다. 배열의 내용물을 한 값에서 다른 값으로 <strong>매핑하고</strong> 새 값을 새 배열에 넣는다.</li>
<li>Array 타입에 구현되어 있다.</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> unsortedNum = [<span class="number">10</span>,<span class="number">34</span>,<span class="number">22</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">25</span>, <span class="number">21</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">//map 함수</span></span><br><span class="line"><span class="keyword">let</span> plusNum = unsortedNum.<span class="built_in">map</span> &#123;</span><br><span class="line">    (number: <span class="type">Int</span>) -&gt; <span class="type">Int</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> number + <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(plusNum)</span><br><span class="line"></span><br><span class="line"><span class="comment">//출력 : [20, 44, 32, 11, 10, 35, 31]</span></span><br></pre></td></tr></table></figure>
<p><code>plusNum</code>이라는 새로운 배열에 담았다.</p>
<br>
<h4><span id="filter">filter(_:)</span></h4>
<hr>
<ul>
<li>배열을 어떤 기준에 따라 <em>걸러내는</em> 함수이다.</li>
<li>결과 배열은 테스트를 통과한 원래 배열의 값에 담게 된다.</li>
<li>Array 타입에 구현되어 있다.</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> unsortedNum = [<span class="number">10</span>,<span class="number">34</span>,<span class="number">22</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">25</span>, <span class="number">21</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">//filter 함수</span></span><br><span class="line"><span class="keyword">let</span> filterNum = unsortedNum.<span class="built_in">filter</span>&#123;</span><br><span class="line">    (number: <span class="type">Int</span>) -&gt; <span class="type">Bool</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> number &gt; <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(filterNum)</span><br><span class="line"><span class="comment">//출력 : [34, 22, 25, 21]</span></span><br></pre></td></tr></table></figure>
<br>
<h4><span id="reduce">reduce(<em>:</em>:)</span></h4>
<hr>
<ul>
<li>컬랙션 내 값들을 함수로부터 리턴된 하나의 값으로 축소시킨다.</li>
<li>첫번재 인수는 <strong>처음 더해질 수 있는 초기량</strong> 이며, 두번째 인수는 컬랙션 내 <strong>값이 결합되는 방식을 정하는 클로저</strong> 이다.</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> unsortedNum = [<span class="number">10</span>,<span class="number">34</span>,<span class="number">22</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">25</span>, <span class="number">21</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">//reduce 함수</span></span><br><span class="line"><span class="keyword">let</span> reduceNum = unsortedNum.<span class="built_in">reduce</span>(<span class="number">10</span>) &#123;</span><br><span class="line">    <span class="comment">//값이결합되는 방식의 클로저</span></span><br><span class="line">    (num: <span class="type">Int</span>, sum: <span class="type">Int</span>) -&gt; <span class="type">Int</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> num+sum</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(reduceNum)</span><br><span class="line"><span class="comment">//출력 : 123</span></span><br><span class="line"><span class="comment">// 모든 배열의 값 + 초기값(10) = 123</span></span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> SWIFT </category>
            
        </categories>
        
        
        <tags>
            
            <tag> closure </tag>
            
            <tag> function </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CH12. Function]]></title>
      <url>/2017/10/26/chap12-function/</url>
      <content type="html"><![CDATA[<h1><span id="chapter12-function">CHAPTER12 / Function</span></h1>
<br>
<br>
<h2><span id="hamsu">함수</span></h2>
<hr>
<ul>
<li>구체적인 어떤 <u>task를 수행하는 <strong>코드 집합</strong></u>이다.</li>
<li>파라미터는 함수 안에서 반드시 사용되어야 한다.</li>
<li>파라미터에 이름을 사용할 경우, 외부에서 호출 되었을때 <em>이름을 반드시 참조</em>해야 한다.</li>
</ul>
<ul>
<li><strong>인수(argument)</strong> : 함수가 호출되었을 때 사용되는 일련의 값 자체.</li>
<li><strong>파라미터(parameter)</strong> : 함수를 정의할 때(함수의 입장), 외부로 부터 받아들이는 값.<br>
-&gt; <em>함수에서 <strong>argument</strong>가 <strong>parameter</strong>로써 대입되었다.</em></li>
</ul>
<br>
<h3><span id="paramiteo">파라미터</span></h3>
<hr>
<ul>
<li>파라미터는 <strong>외부 파라미터(extenal parameter)</strong>, **내부 파라미터(inner parameter) 두가지가 있다. 둘다 함께 사용 가능하며 생략도 가능하다.</li>
<li>외부 파라미터는 함수를 호출시 이떤 인수를 넣어야 할지 가독성을 높이기 위해서 사용되며, 내부 파라미터는 함수 내부에서 사용될 때 가독성을 높이기 위해 사용된다.</li>
</ul>
<br>
<h4><span id="code">CODE</span></h4>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendService</span> <span class="params">(name: String, ea: Int)</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\(name)</span>에게 딸기를 <span class="subst">\(ea)</span>개 보낸다."</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sendService(name: <span class="string">"현아공주"</span>, ea: <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//external parameter를 사용할 경우</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendService</span> <span class="params">(to name: String, <span class="number">_</span> ea: Int)</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\(name)</span>에게 딸기를 <span class="subst">\(ea)</span>개 보낸다."</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sendService(to: <span class="string">"현아공주"</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//출력 : 현아공주에게 딸기를 4개 보낸다.</span></span><br></pre></td></tr></table></figure>
<br>
<h3><span id="gabyeon-paramiteo">가변 파라미터</span></h3>
<hr>
<ul>
<li>인수에 해당하는 값을 하나도 전달받지 않을 수도 있고, 여러 개를 받을 수도 있다.</li>
<li>인수로 전달받은 값들은 함수 안에서 <strong>배열의 형태</strong>로 사용된다.</li>
<li>함수는 단 <em>하나의 가변 파라미터</em>만을 갖는다. 순서상 가장 마지막 파라미터 자리에 온다.</li>
<li>입력받은 인자들은 배열로 저장되며, 함수내부에서 <code>for~in</code> 구문으로 사용가능하다.</li>
<li><code>파라미터이름 : String...</code> 형식으로 표현한다.</li>
</ul>
<br>
<h4><span id="code">CODE</span></h4>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendService</span> <span class="params">(ea: Int, name: String...)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> names <span class="keyword">in</span> name &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"<span class="subst">\(names)</span>에게 딸기를 <span class="subst">\(ea)</span>개 보낸다."</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sendService(name: <span class="string">"현아"</span>,<span class="string">"화투"</span>,<span class="string">"병운"</span>,<span class="string">"재석"</span>, ea: <span class="number">7</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//출력:</span></span><br><span class="line">현아에게 딸기를 <span class="number">7</span>개 보낸다.</span><br><span class="line">화투에게 딸기를 <span class="number">7</span>개 보낸다.</span><br><span class="line">병운에게 딸기를 <span class="number">7</span>개 보낸다.</span><br><span class="line">재석에게 딸기를 <span class="number">7</span>개 보낸다.</span><br></pre></td></tr></table></figure>
<br>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">avg</span><span class="params">(grade: Int...)</span></span> -&gt; <span class="type">Int</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> total = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> grade &#123;	<span class="comment">//입력받은 학점들을 for문을 돌면서 저장한다</span></span><br><span class="line">    total += i</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> (total / grade.<span class="built_in">count</span>) 	<span class="comment">//평균학점</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="paramiteoyi-gibongabs">파라미터의 기본값</span></h3>
<hr>
<p>파라미터에는 기본값을 지정할 수 있다. 함수를 호출할 때 <em>인수를 생략</em>해도 된다. (따라서 입력된 인수가 없으면 설정한 default값으로 설정한다.)<br>
<code>ea: Int=10</code> 와 같이 기본값을 설정 가능하다.</p>
<br>
<h4><span id="code">CODE</span></h4>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendService</span> <span class="params">(name: String, ea: Int=<span class="number">10</span>)</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"<span class="subst">\(name)</span>에게 딸기를 <span class="subst">\(ea)</span>개 보낸다."</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sendService(name: <span class="string">"현아"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//출력 : 현아에게 딸기를 10개 보낸다.</span></span><br></pre></td></tr></table></figure>
<br>
<h3><span id="inaus-paramiteo">인아웃 파라미터</span></h3>
<hr>
<p>파라미터값은 변경할 수 없는 상수(<code>let</code>)로 값이 복사되어 전달된다. (값에 의한 전달)</p>
<p>만약 <strong>인아웃 파라미터</strong>를 사용하지 않으면 immutable 값이라 변경불가능하다고 컴파일 에러가 뜬다.</p>
<p>따라서 직접 값을 변경 할 수 없으며 내부에서 값을 변경하여 사용하려면 다른 변수로 값을 복사하여 사용해야 한다.</p>
<p>하지만 <strong>inout 파라미터</strong>를 통해서 파라미터의 실제 값을 변경가능하다. (<strong>참조에 의한 전달</strong>)</p>
<p>inout 파라미터가 붙은 매개변수는 일반 파라미터와 달리 인자값이 전달될 때 새로운 내부 상수를 만들어 복사하는 대신, <strong><em>인자값 자체를 내부로 전달한다.</em></strong>(저장된 메모리주소를 전달)</p>
<ol>
<li>가변 파라미터에는 <code>inout</code>을 적용할 수 없다.</li>
<li><code>inout</code> 파라미터는 기본값을 가질 수 없다.</li>
<li>참조값을 변경하는 것이므로, 상수나 리터럴은 파라미터 타입이 될 수 없다.</li>
<li><code>파라미터이름: inout String</code> 의 형식으로 사용한다.호출된 후 인자 앞에는 <code>&amp;(엠퍼샌드)</code>를 붙어야한다.</li>
</ol>
<p>** <code>&amp;(엠퍼샌드)</code> : 주소 추출 연산자로, 변수나 상수 앞에 붙어 저장된 메모리의 주소를 읽어오는 역활을 한다.</p>
<br>
<h4><span id="code">CODE</span></h4>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">inoutParam</span> <span class="params">(param: <span class="keyword">inout</span> Int)</span></span> &#123;</span><br><span class="line">       param += <span class="number">1</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="built_in">count</span> = <span class="number">1</span></span><br><span class="line">inoutParam(param: &amp;<span class="built_in">count</span>)	</span><br><span class="line"></span><br><span class="line"><span class="comment">// count = 1 -&gt; count = 2</span></span><br></pre></td></tr></table></figure>
<br>
<h3><span id="returngabs-jijeonghagi">return값 지정하기</span></h3>
<hr>
<ul>
<li>return type은 파라미터 옆에 <code>-&gt; String</code> 과 같이 나타내고, return 값은 함수 내부에서 정의한다.</li>
<li>복수 리턴값이 가능하며 <code>-&gt; (파라미터이름1:[type] ,파라미터이름2: [type])</code> 와 같이 표현 가능하다.</li>
<li>복수 리턴값은 <strong>튜플</strong>의 형태로 저장된다.</li>
</ul>
<br>
<h4><span id="code">CODE</span></h4>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendService</span> <span class="params">(name: String, ea: Int, soldOut:  String)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"<span class="subst">\(name)</span>님, <span class="subst">\(soldOut)</span> 매진 되었습니다."</span>)</span><br><span class="line">        <span class="keyword">return</span> ea</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = sendService(name: <span class="string">"현아공주"</span>, ea: <span class="number">10</span>, soldOut: <span class="string">"마카롱"</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"></span><br><span class="line"><span class="comment">//출력: 현아공주님, 마카롱 매진 되었습니다. / 10</span></span><br><span class="line"><span class="comment">// return 값이 있기 때문에, 변수에 담아서 사용해야 한다.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//1개 이상의 리턴값을 튜플로 묶어 반환하기.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendService</span> <span class="params">()</span></span> -&gt; (<span class="type">Int</span>,<span class="type">String</span>)&#123;</span><br><span class="line">  <span class="keyword">let</span> age = <span class="number">27</span></span><br><span class="line">  <span class="keyword">let</span> name = <span class="string">"hyunable"</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> (age,name) 	<span class="comment">//튜플 순서에 맞게 반환해 주면 된다.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//튜플로 된 리턴값을 대입받은 변수사용</span></span><br><span class="line"><span class="comment">//방법 1</span></span><br><span class="line"><span class="keyword">var</span> service = sendService()	<span class="comment">//service에 튜블로 된 리턴값이 담긴다.</span></span><br><span class="line">sevice.<span class="number">0</span>	<span class="comment">// 27</span></span><br><span class="line">service.<span class="number">1</span>	<span class="comment">// hyunable</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 방법 2 : 튜플에 파싱하기</span></span><br><span class="line"><span class="keyword">var</span> (a,b) = sendService()	<span class="comment">//튜플에 리턴값이 파싱되어 저장된다.</span></span><br><span class="line">sevice.a	<span class="comment">// 27</span></span><br><span class="line">service.b	<span class="comment">// hyunable</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//방법 3 : 외부변수명으로 불러오기</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendService</span> <span class="params">()</span></span> -&gt; (a: <span class="type">Int</span>, n: <span class="type">String</span>)&#123;</span><br><span class="line">  <span class="keyword">let</span> age = <span class="number">27</span></span><br><span class="line">  <span class="keyword">let</span> name = <span class="string">"hyunable"</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> (age,name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> service = sendService()</span><br><span class="line">sevice.a	<span class="comment">// 27</span></span><br><span class="line">service.n	<span class="comment">// hyunable</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//튜플에 다른곳에서 여러번 재사용 될 경우엔 편의를 위해서 typealias를 통해서 정의 할 수 있다.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typealias</span> info = (<span class="type">Int</span>,<span class="type">String</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendService</span> <span class="params">()</span></span> -&gt; info&#123;</span><br><span class="line">  <span class="keyword">let</span> age = <span class="number">27</span></span><br><span class="line">  <span class="keyword">let</span> name = <span class="string">"hyunable"</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> (age,name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>
<h3><span id="hamsuyi-jungceob">함수의 중첩</span></h3>
<hr>
<ul>
<li>내부 함수와 외부 함수로 구분할 수 있다.</li>
</ul>
<ul>
<li>내수함수의 개수에 제한이 없다.</li>
<li>내부함수는 <u>외부함수가 실행되는 시점에서 생성되고, 종료되는순간 소멸</u>된다. (내부함수의 Life Cycle)</li>
<li>이 때문에 내부 함수는 외부로 부터 차단될 수 있다. (함수의 <strong>은닉성</strong>이 높아진다.)</li>
<li>외부 함수 내부에 변수와 인스턴스를 공유가능하다. (함수의 <code>{}</code> 시야안에 포함되기 때문이다.)</li>
<li>​</li>
</ul>
<br>
<h3><span id="guard-hamsueseo-jungdoe-bbajyeonaogi">Guard : 함수에서 중도에 빠져나오기</span></h3>
<hr>
<ul>
<li>함수의 시작부분에 써서 검사하여 <strong><em>부적절한 조건일 때</em></strong> 함수 실행 도중에 빠져나와 코드가 실행되지 않도록 할 때 사용한다.</li>
<li><code>if let</code>처럼 쓰인다고 생각하면 된다. (if문의 subset 개념)</li>
<li>if문을 쓰지 않고 guard를 쓰는 이유는, <em>가독성</em> 때문이다.</li>
<li>문법은 <code>guard (조건) else</code> 와 같이 쓰며, 조건이 true 이면 guard문은 그냥 지나쳐가고, <u>false일 경우 else 구문을 수행한 뒤 함수를 바로 종료한다.</u></li>
<li><code>return</code> 혹은 <code>throw</code> 등 종료하는 명령이 존재해야하며, 없을 경우 컴파일 에러가 발생된다.</li>
</ul>
<br>
<h4><span id="code">CODE</span></h4>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello</span> <span class="params">(fullName : <span class="params">(first:String, second: String?, third:String)</span></span></span>)  &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> secondName = fullName.second <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"외자 이름"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"<span class="subst">\(secondName)</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sayHello(fullName: (<span class="string">"정"</span>,<span class="string">"현"</span>,<span class="string">"아"</span>))</span><br><span class="line"><span class="comment">//출력 : 현</span></span><br></pre></td></tr></table></figure>
<br>
<h3><span id="hamsuhyeong-peurogeuraemingyi-jangjeom">함수형 프로그래밍의 장점</span></h3>
<hr>
<ol>
<li>동일한 코드가 여러곳에서 사용될 때 재작성할 필요 없이 함수 호출만으로 처리가 가능하다.</li>
<li>전체 프로세스를 하나의 소스코드에서 연속적으로 작성하는 것 보다 기능 단위로 함수화하면 가독성이 좋아지고, 코드와 로직을 이해하기 쉬워진다.</li>
<li>로직을 변경해야할 때 함수 내부만 수정하면 되므로 유지보수가 용이하다.</li>
</ol>
<br>
<h3><span id="defer-block-jiyeonbeulrog">defer Block (지연블록)</span></h3>
<hr>
<p>메서드에서 코드의 흐름과 상관없이 가장 마지막에 실행되는 블록이다. 작성된 위치와 상관없이 함수의 종료 직전에 실행된다. 종료 시점에 맞추어 처리할 구문이 있다면 <code>defer</code> 구문에 넣어두면 된다.</p>
<ul>
<li>작성된 위치와 상관없이 함수 종료 직전에 실행된다.</li>
<li><code>defer</code>구문을 읽기 전 함수구문이 종료될 경우 <code>defer</code>구문은 실행되지 않는다.</li>
<li>하나의 메서드에서 <code>defer</code> 블록을 여러번 사용가능하다. 단, 실행순서는 가장 아래서부터 역순으로 실행된다.</li>
<li>중첩해서 사용 가능하다. 가장 바깥쪽 <code>defer</code>구문부터 안쪽 구문까지 순차적으로 실행된다.</li>
</ul>
]]></content>
      
        <categories>
            
            <category> SWIFT </category>
            
        </categories>
        
        
        <tags>
            
            <tag> function </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CH11. Set]]></title>
      <url>/2017/10/26/chap11-set/</url>
      <content type="html"><![CDATA[<h1><span id="chapter11-set">CHAPTER11 / Set</span></h1>
<br>
<br>
<h2><span id="jibhab-set">집합(Set)</span></h2>
<hr>
<ul>
<li>서로 연관성이 없는 인스턴스들의 컬렉션 타입</li>
<li>Array와는 다르게 <em>순서가 없으며</em> , 따라서 중복되는 요소도 허용되지 않는다.</li>
<li>hashable 프로토콜을 준수해야 한다.</li>
</ul>
<br>
<h3><span id="collection-type-bigyo">Collection Type 비교</span></h3>
<p><img src="/image/set.png" alt="컬렉션비교"></p>
<br>
<h4><span id="code1-set-saengseong">CODE1 :: set 생성</span></h4>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> refrigerator = <span class="type">Set</span>&lt;<span class="type">String</span>&gt;()</span><br><span class="line">refrigerator.insert(<span class="string">"bread"</span>)</span><br><span class="line">refrigerator.insert(<span class="string">"fruits"</span>)</span><br><span class="line">refrigerator.insert(<span class="string">"water</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">for food in refrigerator &#123;</span></span><br><span class="line"><span class="string">    print(food)</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">//출력 : fruits , bread , water</span></span><br></pre></td></tr></table></figure>
<br>
<h4><span id="code2-arrayyi-literal-munbeob-iyonghayeo-saengseong">CODE2 :: Array의 literal 문법 이용하여 생성</span></h4>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> refrigerator = <span class="type">Set</span>([<span class="string">"bread"</span>,<span class="string">"fruits"</span>,<span class="string">"water"</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> food <span class="keyword">in</span> refrigerator &#123;</span><br><span class="line">    <span class="built_in">print</span>(food)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//출력 : 위와 상동</span></span><br></pre></td></tr></table></figure>
<br>
<h4><span id="code-method">CODE :: method</span></h4>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//특정 요소가 있는지 확인, true,false를 return한다.</span></span><br><span class="line"><span class="keyword">let</span> hasFood = refrigerator.<span class="built_in">contains</span>(<span class="string">"gum"</span>)   <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//합집합</span></span><br><span class="line"><span class="keyword">let</span> commonSet = refrigerator.intersection(freezer)</span><br><span class="line"></span><br><span class="line"><span class="comment">//서로소</span></span><br><span class="line"><span class="comment">// isDisjoint은 교집합이 없을경우 true, 있을경우 false를 return한다.</span></span><br><span class="line"><span class="keyword">let</span> disJoin = refrigerator.isDisjoint(with: freezer)</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> SWIFT </category>
            
        </categories>
        
        
        <tags>
            
            <tag> collection </tag>
            
            <tag> 집합 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[정렬 알고리즘(선택,삽입,버블)]]></title>
      <url>/2017/10/21/sort-selection-insertion/</url>
      <content type="html"><![CDATA[<h1><span id="jeongryeol-algorijeum">정렬 알고리즘</span></h1>
<br>
<br>
<h2><span id="seontaeg-jeongryeol-algorijeum-selection-sort">선택 정렬 알고리즘 (Selection Sort)</span></h2>
<hr>
<p>기준 위치에 맞는 원소를 <strong>선택</strong>해 자리를 교환하는 방식이다. 그 기준에 따라 <strong>최소 선택 정렬</strong>과 <strong>최대 선택 정렬</strong>로 구분되며, 각각 오름차순과 내림차순으로 정렬된다.<br>
<em>단순하게 첫 인덱스부터 배열전체를 돌며 가장 작은값을 차례로 찾아서 정렬하는 방법이다.</em></p>
<br>
<h3><span id="logic">LOGIC</span></h3>
<ol>
<li>정렬 되지 않은 배열의 첫 인덱스부터 <u>가장 작은 배열값</u>을 찾아간다.</li>
<li>가장 작은 값을 찾으면 현재 인덱스의 값과 바꿔준다.</li>
<li>배열의 마지막 인덱스까지 <code>1,2번</code>을 반복한다.</li>
</ol>
<p><img src="/image/select_sort.png" alt="선택정렬"></p>
<br>
<h3><span id="sigan-bogjabdo">시간 복잡도</span></h3>
<p>선택 정렬 알고리즘은 배열의 인덱스가 n일 경우, n-1번 n번 …1번 (즉 Σ(k-1), 단 k=1부터 n까지) 실행하게 되므로,<br>
시간 복잡도는 <code>O(n^2)</code> 이다.</p>
<br>
<h3><span id="gonggan-bogjabdo">공간 복잡도</span></h3>
<p>단 하나의 배열에서만 실행되므로 <code>O(n)</code>이다.</p>
<br>
<h3><span id="swift-code">SWIFT CODE</span></h3>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//주어진 배열</span></span><br><span class="line"><span class="keyword">var</span> arr  = [<span class="number">10</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">//selection sort</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>...arr.<span class="built_in">count</span>-<span class="number">2</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> minIndex = i</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> i+<span class="number">1</span>...arr.<span class="built_in">count</span>-<span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> arr[minIndex] &gt; arr[j] &#123;</span><br><span class="line">            minIndex = j</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    arr.swapAt(i, minIndex)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(arr)    <span class="comment">//출력 :[1, 2, 4, 5, 6, 8, 10]</span></span><br></pre></td></tr></table></figure>
<br>
<h2><span id="sabib-jeongryeol-algorijeum-insert-sort">삽입 정렬 알고리즘 (Insert Sort)</span></h2>
<hr>
<p><em>현재 인덱스값이 어디에 삽입되어야 하는지</em> 해당 위치보다 작은 인덱스값들을 비교하여 찾아가 삽입하는 배열 알고리즘이다.<br>
이번에 정렬해야 하는 값을 <strong>key</strong>라고 부른다. 결과적으로 큰 값이 오른쪽에 쌓이도록 한다.<br>
<em>단순하게 해당 값 앞에 존재하는 값을 모두 비교하며 정렬하는 방식이다.</em></p>
<br>
<h3><span id="logic">LOGIC</span></h3>
<ol>
<li>정렬 하고자 하는 배열의 두번째 인덱스값을 key값으로 선언 후 <u>(현재 인덱스-1)부터 key와 배열값을 비교한다 </u></li>
<li><em>(오름차순으로 정렬한다는 가정하에)</em> 비교시 key값보다 크다면 인덱스를 <em>땡기고(인덱스+1), 작다면 땡겨진 빈 인덱스에 key값이 삽입</em>된다.</li>
<li><code>1,2번</code>을 n번째 인덱스까지 실행한다.</li>
</ol>
<p><img src="/image/insert_sort.png" alt="삽입정렬"></p>
<br>
<h3><span id="sigan-bogjabdo">시간 복잡도</span></h3>
<p>최악의 경우 n-1,n-2 … 1번 비교하게 되므로 시간복잡도는 <code>O(n^2)</code> 이다. 단, 정렬되어 있는 배열일 경우 n-1번씩만 비교해도 되므로 시간복잡도는 <code>Ω(n)</code>이 된다.</p>
<br>
<h3><span id="gonggan-bogjabdo">공간 복잡도</span></h3>
<p>단 하나의 배열에서만 실행되므로 <code>O(n)</code>이다.</p>
<br>
<h3><span id="swift-code">SWIFT CODE</span></h3>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//insertion sort</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>...arr.<span class="built_in">count</span>-<span class="number">1</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> minValue = arr[i]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> j = i-<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> j &gt;= <span class="number">0</span> &amp;&amp; minValue &lt; arr[j] &#123;</span><br><span class="line">        arr[j+<span class="number">1</span>] = arr[j]</span><br><span class="line">        j -= <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">     arr[j+<span class="number">1</span>] = minValue</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(arr)   <span class="comment">//출력 :[1, 2, 4, 5, 6, 8, 10]</span></span><br></pre></td></tr></table></figure>
<br>
<h2><span id="beobeul-jeongryeol-algorijeum-bubble-sort">버블 정렬 알고리즘 (Bubble Sort)</span></h2>
<hr>
<p><strong>두 인접한 원소</strong>를 검사하여 정렬하는 방식이다. 시간복잡도는 높으나 <em>코드가 단순</em>하여 많이 쓰인다. 원소의 이동이 거품이 수면위로 올라가는 듯한 모습을 보여서 붙여진 이름이라고 한다 :)</p>
<br>
<h3><span id="logic">LOGIC</span></h3>
<ol>
<li>정렬 하고자 하는 배열의 첫번째 인덱스값 부터 그다음 인덱스값을 비교한다.</li>
<li><em>(오름차순으로 정렬한다는 가정하에)</em> 두 값을 비교 후 오른쪽 값이 더 작을 경우 자리를 바꿔준다.</li>
<li>인덱스를 한 칸씩 이동하며 n-1번째 인덱스까지 swap을 반복한다.</li>
</ol>
<p><img src="/image/bubble_sort.png" alt="버블정렬"></p>
<br>
<h3><span id="sigan-bogjabdo">시간 복잡도</span></h3>
<p>n-1,n-2 … 1번 비교하게 되므로 시간복잡도는 <code>O(n^2)</code> 이다.</p>
<br>
<h3><span id="gonggan-bogjabdo">공간 복잡도</span></h3>
<p>n개의 인덱스에 대해서 n개의 메모리를 사용하므로 공간 복잡도는 <code>O(n)</code>이다.</p>
<br>
<h3><span id="swift-code">SWIFT CODE</span></h3>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//bubble sort</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>...arr.<span class="built_in">count</span>-<span class="number">2</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">1</span>...arr.<span class="built_in">count</span>-<span class="number">1</span>-i &#123;</span><br><span class="line">        <span class="keyword">if</span> arr[j-<span class="number">1</span>] &gt; arr[j]&#123;</span><br><span class="line">            arr.swapAt(j-<span class="number">1</span>, j)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(arr)</span><br></pre></td></tr></table></figure>
<p><a href="http://hsp1116.tistory.com/33" target="_blank" rel="noopener"># 참조 사이트</a></p>
]]></content>
      
        <categories>
            
            <category> ALGORISM </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 정렬 </tag>
            
            <tag> sort </tag>
            
            <tag> 선택정렬 </tag>
            
            <tag> 삽입정렬 </tag>
            
            <tag> 버블정렬 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CH10. Dictionary]]></title>
      <url>/2017/10/21/chap10-Dictionary/</url>
      <content type="html"><![CDATA[<h1><span id="chapter10-dictionary">CHAPTER10 / Dictionary</span></h1>
<br>
<br>
<h2><span id="digsyeoneori">딕셔너리</span></h2>
<hr>
<ul>
<li><code>Key</code> 와 <code>value</code>의 쌍으로 담아두는 컬렉션 타입이다.</li>
<li>Array 타입은 요소들의 순서가 중요한 컬렉션인 반면 <strong>딕셔너리</strong>는 일련의 정보만 담아두고 필요할 때마다 꺼내오기 적합하다.</li>
<li>Dictionary 타입의 인스턴스에 <code>Key</code>를 제공하면 이와 연결된 <code>value</code> 값이 return 된다.</li>
<li>key값은 중복되면 안된다. 고유한 값이여야 한다.</li>
<li>Dictionary 타입의 키는 반드시 <strong>해시가능 (hashable)</strong> 햐야 한다.</li>
<li><strong>Hash</strong> :: 임이의 크기를 가진 데이터를 고정된 데이터의 크기로 변환시키는 것을 말한다. 이를 이용해 <u>특정한 배열의 인덱스나 인덱스의 데이터값을 이용해 저장하거나 찾을 수 있다.</u></li>
</ul>
<br>
<h3><span id="a-digsyeoneori-mandeulgi">A. 딕셔너리 만들기</span></h3>
<hr>
<ol>
<li>선언하기</li>
</ol>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dict1: <span class="type">Dictionary</span>&lt;<span class="type">String</span>, <span class="type">Double</span>&gt; = [:]</span><br><span class="line"><span class="keyword">var</span> dict2 =  <span class="type">Dictionary</span>&lt;<span class="type">String</span>,<span class="type">Double</span>&gt;()</span><br><span class="line"><span class="keyword">var</span> dict3: [<span class="type">String</span>:<span class="type">Double</span>] = [:]  <span class="comment">// 리터럴 방식 사용</span></span><br><span class="line"><span class="keyword">var</span> dict4 = [<span class="type">String</span>:<span class="type">Double</span>]() <span class="comment">// 초기화 방식 사용</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>딕셔너리에 내용물 넣기</li>
</ol>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dessert = [<span class="string">"에끌레어"</span>:<span class="number">4</span> , <span class="string">"치즈케이크"</span>:<span class="number">2</span>, <span class="string">"타르트"</span>:<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">//사용가능 메서드</span></span><br><span class="line">dessert.<span class="built_in">count</span>   <span class="comment">//3</span></span><br><span class="line">dessert[<span class="string">"에끌레어"</span>]   <span class="comment">//key값으로 value에 접근하기</span></span><br></pre></td></tr></table></figure>
<p>단, <code>dessert[string:]</code>은 값이 없을 수도 있기 때문에 <code>Int?</code> 를 반환한다.</p>
<br>
<h3><span id="b-digsyeoneori-sujeong-mic-jegeohagi">B. 딕셔너리 수정 및 제거하기</span></h3>
<hr>
<ol>
<li>value값 업데이트하기</li>
</ol>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> whatValue :<span class="type">Int</span>? = dessert.updateValue(<span class="number">0</span>, forKey: <span class="string">"치즈케이크"</span>)   <span class="comment">//return 변경전 값 &amp; 옵셔널</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> whatValue = whatValue &#123;</span><br><span class="line">    <span class="built_in">print</span>(whatValue)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>값 추가와 제거</li>
</ol>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dessert[<span class="string">"마카롱"</span>] = <span class="number">3</span>      <span class="comment">//append</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//삭제된 키의 value의 옵셔널 리턴</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> whatdel = dessert.removeValue(forKey: <span class="string">"치즈케이크"</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(whatdel)</span><br><span class="line">&#125; <span class="comment">//remove</span></span><br></pre></td></tr></table></figure>
<br>
<h3><span id="c-rupeu-jeogyonghagi">C. 루프 적용하기</span></h3>
<hr>
<p>Dictionary 타입은 키-값 쌍을 반복 처리할 수 있는 편리한 방법을 제공하고 있다.<br>
키,값에 해당하는 상수들로 분리 구성하고 이를 <code>for-in</code>루프 안에 <strong>튜플</strong> 형태로 두는 방법이다.</p>
<h4><span id="code">CODE</span></h4>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (key,value) <span class="keyword">in</span> dessert &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\(key)</span>가 <span class="subst">\(value)</span>개 남았습니다."</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 출력:</span></span><br><span class="line"><span class="comment">//타르트가 1개 남았습니다.</span></span><br><span class="line"><span class="comment">//마카롱가 3개 남았습니다.</span></span><br><span class="line"><span class="comment">//에끌레어가 4개 남았습니다.</span></span><br></pre></td></tr></table></figure>
<p>키값을 Array에 저장하기</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ateDessert = <span class="type">Array</span>(dessert.keys)</span><br><span class="line"><span class="comment">// 출력 : ["타르트", "마카롱", "에끌레어"]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> ateDessert = <span class="type">Array</span>(dessert.value)</span><br><span class="line"><span class="comment">// 출력 : [1, 3, 4]</span></span><br></pre></td></tr></table></figure>
<br>
]]></content>
      
        <categories>
            
            <category> SWIFT </category>
            
        </categories>
        
        
        <tags>
            
            <tag> collection </tag>
            
            <tag> Dictionary </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CH9. Array]]></title>
      <url>/2017/10/19/chap9-Array/</url>
      <content type="html"><![CDATA[<h1><span id="chapter9-array">CHAPTER9 / Array</span></h1>
<br>
<br>
<h2><span id="baeyeol">배열</span></h2>
<hr>
<p>스위프트의 컬렉션 타입중 하나로 <strong>인덱스</strong>라는 순서가 있는 값들의 컬렉션이다. OJC와 다르게 <em>객체든 비객체든 어떤 종류의 값</em>도 담을 수 있다.</p>
<h3><span id="code">CODE</span></h3>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 명시적 배열선언 -&gt; 초기화를 해야 append 할 수 있다.</span></span><br><span class="line"><span class="keyword">var</span> list: [<span class="type">String</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 타입추론으로 인해 dongBang Array가 String type으로 추론되었다.</span></span><br><span class="line"><span class="keyword">var</span> dongBang = [<span class="string">"최강창민"</span>,<span class="string">"유노윤호"</span>,<span class="string">"영웅재중"</span>]</span><br><span class="line">dongBang.append(<span class="string">"믹키유천"</span>)  <span class="comment">//요소 추가</span></span><br><span class="line">dongBang.append(<span class="string">"시아준수"</span>)</span><br><span class="line">dongBang.remove(at: <span class="number">2</span>)    <span class="comment">//해당 인덱스 요소 삭제</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(dongBang)   <span class="comment">//출력 : ["최강창민", "유노윤호", "믹키유천", "시아준수"]</span></span><br><span class="line"><span class="built_in">print</span>(dongBang.<span class="built_in">count</span>)   <span class="comment">//배열의 크기 -&gt; 출력 : 4</span></span><br><span class="line"><span class="built_in">print</span>(dongBang[<span class="number">0</span>...<span class="number">2</span>])  <span class="comment">//범위적용  -&gt; 출력 : ["최강창민", "유노윤호", "믹키유천"]</span></span><br></pre></td></tr></table></figure>
<br>
<h3><span id="code-a-seobeuseukeuribteureul-tonghan-yosogabs-byeongyeong">CODE : A. 서브스크립트를 통한 요소값 변경</span></h3>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dongBang[<span class="number">3</span>] = <span class="string">"박유천"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">2</span>...<span class="number">3</span> &#123;</span><br><span class="line">    dongBang[i] += <span class="string">"_jyj"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(dongBang[<span class="number">3</span>])    <span class="comment">//출력 : 박유천_jyj</span></span><br></pre></td></tr></table></figure>
<br>
<h3><span id="code-b-insert-peuropeotireul-tonghan-yosogabs-byeongyeong">CODE : B. insert 프로퍼티를 통한 요소값 변경</span></h3>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dongBang.insert(<span class="string">"추가멤버"</span>, at: <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(dongBang[<span class="number">4</span>])    <span class="comment">//출력 : 추가멤버</span></span><br></pre></td></tr></table></figure>
<br>
<h3><span id="code-teugjeong-yosoreul-pohamhago-issneunji-geomsahaneun-method">CODE : 특정 요소를 포함하고 있는지 검사하는 method</span></h3>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 해당 요소를 포함하고 있는지 검사하는 method</span></span><br><span class="line"><span class="keyword">if</span> dongBang.<span class="built_in">contains</span>(<span class="string">"최강창민"</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"exist"</span>)</span><br><span class="line">&#125; <span class="comment">// 출력: exist</span></span><br></pre></td></tr></table></figure>
<ul>
<li>두 배열의 등가가 true로 성립하려면, 배열값뿐만 아니라 인덱스 값도 일치해야 한다.</li>
<li>변경할 수 없는 배열은 let 키워드를 통해 생성 가능하다.</li>
</ul>
<br>
<hr>
<h3><span id="quest1">Quest1</span></h3>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dongBang = ["최강창민", "유노윤호", "영웅재중", "믹키유천", "시아준수"]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>...dongBang.<span class="built_in">count</span> % <span class="number">2</span>  &#123;</span><br><span class="line">    <span class="keyword">var</span> num : <span class="type">Int</span> = dongBang.<span class="built_in">count</span> - (i+<span class="number">1</span>)</span><br><span class="line">    dongBang.swapAt(i, num)</span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">print</span>(dongBang)</span><br><span class="line"></span><br><span class="line"><span class="comment">//출력 : ["시아준수", "믹키유천", "영웅재중", "유노윤호", "최강창민"]</span></span><br></pre></td></tr></table></figure>
<h3><span id="quest2">Quest2</span></h3>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> whatIndex = dongBang.index(of: <span class="string">"영웅재중"</span>)</span><br><span class="line"><span class="comment">// "영웅재중"의 index는 optional(2)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> whatIndex != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// nil이 아닐경우 강제언랩핑해라</span></span><br><span class="line">    <span class="built_in">print</span>(dongBang[whatIndex!])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//출력 : 영웅재중</span></span><br></pre></td></tr></table></figure>
<p>만약 찾는 요소가 배열에 없다면?</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> whatIndex = dongBang.index(of: <span class="string">"현아공주"</span>)</span><br><span class="line"><span class="comment">// "영웅재중"의 index는 optional(2)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span>  whatIndex = whatIndex &#123;</span><br><span class="line">    <span class="built_in">print</span>(dongbang[whatIndex])</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"없는 텍스트입니다."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 출력 : 없는 택스트입니다.</span></span><br></pre></td></tr></table></figure>
<p><a href="https://developer.apple.com/documentation/swift/array" target="_blank" rel="noopener"> # Swift - 공식 사이트 참조</a></p>
]]></content>
      
        <categories>
            
            <category> SWIFT </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ArrayList </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[자료구조]]></title>
      <url>/2017/10/17/algorithm2/</url>
      <content type="html"><![CDATA[<h1><span id="a-jaryogujo">A. 자료구조</span></h1>
<hr>
<ul>
<li>프로그램에서 사용하는 자료를 기억장치의 공간 내에 <strong>저장하는 방법</strong>과 저장된 그룹 내에 존재하는 <strong>자료간의 관계,처리 방법</strong> 등을 연구 및 분석하기 위해 쓰인다.</li>
<li>sort(정렬), 검색(search), 파일 편성 등에 사용된다.</li>
</ul>
<br>
<h2><span id="baeyeol-array">배열(Array)</span></h2>
<hr>
<p>순서대로 번호가 붙어 있는 <em>원소들이 연속적인 형태</em>로 구성되어 있는 형태로 정적인 데이터를 저장하기 위한 가장 기초적인 자료구조이다.<br>
각 원소에 index라는 번호가 붙는데 이를 통해 데이터를 쉽게 다룰 수 있다는 장점이 있다. 다차원 배열도 구성가능하다.</p>
<ul>
<li>배열은 접근속도가 빠르지만 삭제와 삽입이 번거롭다. (새로 생성해서 통으로 옮겨야 한다.)</li>
</ul>
<br>
<h2><span id="yeongyeoldoen-riseuteu-linked-list">연결된 리스트(Linked List)</span></h2>
<hr>
<p><strong>리스트(List)</strong> 는 가장 단순한 자료구조중 하나로 데이터들이 차례대로 연결되어 있는 <strong>선형구조</strong>로 <em>배열 , 스택, 큐, 트리 , 그래프</em> 등을 구현하는 데 사용할 수 있다.</p>
<p>연결 리스트(Linked List)는 <u>노드를 선형으로 연결</u>해 놓은 구조이다.</p>
<ul>
<li>노드는 <code>[데이터]-[포인터]</code> 로 이루어져 있는데 포인터(다음데이터에 대한 주소값)를 이용하여 연결되기 때문에 배열과 다르게 물리적 메모리상에 연속적으로 위치할 필요가 없고 <em>입력,삭제가 편하다</em>.</li>
<li>하지만 첫 노드부터 원하는 위치의 노드까지 검색해야 하기 때문에 접근 속도는 느린 편이다.</li>
<li>희소행렬을 Linked List로 구성하면 메모리 절약에 효율적이다.
<ul>
<li>희소행렬 : 행렬의 값이 대부분 0 으로 이루어져 있는 경우.</li>
</ul>
</li>
<li><code>A-B</code> 로 이루어져있는 연결리스트에 C를 <strong>삽입</strong>하고자 하는 경우에는 A의 포인터는 C를 가리키고 C는 B를 가리키게 하면 노드가 삽입되어 <code>A-C-B</code> 형태의 연결리스트가 된다.</li>
<li><code>A-C-B</code> 로 이루어져있는 연결리스트에 C를 <strong>삭제</strong>하고자 하는 경우에는 <em>삭제전에 A의 포인터는 B를 가리켜</em> <u>연결이 끊어지지 않게</u> 하는 것이 중요하다.</li>
</ul>
<h5><span id="ijungyeongyeolriseuteu">이중연결리스트</span></h5>
<ul>
<li>데이터의 앞,뒤를 가리키는 <strong>선포인터</strong>와 <strong>후포인터</strong>를 갖는다.</li>
<li><em>탐색,삽입,삭제가 용이</em>하지만 포인터가 두개씩 있어서 <em>메모리를 많이 차지</em>하는 단점이 있다.</li>
</ul>
<h5><span id="weonhyeong-yeongyeolriseuteu">원형 연결리스트</span></h5>
<ul>
<li>이중연결리스트에서 마지막 노드의 포인터가 리스트의 종료가 아닌 <u>처음 노드를 다시 가리키는 구조</u>이다.</li>
<li>이중연결리스트에 비해 모든 성능이 뛰어나지만 <em>구현이 어렵다는 단점</em>이 있다.</li>
</ul>
<p><img src="/image/struct_list.png" alt="리스트구조"></p>
<br>
<h2><span id="seutaeg-stack">스택(Stack)</span></h2>
<hr>
<ul>
<li>쌓여있는 더미라는 뜻으로 자료구조적인 특징은 <strong>한쪽끝에서만 데이터를 삽입하고 삭제할 수 있다</strong>는 것이다.</li>
<li><strong>LIFO</strong>(Last-in,First-out) 방식을 따른다.</li>
<li>사용되는 명령어로는 <u>Push(데이터 삽입) , Pop(데이터 꺼내기), Top(스택의 가장 위에 위치한 데이터를 봄)</u>이 있다.</li>
</ul>
<p><img src="/image/struct_stack.png" alt="스택구조"></p>
<br>
<h2><span id="kyu-queue">큐(Queue)</span></h2>
<hr>
<ul>
<li>양쪽 끝이 뚫려있는 형태로 한쪽은 들어가기만하고, 한쪽은 나오기만 한다.</li>
<li><strong>FIFO</strong>(First-in, First-out) 방식을 따른다.</li>
<li>데이터가 들어오는 쪽을 <strong>Head or Front</strong> 라고 부르며 데이터가 나오는 쪽을 <strong>tail or Rear</strong>라고 부른다.</li>
<li>큐에 데이터를 집어 넣은 것을 <strong>Enqueue</strong> 라고 하며, 큐에서 데이터를 빼는 것을 <strong>Dequeue</strong>라고 한다.</li>
<li><strong><em>환형 큐</em></strong>는 길이가 n인 1차원 배열의 큐를 원형으로 만든것으로 배열의 처음과 끝을 연결하여 만든다.
<ul>
<li>오버플로우가 발생했을 경우 <strong>rear의 위치를 이동</strong>시켜 추가로 공간을 확보할 수 있는 장점이 있으며, 포인터만 이동하여 소요시간도 줄일수 있다.</li>
</ul>
</li>
</ul>
<p><img src="/image/struct_queue.png" alt="큐의구조"></p>
<br>
<h2><span id="teuri-tree">트리(Tree)</span></h2>
<hr>
<ul>
<li>
<p>구조중에서 <strong>계층적 구조</strong>를 가진 데이터를 표현할 때 유용하게 쓸 수 있다.</p>
</li>
<li>
<p>tree는 <strong>root</strong>와 <strong>하위 tree</strong>, 자식 노드가 존재하지 않는<strong>leaf</strong>로 이루어지며 상위 데이터를 <strong>parent</strong>, 하위 데이터를 <strong>children</strong>이라고 부른다.</p>
<h4><span id="ijinteuri-binary-tree">이진트리(Binary Tree)</span></h4>
<ul>
<li>어떤 노드의 자식 노드의 수는 최대 <strong>2개</strong>인 이진트리</li>
<li>모든 노드들이 2개의 자식노드를 갖는 트리를 <strong><em>완전이진트리</em></strong> 라고 한다.</li>
</ul>
<h4><span id="ijintamsaegteuri-binary-search-tree-bst">이진탐색트리(Binary Search Tree,BST)</span></h4>
<ul>
<li>
<p>부모 노드를 기준으로 <u>왼쪽 노드들의 값은 더 작고 오른쪽 노드들의 값은 더 크게</u> 만들어 놓은 트리형태이다.</p>
</li>
<li>
<p>이진탐색트리를 생성하는 방법은 들어오는 입력값을 root로 부터 차례대로 저장하되 <u>현재 위치의 노드값보다 큰지 작은지</u> 추적하며 저장하면 된다.</p>
</li>
<li>
<p>이때 주의할 점은 root 값이 <em>전체 원소의 중간값이 아닌 경우</em>에는 <u>한쪽으로 크게 기울어진 트리형태</u>가 될 수 있기 때문에 이를 보정해야할 필요가 있다.</p>
</li>
<li>
<p>삭제할 경우 주의해야 할 case가 있다.</p>
<ul>
<li>삭제할 노드의 자식이 없는 경우 : 노드만 삭제가능</li>
<li>삭제할 노드의 자식이 1개인 경우 : 노드를 삭제하고 자식을 부모로 올린다.</li>
<li>삭제할 노드의 자식이 2개인 경우 : 두 자식중에 하나를 부모노드로 <strong>subtree를 만들어서</strong> 이것을 지우려고하는 노드의 부모노드로 연결하면 된다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/image/struct_tree.png" alt="트리구조"></p>
]]></content>
      
        <categories>
            
            <category> ALGORISM </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Data_Structure </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[알고리즘의 정의]]></title>
      <url>/2017/10/15/algorithm/</url>
      <content type="html"><![CDATA[<h1><span id="a-keompyuteo-algorijeumyi-jeongyi">A. 컴퓨터 알고리즘의 정의</span></h1>
<hr>
<p>컴퓨터는 주어진 문제(problem)를 해결하기 위해 여러 산술연산 및 논리연산을 수행하는 다목적 장치이다. 컴퓨터 알고리즘은 이러한 컴퓨터를 이용하여 <u>문제를 풀기위한 방법을 <strong>과정</strong>이나 <strong>절차</strong>를 이용</u>하여 만들어 놓은 것이다.</p>
<ul>
<li>컴퓨터가 문제를 풀려면 <em>무엇을 실행해야 하는지</em>를 정의해야한다.</li>
<li>정의 후에는 컴퓨터가 할 수 있는 일로 변환시켜 주어야 한다.
<ul>
<li>컴퓨터가 할 수 있는 가장 작은 기본 작업의 형태로 만들고 이를 순차적으로 나열해준다.</li>
</ul>
</li>
</ul>
<br>
<h2><span id="keompyuteo-algorijeumyi-4gaji-dangye">컴퓨터 알고리즘의 4가지 단계</span></h2>
<ul>
<li>
<p><strong>문제 정의 (Program Definition)</strong><br>
문제를 컴퓨터가 이해하고 풀 수 있는 형태로 바꾸어 준다.</p>
</li>
<li>
<p><strong>알고리즘 설명 (algorithm Description)</strong><br>
문제를 풀기 위해 수행해야하는 작업을 순서대로 나열해 놓은 것</p>
</li>
<li>
<p><strong>정확성 증명 (Correctness Proof)</strong><br>
주어진 알고리즘을 수행했을 때 문제를 풀 수 있는지를 증명하는 과정이다.</p>
<ul>
<li>부분 정확성 : 문제의 해답을 <strong>정확히</strong> 찾는가?</li>
<li>전체 정확성 : 문제의 해답을 찾을 뿐만 아니라 <strong>정상적으로 알고리즘</strong>이 종료하는가?</li>
</ul>
</li>
<li>
<p><strong>성능평가 (Performance Analysis)</strong><br>
알고리즘이 어떤 문제를 풀기 위해서 필요한 시간이나 공간 혹은 그 외의 자원들이 얼마나 되는지를 비교하기 위해 사용한다.</p>
<p>​</p>
<br>
<p>​</p>
</li>
</ul>
<h1><span id="b-algorijeumyi-seongneungbunseog">B. 알고리즘의 성능분석</span></h1>
<hr>
<h2><span id="jeomgeunjeog-pyogibeob-asymptotic-notation">점근적 표기법 (Asymptotic Notation)</span></h2>
<p>알고리즘이 주어진 데이터의 크기를 기준으로 수행시간 혹은 사용공간이 얼마나 되는지를 객관적으로 비교할 수 있는 기준을 제시해 준다.</p>
<ul>
<li>
<p><strong>O(빅오) 표기법</strong><br>
점근적 상한선을 의미한다. 즉 알고리즘의 <strong>최악의 성능</strong>을 표시해준다. 아무리 나빠도 비교하는 함수와 같거나 좋다는 뜻이다.<br>
<u>‘아무리 최악의 상황이라도 이정도의 성능을 보장할 수 있다’</u> 는 것을 증명하기 위해 가장 많이 쓰이는 방법이다.</p>
</li>
<li>
<p><strong>Ω(오메가) 표기법</strong><br>
점근적 하한선을 의미한다. 즉 알고리즘의 <strong>최고의 성능</strong>을 표시해준다. 아무리 좋아도 비교하는 함수와 같거나 나쁘다는 뜻이다.</p>
</li>
<li>
<p><strong>θ(세타) 표기법</strong><br>
점근적 상한선과 점근적 하한선의 교집합을 의미한다. 주어진 함수가 아무리 좋아지거나 나빠져도 비교하는 함수의 범위안에 있다는 뜻이다.</p>
</li>
</ul>
<p><img src="/image/notation.png" alt="점근적 표기법"></p>
<br>
<h2><span id="seongneungbigyoyi-daesang">성능비교의 대상</span></h2>
<ul>
<li>
<p>산술 연산 (사칙연산)</p>
</li>
<li>
<p>데이터 이동 연산 (copy, move, save, load)</p>
</li>
<li>
<p>제어 연산 (if, while ,register)</p>
<p>​<br>
<a href="http://openparadigm.tistory.com/20" target="_blank" rel="noopener">* 빅오 표기법 참고 Blog</a></p>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> ALGORISM </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 알고리즘 정의 </tag>
            
            <tag> 공간복잡도 </tag>
            
            <tag> 시간복잡도 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CH8. Optional]]></title>
      <url>/2017/10/14/chap8-optional/</url>
      <content type="html"><![CDATA[<h1><span id="chapter8-optional">CHAPTER8 / Optional</span></h1>
<br>
<br>
<h2><span id="obsyeoneol">옵셔널</span></h2>
<hr>
<p>옵셔널(Optional)은 어떤 인스턴스 <em>값이 없을 수도 있다</em>는 일종의 안내다.</p>
<ul>
<li>인스턴스 값이 지정되어 있고 언제든 사용될 수 있다.</li>
<li>인스턴스에 지정된 값이 없다.</li>
<li>값이 없는 인스턴스를 <code>nil</code> 이라 한다.</li>
</ul>
<br>
<h2><span id="obsyeoneol-taib">옵셔널 타입</span></h2>
<hr>
<ul>
<li>일종의 <u>안정장치</u>로써, <strong>nil</strong>이 될 수도 있는 인스턴스는 반드시 옵셔널 타입으로 선언해야한다.</li>
<li>옵셔널 타입이 아니면 <em>nil이 될 수 없다</em>.</li>
<li>옵셔널 이라고 명시함으로 인해서 코드의 가독성과 안정성이 높아진다.</li>
<li>옵셔널 타입은 언래핑하지 않으면 변수에 지정하지 못한다. (wrapping되어 있음.)</li>
</ul>
<h3><span id="code">CODE</span></h3>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> yesOrNoString: <span class="type">String</span>?</span><br><span class="line">yesOrNoString = <span class="string">"옵셔널"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//출력: Optional("옵셔널")</span></span><br></pre></td></tr></table></figure>
<p>만약 위 코드에서 <code>yesOrNoString</code>에 아무값도 넣어주지 않았다면, <code>nil</code>을 출력한다.<br>
nil이 아니라면 <code>Optional(&quot;&lt;string&gt;&quot;)</code>과 같이 옵셔널에 쌓여 출력된다.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> yesOrNoString: <span class="type">String</span>?</span><br><span class="line"><span class="comment">//yesOrNoString = "옵셔널"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> yesOrNoString != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="type">String</span> = yesOrNoString!</span><br><span class="line">    <span class="built_in">print</span>(<span class="type">String</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"run-time error"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//출력: 옵셔널</span></span><br></pre></td></tr></table></figure>
<p>위와 같이 강제 언래핑으로 (<code>yesOrNoString!</code> ) yesOrNoString에 강제 엑세스를 할 수 있다.<br>
그러나 강제 언래핑 시에 해당 값이 nil 일 경우 run-time error로 crash 될수 있다.<br>
때문에 반드시 <em>nil이 아닌지 검사 후</em> 언래핑 해야 한다.</p>
<br>
<h2><span id="obsyeoneol-bainding-binding">옵셔널 바인딩(binding)</span></h2>
<hr>
<p>어떤 옵셔널 값의 유무를 판단할 수 있는 유용한 패턴이다.<br>
옵셔널에 값이 있다면 상수나 변수에 그 값을 지정할 수 있다.<br>
값이 있다면 변수에 넣고 해당 변수로 코드를 실행할 수 있다.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> box : <span class="type">String</span>? = <span class="string">"고양이"</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> object  = box &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\(object)</span>가 들어있다"</span>)</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"nil이다"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="obsyeoneol-ceining">옵셔널 체이닝</span></h2>
<ul>
<li>옵셔널에 값의 유무를 판단하는 할 수 있다.</li>
<li>사슬처럼 연달아 이어서 조회할 수 있다.</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> emptyPoket:[<span class="type">String</span>]?</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> pocket:[<span class="type">String</span>]?</span><br><span class="line">pocket = [<span class="string">"ball"</span>,<span class="string">"candy"</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">//옵셔널 체이닝</span></span><br><span class="line"><span class="comment">//1. 객체가 nil인 경우</span></span><br><span class="line"><span class="comment">//emptyPocket에 값이 있니?-&gt; nil이 아니면 remove 메서드를 실행해라.</span></span><br><span class="line">emptyPoket?.remove(at: <span class="number">0</span>)</span><br><span class="line">​~~~~~~~~~~~</span><br><span class="line"></span><br><span class="line"><span class="comment">//객체가 nil이므로 nil확인 후 종료, 메서드 실행 x</span></span><br><span class="line"><span class="built_in">print</span>(emptyPoket)  <span class="comment">//출력 :nill</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 객체가 nill이 아닐 경우</span></span><br><span class="line">pocket?.remove(at: <span class="number">0</span>)</span><br><span class="line">​~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(pocket)   <span class="comment">// 인덱스 0이 삭제되어, "candy"출력</span></span><br></pre></td></tr></table></figure>
<br>
<h2><span id="nil-gyeolhab-yeonsanja">nil 결합 연산자</span></h2>
<ul>
<li>옵셔널을 처리할 때는 값을 가져오거나 옵셔널이 nil일 때 기본값을 사용하는 것이 일반적이다.</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> description = errorDescription ?? <span class="string">"No error"</span></span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> SWIFT </category>
            
        </categories>
        
        
        <tags>
            
            <tag> optional </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CH6. String]]></title>
      <url>/2017/10/14/chap7-string/</url>
      <content type="html"><![CDATA[<h1><span id="chapter7-string">CHAPTER7 / String</span></h1>
<br>
<br>
<h2><span id="munjayeol">문자열</span></h2>
<hr>
<ul>
<li>문자열은 <code>&quot; &quot;</code>안에 넣어 선언한다.</li>
<li>문자들의 배열이다. 그러나 인덱스로 문자열에 접근할 수 없다.</li>
</ul>
<ul>
<li>아래와 같은 방법으로 <strong>구간추출</strong>이 가능하다</li>
</ul>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">let</span> sentence = <span class="string">"hyunah, Princess"</span></span><br><span class="line"><span class="keyword">let</span> start = sentence.startIndex     <span class="comment">//인덱스정보</span></span><br><span class="line"><span class="comment">//출력: Index(_compoundOffset: 0, _cache: Swift.String.Index._Cache.utf16)</span></span><br><span class="line"><span class="keyword">let</span> end = sentence.index(start, offsetBy: <span class="number">4</span>)  <span class="comment">//인덱스정보</span></span><br><span class="line"><span class="comment">//출력: Index(_compoundOffset: 16, _cache: Swift.String.Index._Cache.character(1))</span></span><br><span class="line"><span class="keyword">let</span> fifthCharacter = sentence[end]      <span class="comment">//출력: a</span></span><br><span class="line"><span class="keyword">let</span> range = start...end</span><br><span class="line"><span class="keyword">let</span> firstFive = sentence[range]     <span class="comment">//출력:hyuna</span></span><br></pre></td></tr></table></figure>
<p>start 와 end에 인덱스 정보를 담고, 그것을 통해서 <code>문자열변수[end]</code> 로 접근하여 구간추출을 한다.</p>
<p>다른방법으로는 메소드를 통해서 제어할 수 있다.</p>
<h3><span id="code">CODE</span></h3>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"hyuna"</span></span><br><span class="line">name += <span class="string">" jeong"</span></span><br><span class="line"><span class="built_in">print</span>(name)   <span class="comment">//출력: hyuna jeong</span></span><br></pre></td></tr></table></figure>
<h2><span id="yunikodeu">유니코드</span></h2>
<hr>
<ul>
<li>문자들을 같은 방식으로 처리하고 표현할 수 있도록 약속한 국제 표준이다.</li>
<li>유니코드의 모든 문자에는 고유 번호가 지정되어 있다.</li>
<li>String과 Charactre 타입은 유니코드를 바탕으로 만들어졌다.</li>
<li><strong>유니코드 스칼라</strong>는 유니코드 표준의 특정 문자를 나타내는 21비트짜리 수이다.</li>
</ul>
]]></content>
      
        <categories>
            
            <category> SWIFT </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 문자열 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CH5. Roof]]></title>
      <url>/2017/10/14/chap6-roof/</url>
      <content type="html"><![CDATA[<h1><span id="chapter6-roof">CHAPTER6 / ROOF</span></h1>
<br>
<br>
<h2><span id="for-rupeu">for 루프</span></h2>
<hr>
<ul>
<li>for 루프는 인스턴스의 특정 요소들을 반복 처리해야 하는 상황에서 <em>반복 횟수</em>를 알수 있을 때 이상적으로 사용할 수 있다.</li>
<li>루프의 현재 반복 횟수를 나타내는 iterator는 루프안에서만 존재한다.<br>
이터레이터 값은 루프에 제공된 구간의 첫번째 값이다.</li>
<li>i대신 _(와일드카드)를 사용할 수 있다.</li>
<li><strong>where</strong>를 사용하여 조건에 만족할 때만 루프코드가 실행되도록 할 수 있다.</li>
</ul>
<h3><span id="code">CODE</span></h3>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> inning:<span class="type">Int</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>...<span class="number">5</span> <span class="keyword">where</span> i % <span class="number">2</span> == <span class="number">0</span>&#123;</span><br><span class="line">    inning += <span class="number">1</span></span><br><span class="line">    inning</span><br><span class="line">    <span class="built_in">print</span>(inning)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//출력: 1 2</span></span><br></pre></td></tr></table></figure>
<br>
<h2><span id="while-rupeu">while 루프</span></h2>
<hr>
<ul>
<li>어떤 조건이 충족될 때까지 반복 처리한다.</li>
<li>이터레이터를 초기화하고 , 조건을 판단하며, 조건이 유효할때 코드를 실행한다.</li>
<li>조건을 잘 설정하여 <em>무한루프</em>에 빠지지 않도록 주의한다.</li>
</ul>
<h3><span id="code">CODE</span></h3>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> i &lt; <span class="number">6</span> &#123;</span><br><span class="line">    inning += <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(inning)</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>
<h2><span id="repeat-while-rupeu">repeat-while 루프</span></h2>
<hr>
<ul>
<li>타 언어의 <strong>do-while</strong> 문과 흡사하다.</li>
<li>적어도 <strong>한 번 실행</strong>하고 조건을 판단한다.</li>
</ul>
<h3><span id="code">CODE</span></h3>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">repeat</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"일어나"</span>)</span><br><span class="line">&#125; <span class="keyword">while</span> inning &gt; <span class="number">0</span></span><br></pre></td></tr></table></figure>
<br>
## 제어권 전달문
- - -
* 루프에서는 ``countinue`` 를 통해 다음 조건문으로 제어권을 전달한다.
* ``break``를 통해서 제어문을 벗어날 수 있다.
]]></content>
      
        <categories>
            
            <category> SWIFT </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 반복문 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CH5. Switch]]></title>
      <url>/2017/10/14/chap5-switch/</url>
      <content type="html"><![CDATA[<h1><span id="chapter5-switch">CHAPTER5 / SWITCH</span></h1>
<br>
<br>
<h2><span id="switch-gibonmunbeob">Switch 기본문법</span></h2>
<hr>
<p>if/else는 조건을 boolean값으로만 판단했다면,<br>
switch는 특정 값에 따라 <strong>경우의 수</strong>를 나눠 판단한다.</p>
<h3><span id="code">CODE</span></h3>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> message: <span class="type">String</span></span><br><span class="line"><span class="keyword">var</span> food:<span class="type">String</span> = <span class="string">"beef"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> food &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"vagitable"</span>,<span class="string">"fruit"</span>:</span><br><span class="line">    message = <span class="string">"야채"</span></span><br><span class="line">    <span class="comment">// 해당값에 따른 코드 실행</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">"beef"</span>:</span><br><span class="line">    message = <span class="string">"소고기"</span></span><br><span class="line">    <span class="keyword">fallthrough</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    message = <span class="string">"기타등등"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(food)     <span class="comment">//출력 : beef</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>마지막 줄의 <code>default</code>는 <strong><em>반드시 삽입해 주어야 한다</em></strong>.  왜냐하면 실행할 수 있는 구문이 적어도 하나는 존재하여야 하기 때문이다.</p>
</li>
<li>
<p>case에 여러가지 조건을 콤마로 나열할 수 있다.</p>
<ul>
<li><code>case 300...307:</code>과 같이 구간으로 설정할 수도 있다.</li>
<li><strong>구간 대조 문법</strong>은 앞뒤 숫자를 포함하여 그 사이의 모든 값까지 나타내는 범위다.</li>
</ul>
</li>
<li>
<p><code>fallthrough</code>라는 <em>제어권 전달문</em>을 사용할 수 있다.</p>
<ul>
<li><code>fallthrough</code>는 현재 case가 가지고 있는 제어권을 바로 아래(다음)case로 '전달하라’고 switch에 알린다.</li>
<li>기존 OJC의 switch문과 다르게 break 없이 만족하는 case를 만나면 자동으로 실행을 멈춘다. 따라서 다음 case로 통과 시키고 싶다면 <code>fallthrough</code>를 쓴다.</li>
</ul>
</li>
</ul>
<br>
<h2><span id="gabs-bainding">값 바인딩</span></h2>
<hr>
<h3><span id="code">CODE</span></h3>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> message: <span class="type">String</span></span><br><span class="line"><span class="keyword">var</span> food:<span class="type">String</span> = <span class="string">"soil"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> food &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"vagitable"</span>:</span><br><span class="line">    message = <span class="string">"야채"</span></span><br><span class="line">    <span class="comment">// 해당값에 따른 코드 실행</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">"beef"</span>:</span><br><span class="line">    message = <span class="string">"소고기"</span></span><br><span class="line">    <span class="comment">// 해당값에 따른 코드 실행</span></span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> unkownFood:</span><br><span class="line">    message = <span class="string">"<span class="subst">\(unkownFood)</span> 는 존재하지 않는 음식입니다."</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    message = <span class="string">"음식아님"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(message)     <span class="comment">//출력 : soil 는 존재하지 않는 음식입니다.</span></span><br></pre></td></tr></table></figure>
<p>아랫줄에 <code>let unkownFood:</code>와 같이 조건절에 변수를 선언하여 실행절에서 대조되는 기준값을 변수에 <strong>묶을(bind)</strong> 수 있다. 단, 변수는 해당 case안에서만 사용가능 하다.</p>
<p>그러나 위와 같은 방법도 있으나, default 실행절에서 대조되는 값의 변수명(ex,food)을 <code>\(food)</code> 로 바인딩하여 위 구문을 대체할 수 있다.</p>
<br>
<h2><span id="where">WHERE</span></h2>
<hr>
<p>조건절에 where을 이용하여 조건절을 쓸 수 있다</p>
<h3><span id="code">CODE</span></h3>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> message: <span class="type">String</span></span><br><span class="line"><span class="keyword">var</span> food:<span class="type">String</span> = <span class="string">"candy"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> food &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"vagitable"</span>:</span><br><span class="line">    message = <span class="string">"야채"</span></span><br><span class="line">    <span class="comment">// 해당값에 따른 코드 실행</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">"beef"</span>:</span><br><span class="line">    message = <span class="string">"소고기"</span></span><br><span class="line">    <span class="comment">// 해당값에 따른 코드 실행</span></span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> unkownFood <span class="keyword">where</span> unkownFood == <span class="string">"candy"</span> || unkownFood == <span class="string">"coffee"</span>:</span><br><span class="line">    message = <span class="string">"<span class="subst">\(unkownFood)</span> 는 존재하지 않는 음식입니다."</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    message = <span class="string">"음식아님"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(message)     <span class="comment">//출력 : candy 는 존재하지 않는 음식입니다.</span></span><br></pre></td></tr></table></figure>
<br>
<h2><span id="tyupeulgwa-paeteon-daejo">튜플과 패턴 대조</span></h2>
<hr>
<ul>
<li><strong>튜플</strong>은 논리적 <em>연관성이 있는 둘 이상의 값</em>을 한데 묶은 일종의 유한 집합이다. 리턴값은 순서 리스트의 구조를 갖는다.</li>
<li>논리적 연관성을 드러내기 위해 사용한다.</li>
<li>튜플 요소에 이름을 붙일 수 있다.</li>
</ul>
<h3><span id="code">CODE</span></h3>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> message: <span class="type">String</span></span><br><span class="line"><span class="keyword">var</span> food:<span class="type">String</span> = <span class="string">"candy"</span></span><br><span class="line"><span class="keyword">var</span> foodNumber:<span class="type">Int</span> = <span class="number">3</span></span><br><span class="line"><span class="keyword">let</span> foodType = (type:food, number: foodNumber)          <span class="comment">//튜플</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> foodType &#123;</span><br><span class="line"><span class="keyword">case</span> (<span class="string">"vagitable"</span>,<span class="number">_</span>),(<span class="string">"fruit"</span>,<span class="number">_</span>):</span><br><span class="line">    message = <span class="string">"야채"</span></span><br><span class="line">    <span class="comment">// 해당값에 따른 코드 실행</span></span><br><span class="line"><span class="keyword">case</span> (<span class="string">"beef"</span>,<span class="number">2</span>):</span><br><span class="line">    message = <span class="string">"소고기"</span></span><br><span class="line">    <span class="comment">// 해당값에 따른 코드 실행</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    message = <span class="string">"음식아님"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(foodType.number)     <span class="comment">//출력 : 3</span></span><br></pre></td></tr></table></figure>
<p>위와 같이 튜플의 값에 <code>foodType.number</code>와 같이 <em>[튜플변수명.요소이름]</em> 으로 접근하며,<br>
(_)는 빈칸의 뜻으로 <em>아무 값이 와도 상관없다</em>는 와일드카드다.</p>
<br>
<h2><span id="if-case-mun">if-case 문</span></h2>
<hr>
<ul>
<li>if문의 조건절에 패턴대조를 사용한다.</li>
<li>조건절에 콤마로 구분하여 한개 이상의 조건을 넣을 수 있다.</li>
<li>swtich문의 default를 쓰지 않아도 되며, if문처럼 한가지 조건만 다루지 않아도 된다.</li>
</ul>
<h3><span id="code">CODE</span></h3>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">case</span> <span class="number">2</span>...<span class="number">10</span> = foodNumber, foodNumber &lt; <span class="number">5</span>   &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"suitable !!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//출력 : suitable !!</span></span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> SWIFT </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 조건문 </tag>
            
            <tag> 튜플 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CH4. Number]]></title>
      <url>/2017/10/13/chap4-number/</url>
      <content type="html"><![CDATA[<h1><span id="chapter4-su-number">CHAPTER4 / 수(number)</span></h1>
<br>
<br>
<h2><span id="jeongsu-integer">정수(Integer)</span></h2>
<hr>
<p>macOS에서 Int는 64bit 정수이다.</p>
<p>Int의 범위를 알아보려면 <code>\(Int.max)</code> 혹은 <code>\(Int.min)</code>으로 최대값,최소값 확인이 가능하다.<br>
Int의 범위를 넘어선 값을 저장하면 <strong>over flow</strong>되기 때문에 유의해야 한다.<br>
스위프트에서는 암묵적으로 정수값을 선언하면 Int 인스턴스로 판단하지만, 명시적으로 선언하면 다른 정수타입의 인스턴스도 만들 수 있다.</p>
<ul>
<li>Int&lt;bit크기&gt; : 크기가 &lt;bit크기&gt;인 정수타입.</li>
<li>UInt&lt;bit크기&gt; : 크기가 &lt;bit크기&gt;인 양의 정수타입.</li>
</ul>
<p>하지만 특별한 경우 아닌 이상 일반적으로 많이 사용되지는 않는다.<br>
또한 UInt로 선언된 변수에 음수값을 넣어주면 오류가 난다.</p>
<br>
## 연산자
- - -
<ul>
<li>기본적으로 <code>+ , - , /(몫) , % (나머지값)</code> 의 연산자를 제공한다.</li>
<li>연산자는 모두 <code>+=</code> 과 <code>-=</code> 와 같은 형태로 줄여쓰기가 가능하다.</li>
</ul>
<br>
<h3><span id="obeopeulro-eondeopeulro-yeonsanja">오버플로/언더플로 연산자</span></h3>
<p>연산 후 결과가 저장되는 변수값의 범위를 벗어난다면(over/under flow), 컴파일러는 오류를 낸다.<br>
이러한 오류를 최소화하기 위해 <em>오버플로/언더플로 연산자</em>를 쓰면 범위 내에서 <strong>반대방향으로 되돌아가게</strong> 된다.</p>
<h4><span id="code">CODE</span></h4>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> y: <span class="type">Int8</span>  = <span class="number">120</span></span><br><span class="line"><span class="keyword">let</span> z = y &amp;+ <span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(z)</span><br></pre></td></tr></table></figure>
<p>Int8의 경우 <u>max값이 <strong>127</strong> / min값이 <strong>-128</strong></u>이다.<br>
위와 같은 경우 z또한 Int8로 인식되며, <em>120+10 = 130</em>은 범위를 초과하게 된다.<br>
그러나 위와 같이 오버프로 연산자 <code>&amp;+</code> 를  사용하면 범위의 초과되는 수 많큼 반대방향 범위로 넘어가게 된다.<br>
따라서 결과 값은 <strong>-126</strong> 이 된다.<br>
( 언더플로의 경우는 언더플로 연산자인 <code>&amp;-</code>를 사용한다. )</p>
<br>
<h2><span id="budongsosujeomsu">부동소수점수</span></h2>
<hr>
<ul>
<li>스위프트에서는 부동소수점수 타입으로 <strong>Float</strong>(32bit)와 <strong>Double</strong>(64bit)를 제공한다.</li>
<li>부동소수점은 컴퓨터에 근사값으로 저장되므로 <u><strong>Float</strong>보다는 <strong>Double</strong>이 더 정확한 근삿값</u>을 저장한다.</li>
<li>부동소수점수의 default는 <strong>Double</strong>이며 , 정수처럼 명시적 선언이 가능하다.</li>
<li>단, 부동소수점수는 근사값이기 때문에 부동소수점수끼리 <code>==</code> 조건문은 불가능하다.</li>
</ul>
]]></content>
      
        <categories>
            
            <category> SWIFT </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Integer </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CH3. Conditional]]></title>
      <url>/2017/10/13/chap3-conditional/</url>
      <content type="html"><![CDATA[<h1><span id="chapter3-jogeon">CHAPTER3 / 조건</span></h1>
<br>
<br>
## 기본 if/else 문
- - -
<p><img src="/image/if_else.png" alt="비교연산자"></p>
<p>특이한 점은 <code>===</code> 가 타입까지 같은지가 아닌 <em>같은 참조값</em> 을 가리키는지 추적한다는 것이다.</p>
<p><img src="/image/logical.png" alt="논리연산자"></p>
<p>기존 타 언어의 논리연산자와 동일하다.</p>
<br>
<h3><span id="code">CODE</span></h3>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> age: <span class="type">Int</span> = <span class="number">26</span></span><br><span class="line"><span class="keyword">var</span> message: <span class="type">String</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> age &lt;= <span class="number">26</span>&#123;</span><br><span class="line">  message = <span class="string">"<span class="subst">\(age)</span>살은 아직 어립니다."</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">    message = <span class="string">"<span class="subst">\(age)</span>살은 어른입니다."</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(message)</span><br></pre></td></tr></table></figure>
<h3><span id="result">RESULT</span></h3>
<blockquote>
<p><strong>26</strong>살은 아직 어립니다.</p>
</blockquote>
<br>
<h2><span id="samhangyeonsanja">삼항연산자</span></h2>
<hr>
<ul>
<li><code>A ? B : C</code> 의 형태를 갖으며, <code>A가 참이면 B를, 그렇지 않으면 C를 이행하라</code> 라고 해석한다.</li>
<li><em>간결한 조건문</em>을 사용할 시 적합하다.</li>
<li>복잡한 조건문은 if/else 문을 사용하는 것이 가독성이 좋다.</li>
</ul>
<br>
<h3><span id="code">CODE</span></h3>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">message = age &lt;= <span class="number">26</span> ?  <span class="string">"<span class="subst">\(age)</span>살은 아직 어립니다."</span> : <span class="string">"<span class="subst">\(age)</span>살은 어른입니다."</span></span><br><span class="line"><span class="built_in">print</span>(message)</span><br></pre></td></tr></table></figure>
<p>결과값은 위와 같다.</p>
<br>
<h2><span id="ijung-ifmun">이중 if문</span></h2>
<hr>
<ul>
<li>경우의 수가 둘 이상일 때는 if문을 중첩해서 사용한다.</li>
<li>다수의 조건을 판단할 경우 <strong>switch</strong> 혹은 <strong>else if문</strong>을 사용한다</li>
</ul>
<br>
<h3><span id="code">CODE</span></h3>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> age: <span class="type">Int</span> = <span class="number">45</span></span><br><span class="line"><span class="keyword">var</span> message: <span class="type">String</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> age &lt;= <span class="number">26</span> &#123;</span><br><span class="line">    message = <span class="string">"<span class="subst">\(age)</span>살은 아직 어립니다."</span></span><br><span class="line">&#125;<span class="keyword">else</span>  &#123;</span><br><span class="line">    <span class="keyword">if</span> (age/<span class="number">10</span>) == <span class="number">4</span>  &#123;</span><br><span class="line">      message = <span class="string">"<span class="subst">\(age)</span>살은 40대 입니다."</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      message = <span class="string">"<span class="subst">\(age)</span>살은 40대가 아닙니다."</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(message)</span><br></pre></td></tr></table></figure>
<h3><span id="result">RESULT</span></h3>
<blockquote>
<p><strong>45</strong>살은 40대 입니다.</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> SWIFT </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 조건문 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CH2. Varialble]]></title>
      <url>/2017/10/13/chap2-variable/</url>
      <content type="html"><![CDATA[<h1><span id="chapter2-taib-sangsu-byeonsu">CHAPTER2 / 타입 , 상수, 변수</span></h1>
<br>
<br>
<h2><span id="taib">타입</span></h2>
<hr>
<ul>
<li>변수와 상수에는 데이터 타입이 있으며, 데이터 처리방식에 대한 정보를 컴파일러에 제공한다.</li>
<li>변수에 엉뚱한 데이터 타입을 지정하지 않도록 <strong>type checking</strong> 기능을 제공한다.</li>
<li><code>변수명: type</code> 과 같은 <strong>타입 어노테이션</strong> 문법을 사용하여 명시적 선언이 가능하다.</li>
</ul>
<br>
<h4><span id="code">CODE</span></h4>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> numberOfStoplights = <span class="string">"Six"</span></span><br><span class="line">numberOfStoplights += <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>위와 같은 경우 <em>String과 Int</em>로 다른 타입의 인스턴스기 때문에 Error가 발생한다.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> numberOfStoplights: <span class="type">Int</span> = <span class="number">6</span></span><br><span class="line">numberOfStoplights += <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>위와 같이 변수의 데이터 타입을 통일시켜 줘야한다.</p>
<br>
<h2><span id="sangsu-vs-byeonsu">상수 vs 변수</span></h2>
<hr>
<ul>
<li><code>let</code>을 통해 상수를 선언한다. <em>String 타입도 선언 가능하다</em>.</li>
<li><code>var</code>을 통해 변수를 선언한다.</li>
<li>항상 고정값인 인스턴스는 <strong>상수(let)</strong>, 가변적인 인스턴스는 <strong>변수(var)</strong> 로 선언한다.</li>
</ul>
<br>
<h3><span id="code">CODE</span></h3>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> numberOfStoplights: <span class="type">Int</span> = <span class="number">6</span></span><br><span class="line">numberOfStoplights += <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p><code>numberOfStoplights</code>는 <strong>상수</strong>로 선언되었기 때문에 위 코드에서는 에러가 발생한다.</p>
<br>
<h2><span id="munjayeol-sabib">문자열 삽입</span></h2>
<hr>
<ul>
<li><code>\()</code> 문법은 어떤 인스턴스 값에 엑세스하여 그값을 새 <em>String 인스턴스</em> 안에 삽입하는 것이다.</li>
</ul>
<br>
<h3><span id="code">CODE</span></h3>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> car: <span class="type">Int</span> = <span class="number">4</span></span><br><span class="line"><span class="keyword">let</span> townName: <span class="type">String</span> = <span class="string">"Seoul"</span></span><br><span class="line"><span class="keyword">var</span> population: <span class="type">Int</span> = <span class="number">1004</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> townDescription =</span><br><span class="line"><span class="string">"<span class="subst">\(townName)</span> has a populaion of <span class="subst">\(population)</span> and <span class="subst">\(car)</span> Cars."</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(townDescription)</span><br></pre></td></tr></table></figure>
<h3><span id="result">RESULT</span></h3>
<blockquote>
<p><strong>Seoul</strong> has a populaion of <strong>1004</strong> and <strong>4</strong> Cars.</p>
</blockquote>
<hr>
<br>
<h2><span id="example">Example</span></h2>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> townName: <span class="type">String</span> = <span class="string">"Seoul"</span></span><br><span class="line"><span class="keyword">var</span> population: <span class="type">Int</span> = <span class="number">1004</span></span><br><span class="line"><span class="keyword">var</span>  unemploymentRate: <span class="type">Int</span> = <span class="number">38</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> townDescription =</span><br><span class="line"><span class="string">"<span class="subst">\(townName)</span> 's unemployment rate is about <span class="subst">\(unemploymentRate)</span> percent ."</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(townDescription)</span><br></pre></td></tr></table></figure>
<h3><span id="result">RESULT</span></h3>
<blockquote>
<p><strong>Seoul 's</strong> unemployment rate is about <strong>38</strong> percent .</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> SWIFT </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 변수 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CH1. Swift]]></title>
      <url>/2017/10/13/chap1-Swift/</url>
      <content type="html"><![CDATA[<h1><span id="chapter1-seuwipeuteu-sijaghagi">CHAPTER1 / 스위프트 시작하기</span></h1>
<hr>
<ul>
<li>설치 및 환경설정은 생략.</li>
<li><strong>playground</strong>는 스위프트 코드를 빠르게 개발,점검하기 위한 인터렉티브 환경이다.</li>
<li>단, Xcode의 모든 기능을 담고 있지 않으므로, 가벼운 테스트에 적합하다.</li>
<li><strong>import</strong> 문은 프레임 워크를 가져오는 행이다.</li>
</ul>
<br>
<h4><span id="code">CODE</span></h4>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">"hello, playground"</span></span><br><span class="line">str += <span class="string">"!"</span></span><br></pre></td></tr></table></figure>
<br>
<br>
]]></content>
      
        <categories>
            
            <category> SWIFT </category>
            
        </categories>
        
        
    </entry>
    
  
  
</search>
